var EightBittr;
(function (EightBittr_1) {
    "use strict";
    /**
     * An abstract class used exclusively as the parent of GameStartr. EightBittr
     * contains useful functions for manipulating Things that are independent of
     * the required GameStartr modules.
     */
    var EightBittr = (function () {
        /**
         * Initializes a new instance of the EightBittr class. Constants are copied
         * onto the EightBittr from the designated source.
         *
         * @param settings   Any optional custom settings.
         */
        function EightBittr(settings) {
            if (settings === void 0) { settings = {}; }
            var EightBitter = EightBittr.prototype.ensureCorrectCaller(this), constants = settings.constants, constantsSource = settings.constantsSource || EightBitter, i;
            EightBitter.unitsize = settings.unitsize || 1;
            EightBitter.constants = constants;
            if (constants) {
                for (i = 0; i < constants.length; i += 1) {
                    EightBitter[constants[i]] = constantsSource[constants[i]];
                }
            }
        }
        /* Resets
        */
        /**
         * Resets the EightBittr by calling all of the named reset member Functions
         * on itself.
         *
         * @param EightBitter
         * @param resets   The ordered Array of reset Functions to be called.
         * @param customs   Additional arguments to pass to all reset Functions.
         */
        EightBittr.prototype.reset = function (EightBitter, resets, customs) {
            var reset, i;
            EightBitter.customs = customs;
            for (i = 0; i < resets.length; i += 1) {
                reset = resets[i];
                if (!EightBitter[reset]) {
                    throw new Error(reset + " is missing on a resetting EightBittr.");
                }
                EightBitter[reset](EightBitter, customs);
            }
        };
        /**
         * Resets the EightBittr in a timed manner by calling all the named reset
         * member Functions on itself and adding the time (in milliseconds) along
         * along with the total process time to an Array, which is then returned.
         *
         * @param EightBitter
         * @param resets   The ordered Array of reset Functions to be called.
         * @param customs   Additional arguments to pass to all reset Functions.
         */
        EightBittr.prototype.resetTimed = function (EightBitter, resets, customs) {
            var timeStartTotal = performance.now(), timeEndTotal, timeStart, timeEnd, i;
            this.resetTimes = {
                order: resets,
                times: []
            };
            for (i = 0; i < resets.length; i += 1) {
                timeStart = performance.now();
                EightBitter[resets[i]](EightBitter, customs);
                timeEnd = performance.now();
                this.resetTimes.times.push({
                    "name": resets[i],
                    "timeStart": timeStart,
                    "timeEnd": timeEnd,
                    "timeTaken": timeEnd - timeStart
                });
            }
            timeEndTotal = performance.now();
            this.resetTimes.total = {
                "name": "resetTimed",
                "timeStart": timeStartTotal,
                "timeEnd": timeEndTotal,
                "timeTaken": timeEndTotal - timeStartTotal
            };
        };
        /* HTML Functions
        */
        /**
         * Creates and returns a new HTML <canvas> element with no image smoothing.
         *
         * @param width   How wide the canvas should be.
         * @param height   How tall the canvas should be.
         * @returns A canvas of the given width and height height.
         */
        EightBittr.prototype.createCanvas = function (width, height) {
            var canvas = document.createElement("canvas"), 
            // context: CanvasRenderingContext2D = canvas.getContext("2d");
            context = canvas.getContext("2d");
            canvas.width = width;
            canvas.height = height;
            // For speed's sake, disable image smoothing in the first supported browsers
            if (typeof context.imageSmoothingEnabled !== "undefined") {
                context.imageSmoothingEnabled = false;
            }
            else if (typeof context.webkitImageSmoothingEnabled !== "undefined") {
                context.webkitImageSmoothingEnabled = false;
            }
            else if (typeof context.mozImageSmoothingEnabled !== "undefined") {
                context.mozImageSmoothingEnabled = false;
            }
            else if (typeof context.msImageSmoothingEnabled !== "undefined") {
                context.msImageSmoothingEnabled = false;
            }
            else if (typeof context.oImageSmoothingEnabled !== "undefined") {
                context.oImageSmoothingEnabled = false;
            }
            return canvas;
        };
        /* Physics functions
        */
        /**
         * Shifts a Thing vertically by changing its top and bottom attributes.
         *
         * @param thing   The Thing to shift vertically.
         * @param dy   How far to shift the Thing.
         */
        EightBittr.prototype.shiftVert = function (thing, dy) {
            thing.top += dy;
            thing.bottom += dy;
        };
        /**
         * Shifts a Thing horizontally by changing its left and right attributes.
         *
         * @param thing   The Thing to shift horizontally.
         * @param dy   How far to shift the Thing.
         */
        EightBittr.prototype.shiftHoriz = function (thing, dx) {
            thing.left += dx;
            thing.right += dx;
        };
        /**
         * Sets the top of a Thing to a set number, changing the bottom based on its
         * height and the EightBittr's unisize.
         *
         * @param thing   The Thing to shift vertically.
         * @param top   Where the Thing's top should be.
         */
        EightBittr.prototype.setTop = function (thing, top) {
            thing.top = top;
            thing.bottom = thing.top + thing.height * thing.EightBitter.unitsize;
        };
        /**
         * Sets the right of a Thing to a set number, changing the left based on its
         * width and the EightBittr's unisize.
         *
         * @param thing   The Thing to shift horizontally.
         * @param top   Where the Thing's right should be.
         */
        EightBittr.prototype.setRight = function (thing, right) {
            thing.right = right;
            thing.left = thing.right - thing.width * thing.EightBitter.unitsize;
        };
        /**
         * Sets the bottom of a Thing to a set number, changing the top based on its
         * height and the EightBittr's unisize.
         *
         * @param thing   The Thing to shift vertically.
         * @param top   Where the Thing's bottom should be.
         */
        EightBittr.prototype.setBottom = function (thing, bottom) {
            thing.bottom = bottom;
            thing.top = thing.bottom - thing.height * thing.EightBitter.unitsize;
        };
        /**
         * Sets the left of a Thing to a set number, changing the right based on its
         * width and the EightBittr's unisize.
         *
         * @param thing   The Thing to shift horizontally.
         * @param top   Where the Thing's left should be.
         */
        EightBittr.prototype.setLeft = function (thing, left) {
            thing.left = left;
            thing.right = thing.left + thing.width * thing.EightBitter.unitsize;
        };
        /**
         * Shifts a Thing so that it is horizontally centered on the given x.
         *
         * @param thing   The Thing to shift horizontally.
         * @param x   Where the Thing's horizontal midpoint should be.
         */
        EightBittr.prototype.setMidX = function (thing, x) {
            thing.EightBitter.setLeft(thing, x - thing.width * thing.EightBitter.unitsize / 2);
        };
        /**
         * Shifts a Thing so that it is vertically centered on the given y.
         *
         * @param thing   The Thing to shift vertically.
         * @param y   Where the Thing's vertical midpoint should be.
         */
        EightBittr.prototype.setMidY = function (thing, y) {
            thing.EightBitter.setTop(thing, y - thing.height * thing.EightBitter.unitsize / 2);
        };
        /**
         * Shifts a Thing so that it is centered on the given x and y.
         *
         * @param thing   The Thing to shift vertically and horizontally.
         * @param x   Where the Thing's horizontal midpoint should be.
         * @param y   Where the Thing's vertical midpoint should be.
         */
        EightBittr.prototype.setMid = function (thing, x, y) {
            thing.EightBitter.setMidX(thing, x);
            thing.EightBitter.setMidY(thing, y);
        };
        /**
         * @param thing
         * @returns The horizontal midpoint of the Thing.
         */
        EightBittr.prototype.getMidX = function (thing) {
            return thing.left + thing.width * thing.EightBitter.unitsize / 2;
        };
        /**
         * @param thing
         * @returns The vertical midpoint of the Thing.
         */
        EightBittr.prototype.getMidY = function (thing) {
            return thing.top + thing.height * thing.EightBitter.unitsize / 2;
        };
        /**
         * Shifts a Thing so that its midpoint is centered on the midpoint of the
         * other Thing.
         *
         * @param thing   The Thing to be shifted.
         * @param other   The Thing whose midpoint is referenced.
         */
        EightBittr.prototype.setMidObj = function (thing, other) {
            thing.EightBitter.setMidXObj(thing, other);
            thing.EightBitter.setMidYObj(thing, other);
        };
        /**
         * Shifts a Thing so that its horizontal midpoint is centered on the
         * midpoint of the other Thing.
         *
         * @param thing   The Thing to be shifted horizontally.
         * @param other   The Thing whose horizontal midpoint is referenced.
         */
        EightBittr.prototype.setMidXObj = function (thing, other) {
            thing.EightBitter.setLeft(thing, thing.EightBitter.getMidX(other)
                - (thing.width * thing.EightBitter.unitsize / 2));
        };
        /**
         * Shifts a Thing so that its vertical midpoint is centered on the
         * midpoint of the other Thing.
         *
         * @param thing   The Thing to be shifted vertically.
         * @param other   The Thing whose vertical midpoint is referenced.
         */
        EightBittr.prototype.setMidYObj = function (thing, other) {
            thing.EightBitter.setTop(thing, thing.EightBitter.getMidY(other)
                - (thing.height * thing.EightBitter.unitsize / 2));
        };
        /**
         * @param thing
         * @param other
         * @returns Whether the first Thing's midpoint is to the left of the other's.
         */
        EightBittr.prototype.objectToLeft = function (thing, other) {
            return (thing.EightBitter.getMidX(thing) < thing.EightBitter.getMidX(other));
        };
        /**
         * Shifts a Thing's top up, then sets the bottom (similar to a shiftVert and
         * a setTop combined).
         *
         * @param thing   The Thing to be shifted vertically.
         * @param dy   How far to shift the Thing vertically.
         */
        EightBittr.prototype.updateTop = function (thing, dy) {
            // If a dy is provided, move the thing's top that much
            thing.top += dy || 0;
            // Make the thing's bottom dependent on the top
            thing.bottom = thing.top + thing.height * thing.EightBitter.unitsize;
        };
        /**
         * Shifts a Thing's right, then sets the left (similar to a shiftHoriz and a
         * setRight combined).
         *
         * @param thing   The Thing to be shifted horizontally.
         * @param dx   How far to shift the Thing horizontally.
         */
        EightBittr.prototype.updateRight = function (thing, dx) {
            // If a dx is provided, move the thing's right that much
            thing.right += dx || 0;
            // Make the thing's left dependent on the right
            thing.left = thing.right - thing.width * thing.EightBitter.unitsize;
        };
        /**
         * Shifts a Thing's bottom down, then sets the bottom (similar to a
         * shiftVert and a setBottom combined).
         *
         * @param thing   The Thing to be shifted vertically.
         * @param dy   How far to shift the Thing vertically.
         */
        EightBittr.prototype.updateBottom = function (thing, dy) {
            // If a dy is provided, move the thing's bottom that much
            thing.bottom += dy || 0;
            // Make the thing's top dependent on the top
            thing.top = thing.bottom - thing.height * thing.EightBitter.unitsize;
        };
        /**
         * Shifts a Thing's left, then sets the right (similar to a shiftHoriz and a
         * setLeft combined).
         *
         * @param thing   The Thing to be shifted horizontally.
         * @param dx   How far to shift the Thing horizontally.
         */
        EightBittr.prototype.updateLeft = function (thing, dx) {
            // If a dx is provided, move the thing's left that much
            thing.left += dx || 0;
            // Make the thing's right dependent on the left
            thing.right = thing.left + thing.width * thing.EightBitter.unitsize;
        };
        /**
         * Shifts a Thing toward a target x, but limits the total distance allowed.
         * Distance is computed as from the Thing's horizontal midpoint.
         *
         * @param thing   The Thing to be shifted horizontally.
         * @param x   How far to shift the Thing horizontally.
         * @param maxDistance   The maximum distance the Thing can be shifted.
         */
        EightBittr.prototype.slideToX = function (thing, x, maxDistance) {
            var midx = thing.EightBitter.getMidX(thing);
            // If no maxSpeed is provided, assume Infinity (so it doesn't matter)
            maxDistance = maxDistance || Infinity;
            // Thing to the left? Slide to the right.
            if (midx < x) {
                thing.EightBitter.shiftHoriz(thing, Math.min(maxDistance, x - midx));
            }
            else {
                // Thing to the right? Slide to the left.
                thing.EightBitter.shiftHoriz(thing, Math.max(-maxDistance, x - midx));
            }
        };
        /**
         * Shifts a Thing toward a target y, but limits the total distance allowed.
         * Distance is computed as from the Thing's vertical midpoint.
         *
         * @param thing   The Thing to be shifted vertically.
         * @param x   How far to shift the Thing vertically.
         * @param maxDistance   The maximum distance the Thing can be shifted.
         */
        EightBittr.prototype.slideToY = function (thing, y, maxDistance) {
            var midy = thing.EightBitter.getMidY(thing);
            // If no maxSpeed is provided, assume Infinity (so it doesn't matter)
            maxDistance = maxDistance || Infinity;
            // Thing above? slide down.
            if (midy < y) {
                thing.EightBitter.shiftVert(thing, Math.min(maxDistance, y - midy));
            }
            else {
                // Thing below? Slide up.
                thing.EightBitter.shiftVert(thing, Math.max(-maxDistance, y - midy));
            }
        };
        /* EightBittr utilities
        */
        /**
         * Ensures the current object is an EightBittr by throwing an error if it
         * is not. This should be used for functions in any EightBittr descendants
         * that have to call 'this' to ensure their caller is what the programmer
         * expected it to be.
         *
         * @param current   The scope that should be an EightBittr.
         */
        EightBittr.prototype.ensureCorrectCaller = function (current) {
            if (!(current instanceof EightBittr)) {
                throw new Error("A function requires the caller ('this') to be the "
                    + "manipulated EightBittr object. Unfortunately, 'this' is a "
                    + typeof (this) + ".");
            }
            return current;
        };
        /* General utilities
        */
        /**
         * "Proliferates" all properties of a donor onto a recipient by copying each
         * of them and recursing onto child Objects. This is a deep copy.
         *
         * @param recipient   An object to receive properties from the donor.
         * @param donor   An object do donoate properties to the recipient.
         * @param noOverride   Whether pre-existing properties of the recipient should
         *                     be skipped (defaults to false).
         * @returns recipient
         */
        EightBittr.prototype.proliferate = function (recipient, donor, noOverride) {
            if (noOverride === void 0) { noOverride = false; }
            var setting, i;
            // For each attribute of the donor:
            for (i in donor) {
                if (donor.hasOwnProperty(i)) {
                    // If noOverride, don't override already existing properties
                    if (noOverride && recipient.hasOwnProperty(i)) {
                        continue;
                    }
                    // If it's an object, recurse on a new version of it
                    setting = donor[i];
                    if (typeof setting === "object") {
                        if (!recipient.hasOwnProperty(i)) {
                            recipient[i] = new setting.constructor();
                        }
                        this.proliferate(recipient[i], setting, noOverride);
                    }
                    else {
                        // Regular primitives are easy to copy otherwise
                        recipient[i] = setting;
                    }
                }
            }
            return recipient;
        };
        /**
         * Identical to proliferate, but instead of checking whether the recipient
         * hasOwnProperty on properties, it just checks if they're truthy.
         *
         * @param recipient   An object to receive properties from the donor.
         * @param donor   An object do donoate properties to the recipient.
         * @param noOverride   Whether pre-existing properties of the recipient should
         *                     be skipped (defaults to false).
         * @returns recipient
         */
        EightBittr.prototype.proliferateHard = function (recipient, donor, noOverride) {
            var setting, i;
            // For each attribute of the donor:
            for (i in donor) {
                if (donor.hasOwnProperty(i)) {
                    // If noOverride, don't override already existing properties
                    if (noOverride && recipient[i]) {
                        continue;
                    }
                    // If it's an object, recurse on a new version of it
                    setting = donor[i];
                    if (typeof setting === "object") {
                        if (!recipient[i]) {
                            recipient[i] = new setting.constructor();
                        }
                        this.proliferate(recipient[i], setting, noOverride);
                    }
                    else {
                        // Regular primitives are easy to copy otherwise
                        recipient[i] = setting;
                    }
                }
            }
            return recipient;
        };
        /**
         * Identical to proliferate, but tailored for HTML elements because many
         * element attributes don't play nicely with JavaScript Array standards.
         * Looking at you, HTMLCollection!
         *
         * @param recipient   An HTMLElement to receive properties from the donor.
         * @param donor   An object do donoate properties to the recipient.
         * @param noOverride   Whether pre-existing properties of the recipient should
         *                     be skipped (defaults to false).
         * @returns recipient
         */
        EightBittr.prototype.proliferateElement = function (recipient, donor, noOverride) {
            if (noOverride === void 0) { noOverride = false; }
            var setting, i, j;
            // For each attribute of the donor:
            for (i in donor) {
                if (donor.hasOwnProperty(i)) {
                    // If noOverride, don't override already existing properties
                    if (noOverride && recipient.hasOwnProperty(i)) {
                        continue;
                    }
                    setting = donor[i];
                    // Special cases for HTML elements
                    switch (i) {
                        // Children and options: just append all of them directly
                        case "children":
                        case "children":
                            if (typeof (setting) !== "undefined") {
                                for (j = 0; j < setting.length; j += 1) {
                                    recipient.appendChild(setting[j]);
                                }
                            }
                            break;
                        // Style: proliferate (instead of making a new Object)
                        case "style":
                            this.proliferate(recipient[i], setting);
                            break;
                        // By default, use the normal proliferate logic
                        default:
                            // If it's null, don't do anything (like .textContent)
                            if (setting === null) {
                                recipient[i] = null;
                            }
                            else if (typeof setting === "object") {
                                // If it's an object, recurse on a new version of it
                                if (!recipient.hasOwnProperty(i)) {
                                    recipient[i] = new setting.constructor();
                                }
                                this.proliferate(recipient[i], setting, noOverride);
                            }
                            else {
                                // Regular primitives are easy to copy otherwise
                                recipient[i] = setting;
                            }
                            break;
                    }
                }
            }
            return recipient;
        };
        /**
         * Creates and returns an HTMLElement of the specified type. Any additional
         * settings Objects may be given to be proliferated onto the Element via
         * proliferateElement.
         *
         * @param type   The tag of the Element to be created.
         * @param settings   Additional settings to proliferated onto the Element.
         * @returns {HTMLElement}
         */
        EightBittr.prototype.createElement = function (tag) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var EightBitter = EightBittr.prototype.ensureCorrectCaller(this), element = document.createElement(tag || "div"), i;
            // For each provided object, add those settings to the element
            for (i = 0; i < args.length; i += 1) {
                EightBitter.proliferateElement(element, args[i]);
            }
            return element;
        };
        /**
         * Follows a path inside an Object recursively, based on a given path.
         *
         * @param object   A container to follow a path inside.
         * @param path   The ordered names of attributes to descend into.
         * @param num   The starting index in path (by default, 0).
         * @returns The discovered property within object, or undefined if the
         *          full path doesn't exist.
         */
        EightBittr.prototype.followPathHard = function (object, path, index) {
            if (index === void 0) { index = 0; }
            for (var i = index; i < path.length; i += 1) {
                if (typeof object[path[i]] === "undefined") {
                    return undefined;
                }
                else {
                    object = object[path[i]];
                }
            }
            return object;
        };
        /**
         * Switches an object from one Array to another using splice and push.
         *
         * @param object    The object to move between Arrays.
         * @param arrayOld   The Array to take the object out of.
         * @param arrayNew   The Array to move the object into.
         */
        EightBittr.prototype.arraySwitch = function (object, arrayOld, arrayNew) {
            arrayOld.splice(arrayOld.indexOf(object), 1);
            arrayNew.push(object);
        };
        /**
         * Sets a Thing's position within an Array to the front by splicing and then
         * unshifting it.
         *
         * @param object   The object to move within the Array.
         * @param array   An Array currently containing the object.
         */
        EightBittr.prototype.arrayToBeginning = function (object, array) {
            array.splice(array.indexOf(object), 1);
            array.unshift(object);
        };
        /**
         * Sets a Thing's position within an Array to the front by splicing and then
         * pushing it.
         *
         * @param object   The object to move within the Array.
         * @param array   An Array currently containing the object.
         */
        EightBittr.prototype.arrayToEnd = function (object, array) {
            array.splice(array.indexOf(object), 1);
            array.push(object);
        };
        /**
         * Sets a Thing's position within an Array to a specific index by splicing
         * it out, then back in.
         *
         * @param object   The object to move within the Array.
         * @param array   An Array currently containing the object.
         * @param index   Where the object should be moved to in the Array.
         */
        EightBittr.prototype.arrayToIndex = function (object, array, index) {
            array.splice(array.indexOf(object), 1);
            array.splice(index, 0, object);
        };
        return EightBittr;
    })();
    EightBittr_1.EightBittr = EightBittr;
    ;
})(EightBittr || (EightBittr = {}));
var GroupHoldr;
(function (GroupHoldr_1) {
    "use strict";
    /**
     * A general storage container for values in keyed Arrays and/or Objects.
     * Manipulation utlities are provided for adding, removing, switching, and
     * applying methods to values.
     */
    var GroupHoldr = (function () {
        /**
         * Initializes a new instance of the GroupHoldr class.
         *
         * @param settings   Settings to be used for initialization.
         */
        function GroupHoldr(settings) {
            if (typeof settings === "undefined") {
                throw new Error("No settings object given to GroupHoldr.");
            }
            if (typeof settings.groupNames === "undefined") {
                throw new Error("No groupNames given to GroupHoldr.");
            }
            if (typeof settings.groupTypes === "undefined") {
                throw new Error("No groupTypes given to GroupHoldr.");
            }
            // These functions containers are filled in setGroupNames 
            this.functions = {
                "setGroup": {},
                "getGroup": {},
                "set": {},
                "get": {},
                "add": {},
                "delete": {}
            };
            this.setGroupNames(settings.groupNames, settings.groupTypes);
        }
        /* Simple gets
        */
        /**
         * @returns The mapping of operation types to each group's Functions.
         */
        GroupHoldr.prototype.getFunctions = function () {
            return this.functions;
        };
        /**
         * @returns The stored object groups, keyed by name.
         */
        GroupHoldr.prototype.getGroups = function () {
            return this.groups;
        };
        /**
         * @param name   The name of the group to retrieve.
         * @returns The group stored under the given name.
         */
        GroupHoldr.prototype.getGroup = function (name) {
            return this.groups[name];
        };
        /**
         * @returns Names of the stored object groups.
         */
        GroupHoldr.prototype.getGroupNames = function () {
            return this.groupNames;
        };
        /* Group/ordering manipulators
        */
        /**
         * Switches an object from one group to another.
         *
         * @param value   The value being moved from one group to another.
         * @param groupNameOld   The name of the group to move out of.
         * @param groupNameNew   The name of the group to move into.
         * @param [keyOld]   What key the value used to be under (required if
         *                   the old group is an Object).
         * @param [keyNew]   Optionally, what key the value will now be under
         *                   (required if the new group is an Object).
         */
        GroupHoldr.prototype.switchMemberGroup = function (value, groupNameOld, groupNameNew, keyOld, keyNew) {
            var groupOld = this.groups[groupNameOld];
            if (groupOld.constructor === Array) {
                this.functions.delete[groupNameOld](value, keyOld);
            }
            else {
                this.functions.delete[groupNameOld](keyOld);
            }
            this.functions.add[groupNameNew](value, keyNew);
        };
        /**
         * Calls a Function for each group, with that group as the first argument.
         * Extra arguments may be passed in an array after scope and func, as in
         * Function.apply's standard.
         *
         * @param scope   An optional scope to call this from (if falsy, defaults
         *                to the calling GroupHoldr).
         * @param func   A Function to apply to each group.
         * @param [args]   Optionally, arguments to pass in after each group.
         */
        GroupHoldr.prototype.applyAll = function (scope, func, args) {
            if (args === void 0) { args = undefined; }
            var i;
            if (!args) {
                args = [undefined];
            }
            else {
                args.unshift(undefined);
            }
            if (!scope) {
                scope = this;
            }
            for (i = this.groupNames.length - 1; i >= 0; i -= 1) {
                args[0] = this.groups[this.groupNames[i]];
                func.apply(scope, args);
            }
            args.shift();
        };
        /**
         * Calls a function for each member of each group. Extra arguments may be
         * passed in an array after scope and func, as in Function.apply's standard.
         *
         * @param scope   An optional scope to call this from (if falsy, defaults
         *                to the calling GroupHoldr).
         * @param func   A Function to apply to each group.
         * @param [args]   Optionally, arguments to pass in after each group.
         */
        GroupHoldr.prototype.applyOnAll = function (scope, func, args) {
            if (args === void 0) { args = undefined; }
            var group, i, j;
            if (!args) {
                args = [undefined];
            }
            else {
                args.unshift(undefined);
            }
            if (!scope) {
                scope = this;
            }
            for (i = this.groupNames.length - 1; i >= 0; i -= 1) {
                group = this.groups[this.groupNames[i]];
                if (group instanceof Array) {
                    for (j = 0; j < group.length; j += 1) {
                        args[0] = group[j];
                        func.apply(scope, args);
                    }
                }
                else {
                    for (j in group) {
                        if (group.hasOwnProperty(j)) {
                            args[0] = group[j];
                            func.apply(scope, args);
                        }
                    }
                }
            }
        };
        /**
         * Calls a Function for each group, with that group as the first argument.
         * Extra arguments may be passed after scope and func natively, as in
         * Function.call's standard.
         *
         * @param scope   An optional scope to call this from (if falsy,
         *                defaults to this).
         * @param func   A Function to apply to each group.
         */
        GroupHoldr.prototype.callAll = function (scope, func) {
            var args = Array.prototype.slice.call(arguments, 1), i;
            if (!scope) {
                scope = this;
            }
            for (i = this.groupNames.length - 1; i >= 0; i -= 1) {
                args[0] = this.groups[this.groupNames[i]];
                func.apply(scope, args);
            }
        };
        /**
         * Calls a function for each member of each group. Extra arguments may be
         * passed after scope and func natively, as in Function.call's standard.
         *
         * @param scope   An optional scope to call this from (if falsy,
         *                defaults to this).
         * @param func   A Function to apply to each group member.
         */
        GroupHoldr.prototype.callOnAll = function (scope, func) {
            var args = Array.prototype.slice.call(arguments, 1), group, i, j;
            if (!scope) {
                scope = this;
            }
            for (i = this.groupNames.length - 1; i >= 0; i -= 1) {
                group = this.groups[this.groupNames[i]];
                if (group instanceof Array) {
                    for (j = 0; j < group.length; j += 1) {
                        args[0] = group[j];
                        func.apply(scope, args);
                    }
                }
                else {
                    for (j in group) {
                        if (group.hasOwnProperty(j)) {
                            args[0] = group[j];
                            func.apply(scope, args);
                        }
                    }
                }
            }
        };
        /**
         * Clears each Array by setting its length to 0.
         */
        GroupHoldr.prototype.clearArrays = function () {
            var group, i;
            for (i = this.groupNames.length - 1; i >= 0; i -= 1) {
                group = this.groups[this.groupNames[i]];
                if (group instanceof Array) {
                    group.length = 0;
                }
            }
        };
        /* Core setup logic
        */
        /**
         * Meaty function to reset, given an Array of names and an object of
         * types. Any pre-existing Functions are cleared, and new ones are added
         * as member objects and to this.functions.
         *
         * @param names   An array of names of groupings to be made
         * @param types   An mapping of the function types of
         *                the names given in names. This may also be taken
         *                in as a String, to be converted to an Object.
         */
        GroupHoldr.prototype.setGroupNames = function (names, types) {
            var scope = this, typeFunc, typeName;
            // If there already were group names, clear them
            if (this.groupNames) {
                this.clearFunctions();
            }
            // Reset the group types and type names, to be filled next
            this.groupNames = names;
            this.groupTypes = {};
            this.groupTypeNames = {};
            // If groupTypes is an object, set custom group types for everything
            if (types.constructor === Object) {
                this.groupNames.forEach(function (name) {
                    scope.groupTypes[name] = scope.getTypeFunction(types[name]);
                    scope.groupTypeNames[name] = scope.getTypeName(types[name]);
                });
            }
            else {
                // Otherwise assume everything uses the same one, such as from a String
                typeFunc = this.getTypeFunction(types);
                typeName = this.getTypeName(types);
                this.groupNames.forEach(function (name) {
                    scope.groupTypes[name] = typeFunc;
                    scope.groupTypeNames[name] = typeName;
                });
            }
            // Create the containers, and set the modifying functions
            this.setGroups();
            this.createFunctions();
        };
        /**
         * Removes any pre-existing "set", "get", etc. functions.
         */
        GroupHoldr.prototype.clearFunctions = function () {
            this.groupNames.forEach(function (name) {
                // Delete member variable functions
                delete this["set" + name + "Group"];
                delete this["get" + name + "Group"];
                delete this["set" + name];
                delete this["get" + name];
                delete this["add" + name];
                delete this["delete" + name];
                // Delete functions under .functions by making each type a new {}
                this.functions.setGroup = {};
                this.functions.getGroup = {};
                this.functions.set = {};
                this.functions.get = {};
                this.functions.add = {};
                this.functions.delete = {};
            });
        };
        /**
         * Resets groups to an empty Object, and fills it with a new groupType for
         * each name in groupNames.
         */
        GroupHoldr.prototype.setGroups = function () {
            var scope = this;
            this.groups = {};
            this.groupNames.forEach(function (name) {
                scope.groups[name] = new scope.groupTypes[name]();
            });
        };
        /**
         * Calls the Function creators for each name in groupNames.
         */
        GroupHoldr.prototype.createFunctions = function () {
            var groupName, i;
            for (i = 0; i < this.groupNames.length; i += 1) {
                groupName = this.groupNames[i];
                this.createFunctionSetGroup(groupName);
                this.createFunctionGetGroup(groupName);
                this.createFunctionSet(groupName);
                this.createFunctionGet(groupName);
                this.createFunctionAdd(groupName);
                this.createFunctionDelete(groupName);
            }
        };
        /* Function generators
        */
        /**
         * Creates a setGroup Function under this and functions.setGroup.
         *
         * @param name   The name of the group, from groupNames.
         */
        GroupHoldr.prototype.createFunctionSetGroup = function (name) {
            var scope = this;
            /**
             * Sets the value of the group referenced by the name.
             *
             * @param value   The new value for the group, which should be
             *                the same type as the group (Array or Object).
             */
            this.functions.setGroup[name] = this["set" + name + "Group"] = function (value) {
                scope.groups[name] = value;
            };
        };
        /**
         * Creates a getGroup Function under this and functions.getGroup.
         *
         * @param name   The name of the group, from groupNames.
         */
        GroupHoldr.prototype.createFunctionGetGroup = function (name) {
            var scope = this;
            /**
             * @param key   The String key that references the group.
             * @returns The group referenced by the given key.
             */
            this.functions.getGroup[name] = this["get" + name + "Group"] = function () {
                return scope.groups[name];
            };
        };
        /**
         * Creates a set Function under this and functions.set.
         *
         * @param name   The name of the group, from groupNames.
         */
        GroupHoldr.prototype.createFunctionSet = function (name) {
            /**
             * Sets a value contained within the group.
             *
             * @param key   The key referencing the value to obtain. This
             *              should be a Number if the group is an Array, or
             *              a String if the group is an Object.
             * @param value   The value to be contained within the group.
             */
            this.functions.set[name] = this["set" + name] = function (key, value) {
                if (value === void 0) { value = undefined; }
                this.groups[name][key] = value;
            };
        };
        /**
         * Creates a get<type> function under this and functions.get
         *
         * @param name   The name of the group, from groupNames.
         */
        GroupHoldr.prototype.createFunctionGet = function (name) {
            /**
             * Gets the value within a group referenced by the given key.
             *
             * @param  key   The key referencing the value to obtain. This
             *               should be a Number if the group is an Array, or
             *               a String if the group is an Object.
             * @param value   The value contained within the group.
             */
            this.functions.get[name] = this["get" + name] = function (key) {
                return this.groups[name][key];
            };
        };
        /**
         * Creates an add function under this and functions.add.
         *
         * @param name   The name of the group, from groupNames.
         */
        GroupHoldr.prototype.createFunctionAdd = function (name) {
            var group = this.groups[name];
            if (this.groupTypes[name] === Object) {
                /**
                 * Adds a value to the group, referenced by the given key.
                 *
                 * @param key   The String key to reference the value to be
                 *              added.
                 * @param value   The value to be added to the group.
                 */
                this.functions.add[name] = this["add" + name] = function (value, key) {
                    group[key] = value;
                };
            }
            else {
                /**
                 * Adds a value to the group, referenced by the given key.
                 *
                 * @param value   The value to be added to the group.
                 */
                this.functions.add[name] = this["add" + name] = function (value, key) {
                    if (key !== undefined) {
                        group[key] = value;
                    }
                    else {
                        group.push(value);
                    }
                };
            }
        };
        /**
         * Creates a delete function under this and functions.delete.
         *
         * @param name   The name of the group, from groupNames.
         */
        GroupHoldr.prototype.createFunctionDelete = function (name) {
            var group = this.groups[name];
            if (this.groupTypes[name] === Object) {
                /**
                 * Deletes a value from the group, referenced by the given key.
                 *
                 * @param key   The String key to reference the value to be
                 *              deleted.
                 */
                this.functions.delete[name] = this["delete" + name] = function (key) {
                    delete group[key];
                };
            }
            else {
                /**
                 * Deletes a value from the group, referenced by the given key.
                 *
                 * @param value The value to be deleted.
                 */
                this.functions.delete[name] = this["delete" + name] = function (value, index) {
                    if (index === void 0) { index = group.indexOf(value); }
                    if (index !== -1) {
                        group.splice(index, 1);
                    }
                };
            }
        };
        /* Utilities
        */
        /**
         * Returns the name of a type specified by a string ("Array" or "Object").
         *
         * @param str   The name of the type. If falsy, defaults to Array
         * @returns The proper name of the type.
         */
        GroupHoldr.prototype.getTypeName = function (str) {
            if (str && str.charAt && str.charAt(0).toLowerCase() === "o") {
                return "Object";
            }
            return "Array";
        };
        /**
         * Returns function specified by a string (Array or Object).
         *
         * @param str   The name of the type. If falsy, defaults to Array
         * @returns The class Function of the type.
         */
        GroupHoldr.prototype.getTypeFunction = function (str) {
            if (str && str.charAt && str.charAt(0).toLowerCase() === "o") {
                return Object;
            }
            return Array;
        };
        return GroupHoldr;
    })();
    GroupHoldr_1.GroupHoldr = GroupHoldr;
})(GroupHoldr || (GroupHoldr = {}));
var MathDecidr;
(function (MathDecidr_1) {
    "use strict";
    /**
     * A computation utility to automate running common equations with access
     * to a set of constant values.
     */
    var MathDecidr = (function () {
        /**
         * Initializes a new instance of the MathDecidr class.
         *
         * @param [settings]   Settings to be used for initialization.
         */
        function MathDecidr(settings) {
            if (settings === void 0) { settings = {}; }
            var i;
            this.constants = settings.constants || {};
            this.equations = {};
            this.equationsRaw = settings.equations || {};
            if (this.equationsRaw) {
                for (i in this.equationsRaw) {
                    if (this.equationsRaw.hasOwnProperty(i)) {
                        this.addEquation(i, this.equationsRaw[i]);
                    }
                }
            }
        }
        /* Simple gets
        */
        /**
         * @returns Useful constants the MathDecidr may use in equations.
         */
        MathDecidr.prototype.getConstants = function () {
            return this.constants;
        };
        /**
         * @param name   The name of a constant to return.
         * @returns The requested constant.
         */
        MathDecidr.prototype.getConstant = function (name) {
            return this.constants[name];
        };
        /**
         * @returns Stored equations with the internal members bound as
         *          their arguments.
         */
        MathDecidr.prototype.getEquations = function () {
            return this.equations;
        };
        /**
         * @returns The raw stored equations, unbound.
         */
        MathDecidr.prototype.getRawEquations = function () {
            return this.equationsRaw;
        };
        /**
         * @param name   The name of the equation to return.
         * @returns The equation under the given name.
         */
        MathDecidr.prototype.getEquation = function (name) {
            return this.equations[name];
        };
        /**
         * @param name   The name of the equation to return.
         * @returns The raw equation under the given name.
         */
        MathDecidr.prototype.getRawEquation = function (name) {
            return this.equationsRaw[name];
        };
        /* Simple additions
        */
        /**
         * Adds a constant of the given name and value.
         *
         * @param name   The name of the constant to add.
         * @param value   A value for the constant.
         */
        MathDecidr.prototype.addConstant = function (name, value) {
            this.constants[name] = value;
        };
        /**
         * Adds an equation Function under the given name.
         *
         * @param name   The name of the equation to add.
         * @param value   A value for the equation.
         */
        MathDecidr.prototype.addEquation = function (name, value) {
            this.equationsRaw[name] = value;
            this.equations[name] = value.bind(this, this.constants, this.equations);
        };
        /* Computations
        */
        /**
         * Runs a stored equation with any number of arguments, returning the result.
         *
         * @param name   The name of the equation to run.
         * @param args   Any arguments to pass to the equation.
         * @returns The result of the equation.
         */
        MathDecidr.prototype.compute = function (name) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            return this.equations[name].apply(this, Array.prototype.slice.call(arguments, 1));
        };
        return MathDecidr;
    })();
    MathDecidr_1.MathDecidr = MathDecidr;
})(MathDecidr || (MathDecidr = {}));
var MapScreenr;
(function (MapScreenr_1) {
    "use strict";
    /**
     * A simple container for Map attributes given by switching to an Area within
     * that map. A bounding box of the current viewport is kept, along with a bag
     * of assorted variable values.
     */
    var MapScreenr = (function () {
        /**
         * Resets the MapScreenr. All members of the settings argument are copied
         * to the MapScreenr itself, though only width and height are required.
         *
         * @param {IMapScreenrSettings} settings
         */
        function MapScreenr(settings) {
            if (typeof settings === "undefined") {
                throw new Error("No settings object given to MapScreenr.");
            }
            if (typeof settings.width === "undefined") {
                throw new Error("No width given to MapScreenr.");
            }
            if (typeof settings.height === "undefined") {
                throw new Error("No height given to MapScreenr.");
            }
            var name;
            for (name in settings) {
                if (settings.hasOwnProperty(name)) {
                    this[name] = settings[name];
                }
            }
            this.variables = settings.variables || {};
            this.variableArgs = settings.variableArgs || [];
        }
        /* State changes
        */
        /**
         * Completely clears the MapScreenr for use in a new Area. Positioning is
         * reset to (0,0) and user-configured variables are recalculated.
         */
        MapScreenr.prototype.clearScreen = function () {
            this.left = 0;
            this.top = 0;
            this.right = this.width;
            this.bottom = this.height;
            this.setMiddleX();
            this.setMiddleY();
            this.setVariables();
        };
        /**
         * Computes middleX as the midpoint between left and right.
         */
        MapScreenr.prototype.setMiddleX = function () {
            this.middleX = (this.left + this.right) / 2;
        };
        /**
         * Computes middleY as the midpoint between top and bottom.
         */
        MapScreenr.prototype.setMiddleY = function () {
            this.middleY = (this.top + this.bottom) / 2;
        };
        /**
         * Recalculates all variables by passing variableArgs to their Functions.
         */
        MapScreenr.prototype.setVariables = function () {
            var i;
            for (i in this.variables) {
                if (this.variables.hasOwnProperty(i)) {
                    this.setVariable(i);
                }
            }
        };
        /**
         * Recalculates a variable by passing variableArgs to its Function.
         *
         * @param name   The name of the variable to recalculate.
         * @param value   A new value for the variable instead of its Function's result.
         * @returns The new value of the variable.
         */
        MapScreenr.prototype.setVariable = function (name, value) {
            this[name] = arguments.length === 1
                ? this.variables[name].apply(this, this.variableArgs)
                : value;
        };
        /* Element shifting
        */
        /**
         * Shifts the MapScreenr horizontally and vertically via shiftX and shiftY.
         *
         * @param dx   How far to scroll horizontally.
         * @param dy   How far to scroll vertically.
         */
        MapScreenr.prototype.shift = function (dx, dy) {
            if (dx) {
                this.shiftX(dx);
            }
            if (dy) {
                this.shiftY(dy);
            }
        };
        /**
         * Shifts the MapScreenr horizontally by changing left and right by the dx.
         *
         * @param dx   How far to scroll horizontally.
         */
        MapScreenr.prototype.shiftX = function (dx) {
            this.left += dx;
            this.right += dx;
        };
        /**
         * Shifts the MapScreenr vertically by changing top and bottom by the dy.
         *
         * @param dy   How far to scroll vertically.
         */
        MapScreenr.prototype.shiftY = function (dy) {
            this.top += dy;
            this.bottom += dy;
        };
        return MapScreenr;
    })();
    MapScreenr_1.MapScreenr = MapScreenr;
})(MapScreenr || (MapScreenr = {}));
var ObjectMakr;
(function (ObjectMakr_1) {
    "use strict";
    /**
     * An factory for JavaScript classes that automates the process of
     * setting constructors' prototypal inheritance. A sketch of class inheritance
     * and a listing of properties for each class is taken in, and dynamically
     * accessible constructors keyed by String names are made available.
     */
    var ObjectMakr = (function () {
        /**
         * Initializes a new instance of the ObjectMakr class.
         *
         * @param settings   Settings to be used for initialization.
         */
        function ObjectMakr(settings) {
            if (typeof settings === "undefined") {
                throw new Error("No settings object given to ObjectMakr.");
            }
            if (typeof settings.inheritance === "undefined") {
                throw new Error("No inheritance given to ObjectMakr.");
            }
            this.inheritance = settings.inheritance;
            this.properties = settings.properties || {};
            this.doPropertiesFull = settings.doPropertiesFull;
            this.indexMap = settings.indexMap;
            this.onMake = settings.onMake;
            this.functions = {};
            if (this.doPropertiesFull) {
                this.propertiesFull = {};
            }
            if (this.indexMap) {
                this.processProperties(this.properties);
            }
            this.processFunctions(this.inheritance, Object, "Object");
        }
        /* Simple gets
        */
        /**
         * @returns The complete inheritance mapping.
         */
        ObjectMakr.prototype.getInheritance = function () {
            return this.inheritance;
        };
        /**
         * @returns The complete properties mapping.
         */
        ObjectMakr.prototype.getProperties = function () {
            return this.properties;
        };
        /**
         * @returns The properties for a particular class.
         */
        ObjectMakr.prototype.getPropertiesOf = function (title) {
            return this.properties[title];
        };
        /**
         * @returns Full properties, if doPropertiesFull is true.
         */
        ObjectMakr.prototype.getFullProperties = function () {
            return this.propertiesFull;
        };
        /**
         * @returns Full properties for a particular class, if
         *          doPropertiesFull is true.
         */
        ObjectMakr.prototype.getFullPropertiesOf = function (title) {
            return this.doPropertiesFull ? this.propertiesFull[title] : undefined;
        };
        /**
         * @returns The full mapping of class constructors.
         */
        ObjectMakr.prototype.getFunctions = function () {
            return this.functions;
        };
        /**
         * @param name   The name of a class to retrieve.
         * @returns The constructor for the given class.
         */
        ObjectMakr.prototype.getFunction = function (name) {
            return this.functions[name];
        };
        /**
         * @param type   The name of a class to check for.
         * @returns Whether that class exists.
         */
        ObjectMakr.prototype.hasFunction = function (name) {
            return this.functions.hasOwnProperty(name);
        };
        /**
         * @returns The optional mapping of indices.
         */
        ObjectMakr.prototype.getIndexMap = function () {
            return this.indexMap;
        };
        /* Core usage
        */
        /**
         * Creates a new instance of the specified type and returns it.
         * If desired, any settings are applied to it (deep copy using proliferate).
         *
         * @param name   The name of the type to initialize a new instance of.
         * @param [settings]   Additional attributes to add to the new instance.
         * @returns A newly created instance of the specified type.
         */
        ObjectMakr.prototype.make = function (name, settings) {
            var output;
            // Make sure the type actually exists in Functions
            if (!this.functions.hasOwnProperty(name)) {
                throw new Error("Unknown type given to ObjectMakr: " + name);
            }
            // Create the new object, copying any given settings
            output = new this.functions[name]();
            if (settings) {
                this.proliferate(output, settings);
            }
            // onMake triggers are handled respecting doPropertiesFull.
            if (this.onMake && output[this.onMake]) {
                output[this.onMake](output, name, settings, (this.doPropertiesFull ? this.propertiesFull : this.properties)[name]);
            }
            return output;
        };
        /* Core parsing
        */
        /**
         * Parser that calls processPropertyArray on all properties given as arrays
         *
         * @param properties   Type properties for classes to create.
         * @remarks Only call this if indexMap is given as an array
         */
        ObjectMakr.prototype.processProperties = function (properties) {
            var name;
            // For each of the given properties:
            for (name in properties) {
                if (properties.hasOwnProperty(name)) {
                    // If it's an Array, replace it with a mapped version
                    if (properties[name] instanceof Array) {
                        properties[name] = this.processPropertyArray(properties[name]);
                    }
                }
            }
        };
        /**
         * Creates an output properties object with the mapping shown in indexMap
         *
         * @param properties   An Array with indiced versions of properties
         * @example
         *     this.indexMap = ["width", "height"];
         *     this.processPropertyArray([7, 14]);
         *     // { "width": 7, "height": 14 }
         */
        ObjectMakr.prototype.processPropertyArray = function (properties) {
            var output = {}, i;
            // For each [i] in properties, set that property as under indexMap[i]
            for (i = properties.length - 1; i >= 0; --i) {
                output[this.indexMap[i]] = properties[i];
            }
            return output;
        };
        /**
         * Recursive parser to generate each Function, starting from the base.
         *
         * @param base   An object whose keys are the names of Functions to
         *               made, and whose values are objects whose keys are
         *               for children that inherit from these Functions
         * @param parent   The parent class Function of the classes about to be made.
         * @param [parentName]   The name of the parent class to be inherited from,
         *                       if it is a generated one (and not Object itself).
         */
        ObjectMakr.prototype.processFunctions = function (base, parent, parentName) {
            var name, ref;
            // For each name in the current object:
            for (name in base) {
                if (base.hasOwnProperty(name)) {
                    this.functions[name] = (new Function());
                    // This sets the Function as inheriting from the parent
                    this.functions[name].prototype = new parent();
                    this.functions[name].prototype.constructor = this.functions[name];
                    // Add each property from properties to the Function prototype
                    for (ref in this.properties[name]) {
                        if (this.properties[name].hasOwnProperty(ref)) {
                            this.functions[name].prototype[ref] = this.properties[name][ref];
                        }
                    }
                    // If the entire property tree is being mapped, copy everything
                    // from both this and its parent to its equivalent
                    if (this.doPropertiesFull) {
                        this.propertiesFull[name] = {};
                        if (parentName) {
                            for (ref in this.propertiesFull[parentName]) {
                                if (this.propertiesFull[parentName].hasOwnProperty(ref)) {
                                    this.propertiesFull[name][ref] = this.propertiesFull[parentName][ref];
                                }
                            }
                        }
                        for (ref in this.properties[name]) {
                            if (this.properties[name].hasOwnProperty(ref)) {
                                this.propertiesFull[name][ref] = this.properties[name][ref];
                            }
                        }
                    }
                    this.processFunctions(base[name], this.functions[name], name);
                }
            }
        };
        /* Utilities
        */
        /**
         * Proliferates all members of the donor to the recipient recursively, as
         * a deep copy.
         *
         * @param recipient   An object receiving the donor's members.
         * @param donor   An object whose members are copied to recipient.
         * @param [noOverride]   If recipient properties may be overriden (by default, false).
         */
        ObjectMakr.prototype.proliferate = function (recipient, donor, noOverride) {
            var setting, i;
            // For each attribute of the donor:
            for (i in donor) {
                // If noOverride is specified, don't override if it already exists
                if (noOverride && recipient.hasOwnProperty(i)) {
                    continue;
                }
                // If it's an object, recurse on a new version of it
                setting = donor[i];
                if (typeof setting === "object") {
                    if (!recipient.hasOwnProperty(i)) {
                        recipient[i] = new setting.constructor();
                    }
                    this.proliferate(recipient[i], setting, noOverride);
                }
                else {
                    // Regular primitives are easy to copy otherwise
                    recipient[i] = setting;
                }
            }
            return recipient;
        };
        return ObjectMakr;
    })();
    ObjectMakr_1.ObjectMakr = ObjectMakr;
})(ObjectMakr || (ObjectMakr = {}));
/// <reference path="ObjectMakr-0.2.2.ts" />
var MapsCreatr;
(function (MapsCreatr) {
    "use strict";
    /**
     * Basic storage container for a single Thing to be stored in an Area's
     * PreThings member. A PreThing stores an actual Thing along with basic
     * sizing and positioning information, so that a MapsHandler may accurately
     * spawn or unspawn it as needed.
     */
    var PreThing = (function () {
        /**
         * @param {Thing} thing   The Thing, freshly created by ObjectMaker.make.
         * @param {IPreThingSettings} reference   The creation Object instruction
         *                                        used to create the Thing.
         */
        function PreThing(thing, reference, ObjectMaker) {
            this.thing = thing;
            this.title = thing.title;
            this.reference = reference;
            this.spawned = false;
            this.left = reference.x || 0;
            this.top = reference.y || 0;
            this.right = this.left + (reference.width || ObjectMaker.getFullPropertiesOf(this.title).width);
            this.bottom = this.top + (reference.height || ObjectMaker.getFullPropertiesOf(this.title).height);
            if (reference.position) {
                this.position = reference.position;
            }
        }
        return PreThing;
    })();
    MapsCreatr.PreThing = PreThing;
})(MapsCreatr || (MapsCreatr = {}));
var MapsCreatr;
(function (MapsCreatr_1) {
    "use strict";
    /**
     * Storage container and lazy loader for GameStartr maps that is the back-end
     * counterpart to MapsHandlr. Maps are created with their custom Location and
     * Area members, which are initialized the first time the map is retrieved.
     */
    var MapsCreatr = (function () {
        /**
         * Initializes a new instance of the MapsCreatr class.
         *
         * @param settings   Settings to be used for initialization.
         */
        function MapsCreatr(settings) {
            if (!settings) {
                throw new Error("No settings object given to MapsCreatr.");
            }
            if (!settings.ObjectMaker) {
                throw new Error("No ObjectMakr given to MapsCreatr.");
            }
            if (typeof settings.ObjectMaker.getFullProperties() === "undefined") {
                throw new Error("MapsCreatr's ObjectMaker must store full properties.");
            }
            if (!settings.groupTypes) {
                throw new Error("No groupTypes given to MapsCreatr.");
            }
            this.ObjectMaker = settings.ObjectMaker;
            this.groupTypes = settings.groupTypes;
            this.keyGroupType = settings.keyGroupType || "groupType";
            this.keyEntrance = settings.keyEntrance || "entrance";
            this.macros = settings.macros || {};
            this.scope = settings.scope || this;
            this.entrances = settings.entrances;
            this.requireEntrance = settings.requireEntrance;
            this.mapsRaw = {};
            this.maps = {};
            if (settings.maps) {
                this.storeMaps(settings.maps);
            }
        }
        /* Simple gets
        */
        /**
         * @returns The internal ObjectMakr.
         */
        MapsCreatr.prototype.getObjectMaker = function () {
            return this.ObjectMaker;
        };
        /**
         * @returns The allowed group types.
         */
        MapsCreatr.prototype.getGroupTypes = function () {
            return this.groupTypes;
        };
        /**
         * @returns The key under which Things are to store their group.
         */
        MapsCreatr.prototype.getKeyGroupType = function () {
            return this.keyGroupType;
        };
        /**
         * @returns The key under which Things declare themselves an entrance.
         */
        MapsCreatr.prototype.getKeyEntrance = function () {
            return this.keyEntrance;
        };
        /**
         * @returns The allowed macro Functions.
         */
        MapsCreatr.prototype.getMacros = function () {
            return this.macros;
        };
        /**
         * @returns The scope to give as a last parameter to macros.
         */
        MapsCreatr.prototype.getScope = function () {
            return this.scope;
        };
        /**
         * @returns Whether Locations must have an entrance Function.
         */
        MapsCreatr.prototype.getRequireEntrance = function () {
            return this.requireEntrance;
        };
        /**
         * @returns The Object storing raw maps, keyed by name.
         */
        MapsCreatr.prototype.getMapsRaw = function () {
            return this.mapsRaw;
        };
        /**
         * @returns The Object storing maps, keyed by name.
         */
        MapsCreatr.prototype.getMaps = function () {
            return this.maps;
        };
        /**
         * @param name   A key to find the map under.
         * @returns The raw map keyed by the given name.
         */
        MapsCreatr.prototype.getMapRaw = function (name) {
            var mapRaw = this.mapsRaw[name];
            if (!mapRaw) {
                throw new Error("No map found under: " + name);
            }
            return mapRaw;
        };
        /**
         * Getter for a map under the maps container. If the map has not yet been
         * initialized that is done here as lazy loading.
         *
         * @param name   A key to find the map under.
         * @returns The parsed map keyed by the given name.
         */
        MapsCreatr.prototype.getMap = function (name) {
            var map = this.maps[name];
            if (!map) {
                throw new Error("No map found under: " + name);
            }
            if (!map.initialized) {
                this.initializeMap(map);
            }
            return map;
        };
        /**
         * Creates and stores a set of new maps based on the key/value pairs in a
         * given Object. These will be stored as maps by their string keys via
         * this.storeMap.
         *
         * @param maps   Raw maps keyed by their storage key.
         */
        MapsCreatr.prototype.storeMaps = function (maps) {
            var i;
            for (i in maps) {
                if (maps.hasOwnProperty(i)) {
                    this.storeMap(i, maps[i]);
                }
            }
        };
        /**
         * Creates and stores a new map. The internal ObjectMaker factory is used to
         * auto-generate it based on a given settings object. The actual loading of
         * Areas and Locations is deferred to this.getMap.
         *
         * @param name   A name under which the map should be stored.
         * @param mapRaw   A raw map to be stored.
         * @returns A Map object created by the internal ObjectMakr using the raw map.
         */
        MapsCreatr.prototype.storeMap = function (name, mapRaw) {
            if (!name) {
                throw new Error("Maps cannot be created with no name.");
            }
            var map = this.ObjectMaker.make("Map", mapRaw);
            this.mapsRaw[name] = mapRaw;
            if (!map.areas) {
                throw new Error("Maps cannot be used with no areas: " + name);
            }
            if (!map.locations) {
                throw new Error("Maps cannot be used with no locations: " + name);
            }
            this.maps[name] = map;
            return map;
        };
        /* Area setup (PreThing analysis)
        */
        /**
         * Given a Area, this processes and returns the PreThings that are to
         * inhabit the Area per its creation instructions.
         *
         * @returns A container with the parsed PreThings.
         */
        MapsCreatr.prototype.getPreThings = function (area) {
            var map = area.map, creation = area.creation, prethings = this.createObjectFromStringArray(this.groupTypes), i;
            area.collections = {};
            for (i = 0; i < creation.length; i += 1) {
                this.analyzePreSwitch(creation[i], prethings, area, map);
            }
            return this.processPreThingsArrays(prethings);
        };
        /**
         * PreThing switcher: Given a JSON representation of a PreThing, this
         * determines what to do with it. It may be a location setter (to switch the
         * x- and y- location offset), a macro (to repeat some number of actions),
         * or a raw PreThing.
         *
         * @param reference   A JSON mapping of some number of PreThings.
         * @param preThings   The PreThing containers within the Area.
         * @param {Area} area   The Area to be populated.
         * @param {Map} map   The Map containing the Area.
         * @returns The results of analyzePreMacro or analyzePreThing.
         */
        MapsCreatr.prototype.analyzePreSwitch = function (reference, prethings, area, map) {
            // Case: macro (unless it's undefined)
            if (reference.macro) {
                return this.analyzePreMacro(reference, prethings, area, map);
            }
            else {
                // Case: default (a regular PreThing)
                return this.analyzePreThing(reference, prethings, area, map);
            }
        };
        /**
         * PreThing case: Macro instruction. This calls the macro on the same input,
         * captures the output, and recursively repeats the analyzePreSwitch driver
         * function on the output(s).
         *
         * @param {Object} reference   A JSON mapping of some number of PreThings.
         * @param preThings   The PreThing containers within the Area.
         * @param {Area} area   The Area to be populated.
         * @param {Map} map   The Map containing the Area.
         */
        MapsCreatr.prototype.analyzePreMacro = function (reference, prethings, area, map) {
            var macro = this.macros[reference.macro], outputs, i;
            if (!macro) {
                throw new Error("A non-existent macro is referenced: '" + reference.macro + "'.");
            }
            // Avoid modifying the original macro by creating a new object in its
            // place, while submissively proliferating any default macro settings
            outputs = macro(reference, prethings, area, map, this.scope);
            // If there is any output, recurse on all components of it, Array or not
            if (outputs) {
                if (outputs instanceof Array) {
                    for (i = 0; i < outputs.length; i += 1) {
                        this.analyzePreSwitch(outputs[i], prethings, area, map);
                    }
                }
                else {
                    this.analyzePreSwitch(outputs, prethings, area, map);
                }
            }
            return outputs;
        };
        /**
         * Macro case: PreThing instruction. This creates a PreThing from the
         * given reference and adds it to its respective group in PreThings (based
         * on the PreThing's [keyGroupType] variable).
         *
         * @param reference   A JSON mapping of some number of PreThings.
         * @param preThings   The PreThing containers within the Area.
         * @param area   The Area to be populated by these PreThings.
         * @param map   The Map containing the Area.
         */
        MapsCreatr.prototype.analyzePreThing = function (reference, prethings, area, map) {
            var title = reference.thing, thing, prething;
            if (!this.ObjectMaker.hasFunction(title)) {
                throw new Error("A non-existent Thing type is referenced: '" + title + "'.");
            }
            prething = new MapsCreatr_1.PreThing(this.ObjectMaker.make(title, reference), reference, this.ObjectMaker);
            thing = prething.thing;
            if (!prething.thing[this.keyGroupType]) {
                throw new Error("A Thing of type '" + title + "' does not contain a " + this.keyGroupType + ".");
            }
            if (this.groupTypes.indexOf(prething.thing[this.keyGroupType]) === -1) {
                throw new Error("A Thing of type '" + title + "' contains an unknown " + this.keyGroupType + ".");
            }
            prethings[prething.thing[this.keyGroupType]].push(prething);
            if (!thing.noBoundaryStretch && area.boundaries) {
                this.stretchAreaBoundaries(prething, area);
            }
            // If a Thing is an entrance, then the entrance's location must know the Thing.
            if (thing[this.keyEntrance] !== undefined && typeof thing[this.keyEntrance] !== "object") {
                if (typeof map.locations[thing[this.keyEntrance]] !== "undefined") {
                    if (typeof map.locations[thing[this.keyEntrance]].xloc === "undefined") {
                        map.locations[thing[this.keyEntrance]].xloc = prething.left;
                    }
                    if (typeof map.locations[thing[this.keyEntrance]].yloc === "undefined") {
                        map.locations[thing[this.keyEntrance]].yloc = prething.top;
                    }
                    map.locations[thing[this.keyEntrance]].entrance = prething.thing;
                }
            }
            if (reference.collectionName && area.collections) {
                this.ensureThingCollection(thing, reference.collectionName, reference.collectionKey, area);
            }
            return prething;
        };
        /* Map initialization
        */
        /**
         * Parses the Areas and Locations in a map to make it ready for use.
         *
         * @param map   A map to be initialized.
         */
        MapsCreatr.prototype.initializeMap = function (map) {
            // Set the one-to-many Map->Area relationships within the Map
            this.setMapAreas(map);
            // Set the one-to-many Area->Location relationships within the Map
            this.setMapLocations(map);
            map.initialized = true;
        };
        /**
         * Converts the raw area settings in a Map into Area objects.
         *
         * @param map   A map whose area settings should be parsed.
         */
        MapsCreatr.prototype.setMapAreas = function (map) {
            var areasRaw = map.areas, locationsRaw = map.locations, 
            // The parsed containers should be the same types as the originals
            areasParsed = new areasRaw.constructor(), locationsParsed = new locationsRaw.constructor(), area, location, i;
            // Parse all the Area objects (works for both Arrays and Objects)
            for (i in areasRaw) {
                if (areasRaw.hasOwnProperty(i)) {
                    area = this.ObjectMaker.make("Area", areasRaw[i]);
                    areasParsed[i] = area;
                    area.map = map;
                    area.name = i;
                    area.boundaries = {
                        "top": 0,
                        "right": 0,
                        "bottom": 0,
                        "left": 0
                    };
                }
            }
            // Parse all the Location objects (works for both Arrays and Objects)
            for (i in locationsRaw) {
                if (locationsRaw.hasOwnProperty(i)) {
                    location = this.ObjectMaker.make("Location", locationsRaw[i]);
                    locationsParsed[i] = location;
                    location.entryRaw = locationsRaw[i].entry;
                    location.name = i;
                    location.area = locationsRaw[i].area || 0;
                    if (this.requireEntrance) {
                        if (!this.entrances.hasOwnProperty(location.entryRaw)) {
                            throw new Error("Location " + i + " has unknown entry string: " + location.entryRaw);
                        }
                    }
                    if (this.entrances && location.entryRaw) {
                        location.entry = this.entrances[location.entryRaw];
                    }
                    else if (location.entry && location.entry.constructor === String) {
                        location.entry = this.entrances[String(location.entry)];
                    }
                }
            }
            // Store the output object in the Map, and keep the raw settings for the
            // sake of debugging / user interest
            map.areas = areasParsed;
            map.locations = locationsParsed;
        };
        /**
         * Converts the raw location settings in a Map into Location objects.
         *
         * @param {Map} map
         */
        MapsCreatr.prototype.setMapLocations = function (map) {
            var locationsRaw = map.locations, 
            // The parsed container should be the same type as the original
            locationsParsed = new locationsRaw.constructor(), location, i;
            // Parse all the keys in locasRaw (works for both Arrays and Objects)
            for (i in locationsRaw) {
                if (locationsRaw.hasOwnProperty(i)) {
                    location = this.ObjectMaker.make("Location", locationsRaw[i]);
                    locationsParsed[i] = location;
                    // The area should be an object reference, under the Map's areas
                    location.area = map.areas[locationsRaw[i].area || 0];
                    if (!locationsParsed[i].area) {
                        throw new Error("Location " + i + " references an invalid area:" + locationsRaw[i].area);
                    }
                }
            }
            // Store the output object in the Map, and keep the old settings for the
            // sake of debugging / user interest
            map.locations = locationsParsed;
        };
        /**
         * "Stretches" an Area's boundaries based on a PreThing. For each direction,
         * if the PreThing has a more extreme version of it (higher top, etc.), the
         * boundary is updated.
         *
         * @param prething   The PreThing stretching the Area's boundaries.
         * @param area   An Area containing the PreThing.
         */
        MapsCreatr.prototype.stretchAreaBoundaries = function (prething, area) {
            var boundaries = area.boundaries;
            boundaries.top = Math.min(prething.top, boundaries.top);
            boundaries.right = Math.max(prething.right, boundaries.right);
            boundaries.bottom = Math.max(prething.bottom, boundaries.bottom);
            boundaries.left = Math.min(prething.left, boundaries.left);
        };
        /**
         * Adds a Thing to the specified collection in the Map's Area. If the collection
         * doesn't exist yet, it's created.
         *
         * @param thing   The thing that has specified a collection.
         * @param collectionName   The name of the collection.
         * @param collectionKey   The key under which the collection should store
         *                        the Thing.
         * @param area   The Area containing the collection.
         */
        MapsCreatr.prototype.ensureThingCollection = function (thing, collectionName, collectionKey, area) {
            var collection = area.collections[collectionName];
            if (!collection) {
                collection = area.collections[collectionName] = {};
            }
            thing.collection = collection;
            collection[collectionKey] = thing;
        };
        /**
         * Creates an Object wrapper around a PreThings Object with versions of each
         * child PreThing[] sorted by xloc and yloc, in increasing and decreasing order.
         *
         * @param prethings   A raw container of PreThings.
         * @returns A PreThing wrapper with the keys "xInc", "xDec", "yInc", and "yDec".
         */
        MapsCreatr.prototype.processPreThingsArrays = function (prethings) {
            var _this = this;
            var output = {}, i;
            for (i in prethings) {
                if (prethings.hasOwnProperty(i)) {
                    var children = prethings[i], array = {
                        "xInc": this.getArraySorted(children, this.sortPreThingsXInc),
                        "xDec": this.getArraySorted(children, this.sortPreThingsXDec),
                        "yInc": this.getArraySorted(children, this.sortPreThingsYInc),
                        "yDec": this.getArraySorted(children, this.sortPreThingsYDec),
                        "push": function (prething) {
                            _this.addArraySorted(array.xInc, prething, _this.sortPreThingsXInc);
                            _this.addArraySorted(array.xDec, prething, _this.sortPreThingsXDec);
                            _this.addArraySorted(array.yInc, prething, _this.sortPreThingsYInc);
                            _this.addArraySorted(array.yDec, prething, _this.sortPreThingsYDec);
                        }
                    };
                    output[i] = array;
                }
            }
            return output;
        };
        /* Utilities
        */
        /**
         * Creates an Object pre-populated with one key for each of the Strings in
         * the input Array, each pointing to a new Array.
         *
         * @param array   An Array listing the keys to be made into an Object.
         * @returns An Object with the keys listed in the Array.
         */
        MapsCreatr.prototype.createObjectFromStringArray = function (array) {
            var output = {}, i;
            for (i = 0; i < array.length; i += 1) {
                output[array[i]] = [];
            }
            return output;
        };
        /**
         * Returns a shallow copy of an Array, in sorted order based on a given
         * sorter Function.
         *
         * @param array   An Array to be sorted.
         * @param sorter   A standard sorter Function.
         * @returns A copy of the original Array, sorted.
         */
        MapsCreatr.prototype.getArraySorted = function (array, sorter) {
            var copy = array.slice();
            copy.sort(sorter);
            return copy;
        };
        /**
         * Adds an element into an Array using a binary search with a sorter Function.
         *
         * @param array   An Array to insert the element into.
         * @param element   An element to insert into the Array.
         * @param sorter   A standard sorter Function.
         */
        MapsCreatr.prototype.addArraySorted = function (array, element, sorter) {
            var lower = 0, upper = array.length, index;
            while (lower !== upper) {
                index = ((lower + upper) / 2) | 0;
                // Case: element is less than the index
                if (sorter(element, array[index]) < 0) {
                    upper = index;
                }
                else {
                    // Case: element is higher than the index
                    lower = index + 1;
                }
            }
            if (lower === upper) {
                array.splice(lower, 0, element);
                return;
            }
        };
        /**
         * Sorter for PreThings that results in increasing horizontal order.
         *
         * @param a   A PreThing.
         * @param b   A PreThing.
         */
        MapsCreatr.prototype.sortPreThingsXInc = function (a, b) {
            return a.left === b.left ? a.top - b.top : a.left - b.left;
        };
        /**
         * Sorter for PreThings that results in decreasing horizontal order.
         *
         * @param a   A PreThing.
         * @param b   A PreThing.
         */
        MapsCreatr.prototype.sortPreThingsXDec = function (a, b) {
            return b.right === a.right ? b.bottom - a.bottom : b.right - a.right;
        };
        /**
         * Sorter for PreThings that results in increasing vertical order.
         *
         * @param a   A PreThing.
         * @param b   A PreThing.
         */
        MapsCreatr.prototype.sortPreThingsYInc = function (a, b) {
            return a.top === b.top ? a.left - b.left : a.top - b.top;
        };
        /**
         * Sorter for PreThings that results in decreasing vertical order.
         *
         * @param a   A PreThing.
         * @param b   A PreThing.
         */
        MapsCreatr.prototype.sortPreThingsYDec = function (a, b) {
            return b.bottom === a.bottom ? b.right - a.right : b.bottom - a.bottom;
        };
        return MapsCreatr;
    })();
    MapsCreatr_1.MapsCreatr = MapsCreatr;
})(MapsCreatr || (MapsCreatr = {}));
/// <reference path="MapsCreatr-0.2.1.ts" />
/// <reference path="MapScreenr-0.2.1.ts" />
/// <reference path="ObjectMakr-0.2.2.ts" />
var AreaSpawnr;
(function (AreaSpawnr_1) {
    "use strict";
    /**
     * Area manipulator and spawner for GameStartr Maps that is the front-end
     * counterpart to MapsCreatr. PreThing listings are loaded from Areas stored in a
     * MapsCreatr and added or removed from user input. Area properties are given to
     * a MapScreenr when a new Area is loaded.
     */
    var AreaSpawnr = (function () {
        /**
         * @param {IAreaSpawnrSettings} settings
         */
        function AreaSpawnr(settings) {
            if (!settings) {
                throw new Error("No settings given to AreaSpawnr.");
            }
            // Maps themselves should have been created in the MapsCreator object
            if (!settings.MapsCreator) {
                throw new Error("No MapsCreator provided to AreaSpawnr.");
            }
            this.MapsCreator = settings.MapsCreator;
            // Map/Area attributes will need to be stored in a MapScreenr object
            if (!settings.MapScreener) {
                throw new Error("No MapScreener provided to AreaSpawnr.");
            }
            this.MapScreener = settings.MapScreener;
            this.onSpawn = settings.onSpawn;
            this.onUnspawn = settings.onUnspawn;
            this.screenAttributes = settings.screenAttributes || [];
            this.stretchAdd = settings.stretchAdd;
            this.afterAdd = settings.afterAdd;
            this.commandScope = settings.commandScope;
        }
        /* Simple gets
        */
        /**
         * @returns The internal MapsCreator.
         */
        AreaSpawnr.prototype.getMapsCreator = function () {
            return this.MapsCreator;
        };
        /**
         * @returns The internal MapScreener.
         */
        AreaSpawnr.prototype.getMapScreener = function () {
            return this.MapScreener;
        };
        /**
         * @returns The attribute names to be copied to MapScreener.
         */
        AreaSpawnr.prototype.getScreenAttributes = function () {
            return this.screenAttributes;
        };
        /**
         * @returns The key by which the current Map is indexed.
         */
        AreaSpawnr.prototype.getMapName = function () {
            return this.mapName;
        };
        /**
         * Gets the map listed under the given name. If no name is provided, the
         * mapCurrent is returned instead.
         *
         * @param name   An optional key to find the map under.
         * @returns A Map under the given name, or the current map if none given.
         */
        AreaSpawnr.prototype.getMap = function (name) {
            if (typeof name !== "undefined") {
                return this.MapsCreator.getMap(name);
            }
            else {
                return this.mapCurrent;
            }
        };
        /**
         * Simple getter pipe to the internal MapsCreator.getMaps() function.
         *
         * @returns A listing of maps, keyed by their names.
         */
        AreaSpawnr.prototype.getMaps = function () {
            return this.MapsCreator.getMaps();
        };
        /**
         * @returns The current Area.
         */
        AreaSpawnr.prototype.getArea = function () {
            return this.areaCurrent;
        };
        /**
         * @returns The name of the current Area.
         */
        AreaSpawnr.prototype.getAreaName = function () {
            return this.areaCurrent.name;
        };
        /**
         * @param location   The key of the Location to return.
         * @returns A Location within the current Map.
         */
        AreaSpawnr.prototype.getLocation = function (location) {
            return this.areaCurrent.map.locations[location];
        };
        /**
         * @returns The most recently entered Location in the current Area.
         */
        AreaSpawnr.prototype.getLocationEntered = function () {
            return this.locationEntered;
        };
        /**
         * Simple getter function for the internal prethings object. This will be
         * undefined before the first call to setMap.
         *
         * @returns A listing of the current area's Prethings.
         */
        AreaSpawnr.prototype.getPreThings = function () {
            return this.prethings;
        };
        /* Map & area setting
        */
        /**
         * Sets the currently manipulated Map in the handler to be the one under a
         * given name. Note that this will do very little unless a location is
         * provided.
         *
         * @param name   A key to find the map under.
         * @param location   An optional key for a location to immediately start the
         *                   map in (if not provided, ignored).
         * @returns The now-current map.
         */
        AreaSpawnr.prototype.setMap = function (name, location) {
            // Get the newly current map from this.getMap normally
            this.mapCurrent = this.getMap(name);
            if (!this.mapCurrent) {
                throw new Error("Unknown Map in setMap: '" + name + "'.");
            }
            this.mapName = name;
            // Most of the work is done by setLocation (by default, the map's first)
            if (arguments.length > 1) {
                this.setLocation(location);
            }
            return this.mapCurrent;
        };
        /**
         * Goes to a particular location in the given map. Area attributes are
         * copied to the MapScreener, PreThings are loaded, and stretches and afters
         * are checked.
         *
         * @param name   The key of the Location to start in.
         */
        AreaSpawnr.prototype.setLocation = function (name) {
            var location, attribute, i;
            // Query the location from the current map and ensure it exists
            location = this.mapCurrent.locations[name];
            if (!location) {
                throw new Error("Unknown location in setLocation: '" + name + "'.");
            }
            // Since the location is valid, mark it as current (with its area)
            this.locationEntered = location;
            this.areaCurrent = location.area;
            this.areaCurrent.boundaries = {
                "top": 0,
                "right": 0,
                "bottom": 0,
                "left": 0
            };
            // Copy all the settings from that area into the MapScreenr container
            for (i = 0; i < this.screenAttributes.length; i += 1) {
                attribute = this.screenAttributes[i];
                this.MapScreener[attribute] = this.areaCurrent[attribute];
            }
            // Reset the prethings object, enabling it to be used as a fresh start
            // for the new Area/Location placements
            this.prethings = this.MapsCreator.getPreThings(location.area);
            // Optional: set stretch commands
            if (this.areaCurrent.stretches) {
                this.setStretches(this.areaCurrent.stretches);
            }
            // Optional: set after commands
            if (this.areaCurrent.afters) {
                this.setAfters(this.areaCurrent.afters);
            }
        };
        /**
         * Applies the stretchAdd Function to each given "stretch" command and
         * stores the commands in stretches.
         *
         * @param stretchesRaw   Raw descriptions of the stretches.
         */
        AreaSpawnr.prototype.setStretches = function (stretchesRaw) {
            var i;
            this.stretches = stretchesRaw;
            for (i = 0; i < stretchesRaw.length; i += 1) {
                this.stretchAdd.call(this.commandScope || this, stretchesRaw[i], i, stretchesRaw);
            }
        };
        /**
         * Applies the afterAdd Function to each given "after" command and stores
         * the commands in afters.
         *
         * @param aftersRaw   Raw descriptions of the afters.
         */
        AreaSpawnr.prototype.setAfters = function (aftersRaw) {
            var i;
            this.afters = aftersRaw;
            for (i = 0; i < aftersRaw.length; i += 1) {
                this.afterAdd.call(this.commandScope || this, aftersRaw[i], i, aftersRaw);
            }
        };
        /**
         * Calls onSpawn on every PreThing touched by the given bounding box,
         * determined in order of the given direction. This is a simple wrapper
         * around applySpawnAction that also gives it true as the status.
         *
         * @param direction   The direction by which to order PreThings, as "xInc",
         *                    "xDec", "yInc", or "yDec".
         * @param top   The upper-most bound to spawn within.
         * @param right   The right-most bound to spawn within.
         * @param bottom    The bottom-most bound to spawn within.
         * @param left    The left-most bound to spawn within.
         */
        AreaSpawnr.prototype.spawnArea = function (direction, top, right, bottom, left) {
            if (this.onSpawn) {
                this.applySpawnAction(this.onSpawn, true, direction, top, right, bottom, left);
            }
        };
        /**
         * Calls onUnspawn on every PreThing touched by the given bounding box,
         * determined in order of the given direction. This is a simple wrapper
         * around applySpawnAction that also gives it false as the status.
         *
         * @param direction   The direction by which to order PreThings, as "xInc",
         *                    "xDec", "yInc", or "yDec".
         * @param top   The upper-most bound to spawn within.
         * @param right   The right-most bound to spawn within.
         * @param bottom    The bottom-most bound to spawn within.
         * @param left    The left-most bound to spawn within.
         */
        AreaSpawnr.prototype.unspawnArea = function (direction, top, right, bottom, left) {
            if (this.onUnspawn) {
                this.applySpawnAction(this.onUnspawn, false, direction, top, right, bottom, left);
            }
        };
        /**
         * Calls onUnspawn on every PreThing touched by the given bounding box,
         * determined in order of the given direction. This is used both to spawn
         * and un-spawn PreThings, such as during QuadsKeepr shifting. The given
         * status is used as a filter: all PreThings that already have the status
         * (generally true or false as spawned or unspawned, respectively) will have
         * the callback called on them.
         *
         * @param callback   The callback to be run whenever a matching matching
         *                   PreThing is found.
         * @param status   The spawn status to match PreThings against. Only PreThings
         *                 with .spawned === status will have the callback applied.
         * @param direction   The direction by which to order PreThings, as "xInc",
         *                    "xDec", "yInc", or "yDec".
         * @param top   The upper-most bound to apply within.
         * @param right   The right-most bound to apply within.
         * @param bottom    The bottom-most bound to apply within.
         * @param left    The left-most bound to apply within.
         */
        AreaSpawnr.prototype.applySpawnAction = function (callback, status, direction, top, right, bottom, left) {
            var name, group, prething, mid, start, end, i;
            // For each group of PreThings currently able to spawn...
            for (name in this.prethings) {
                if (!this.prethings.hasOwnProperty(name)) {
                    continue;
                }
                // Don't bother trying to spawn the group if it has no members
                group = this.prethings[name][direction];
                if (group.length === 0) {
                    continue;
                }
                // Find the start and end points within the PreThings Array
                // Ex. if direction="xInc", go from .left >= left to .left <= right
                mid = (group.length / 2) | 0;
                start = this.findPreThingsSpawnStart(direction, group, mid, top, right, bottom, left);
                end = this.findPreThingsSpawnEnd(direction, group, mid, top, right, bottom, left);
                // Loop through all the directionally valid PreThings, spawning if 
                // they're within the bounding box
                for (i = start; i <= end; i += 1) {
                    prething = group[i];
                    // For example: if status is true (spawned), don't spawn again
                    if (prething.spawned !== status) {
                        prething.spawned = status;
                        callback(prething);
                    }
                }
            }
        };
        /**
         * Finds the index from which PreThings should stop having an action
         * applied to them in applySpawnAction. This is less efficient than the
         * unused version below, but is more reliable for slightly unsorted groups.
         *
         * @param direction   The direction by which to order PreThings, as "xInc",
         *                    "xDec", "yInc", or "yDec".
         * @param group   The group to find a PreThing index within.
         * @param mid   The middle of the group. This is currently unused.
         * @param top   The upper-most bound to apply within.
         * @param right   The right-most bound to apply within.
         * @param bottom    The bottom-most bound to apply within.
         * @param left    The left-most bound to apply within.
         * @returns The index to start spawning PreThings from.
         */
        AreaSpawnr.prototype.findPreThingsSpawnStart = function (direction, group, mid, top, right, bottom, left) {
            var directionKey = AreaSpawnr.directionKeys[direction], directionEnd = this.getDirectionEnd(directionKey, top, right, bottom, left), i;
            for (i = 0; i < group.length; i += 1) {
                if (group[i][directionKey] >= directionEnd) {
                    return i;
                }
            }
            return i;
        };
        /**
         * Finds the index from which PreThings should stop having an action
         * applied to them in applySpawnAction. This is less efficient than the
         * unused version below, but is more reliable for slightly unsorted groups.
         *
         * @param direction   The direction by which to order PreThings, as "xInc",
         *                    "xDec", "yInc", or "yDec".
         * @param group   The group to find a PreThing index within.
         * @param mid   The middle of the group. This is currently unused.
         * @param top   The upper-most bound to apply within.
         * @param right   The right-most bound to apply within.
         * @param bottom    The bottom-most bound to apply within.
         * @param left    The left-most bound to apply within.
         * @returns The index to stop spawning PreThings from.
         */
        AreaSpawnr.prototype.findPreThingsSpawnEnd = function (direction, group, mid, top, right, bottom, left) {
            var directionKey = AreaSpawnr.directionKeys[direction], directionKeyOpposite = AreaSpawnr.directionKeys[AreaSpawnr.directionOpposites[direction]], directionEnd = this.getDirectionEnd(directionKeyOpposite, top, right, bottom, left), i;
            for (i = group.length - 1; i >= 0; i -= 1) {
                if (group[i][directionKey] <= directionEnd) {
                    return i;
                }
            }
            return i;
        };
        /**
         * Conditionally returns a measurement based on what direction String is
         * given. This is useful for generically finding boundaries when the
         * direction isn't known, such as in findPreThingsSpawnStart and -End.
         *
         * @param direction   The direction by which to order PreThings, as "xInc",
         *                    "xDec", "yInc", or "yDec".
         * @param top   The upper-most bound to apply within.
         * @param right   The right-most bound to apply within.
         * @param bottom    The bottom-most bound to apply within.
         * @param left    The left-most bound to apply within.
         * @returns Either top, right, bottom, or left, depending on direction.
         */
        AreaSpawnr.prototype.getDirectionEnd = function (directionKey, top, right, bottom, left) {
            switch (directionKey) {
                case "top":
                    return top;
                case "right":
                    return right;
                case "bottom":
                    return bottom;
                case "left":
                    return left;
                default:
                    throw new Error("Unknown directionKey: " + directionKey);
            }
        };
        /**
         * Directional equivalents for converting from directions to keys.
         */
        AreaSpawnr.directionKeys = {
            "xInc": "left",
            "xDec": "right",
            "yInc": "top",
            "yDec": "bottom"
        };
        /**
         * Opposite directions for when finding descending order Arrays.
         */
        AreaSpawnr.directionOpposites = {
            "xInc": "xDec",
            "xDec": "xInc",
            "yInc": "yDec",
            "yDec": "yInc"
        };
        return AreaSpawnr;
    })();
    AreaSpawnr_1.AreaSpawnr = AreaSpawnr;
})(AreaSpawnr || (AreaSpawnr = {}));
var ItemsHoldr;
(function (ItemsHoldr_1) {
    "use strict";
    /**
     * Storage container for a single ItemsHoldr value. The value may have triggers
     * assigned to value, modularity, and other triggers, as well as an HTML element.
     */
    var ItemValue = (function () {
        /**
         * Creates a new ItemValue with the given key and settings. Defaults are given
         * to the value via proliferate before the settings.
         *
         * @constructor
         * @param ItemsHolder   The container for this value.
         * @param key   The key to reference this new ItemValue by.
         * @param settings   Any optional custom settings.
         */
        function ItemValue(ItemsHolder, key, settings) {
            if (settings === void 0) { settings = {}; }
            this.ItemsHolder = ItemsHolder;
            ItemsHolder.proliferate(this, ItemsHolder.getDefaults());
            ItemsHolder.proliferate(this, settings);
            this.key = key;
            if (!this.hasOwnProperty("value")) {
                this.value = this.valueDefault;
            }
            if (this.hasElement) {
                this.element = ItemsHolder.createElement(this.elementTag || "div", {
                    className: ItemsHolder.getPrefix() + "_value " + key
                });
                this.element.appendChild(ItemsHolder.createElement("div", {
                    "textContent": key
                }));
                this.element.appendChild(ItemsHolder.createElement("div", {
                    "textContent": this.value
                }));
            }
            if (this.storeLocally) {
                // If there exists an old version of this property, get it 
                if (ItemsHolder.getLocalStorage().hasOwnProperty(ItemsHolder.getPrefix() + key)) {
                    this.value = this.retrieveLocalStorage();
                    this.update();
                }
                else {
                    // Otherwise save the new version to memory
                    this.updateLocalStorage();
                }
            }
        }
        /**
         * @returns The value being stored, with a transformGet applied if one exists.
         */
        ItemValue.prototype.getValue = function () {
            if (this.transformGet) {
                return this.transformGet(this.value);
            }
            return this.value;
        };
        /**
         * Sets the value being stored, with a is a transformSet applied if one exists.
         * Any attached triggers to the new value will be called.
         *
         * @param value   The desired value to now store.
         */
        ItemValue.prototype.setValue = function (value) {
            if (this.transformSet) {
                this.value = this.transformSet(value);
            }
            else {
                this.value = value;
            }
            this.update();
        };
        /**
         * General update Function to be run whenever the internal value is changed.
         * It runs all the trigger, modular, etc. checks, updates the HTML element
         * if there is one, and updates localStorage if needed.
         */
        ItemValue.prototype.update = function () {
            // Mins and maxes must be obeyed before any other considerations
            if (this.hasOwnProperty("minimum") && Number(this.value) <= Number(this.minimum)) {
                this.value = this.minimum;
                if (this.onMinimum) {
                    this.onMinimum.apply(this, this.ItemsHolder.getCallbackArgs());
                }
            }
            else if (this.hasOwnProperty("maximum") && Number(this.value) <= Number(this.maximum)) {
                this.value = this.maximum;
                if (this.onMaximum) {
                    this.onMaximum.apply(this, this.ItemsHolder.getCallbackArgs());
                }
            }
            if (this.modularity) {
                this.checkModularity();
            }
            if (this.triggers) {
                this.checkTriggers();
            }
            if (this.hasElement) {
                this.updateElement();
            }
            if (this.storeLocally) {
                this.updateLocalStorage();
            }
        };
        /**
         * Stores a ItemValue's value in localStorage under the prefix plus its key.
         *
         * @param {Boolean} [overrideAutoSave]   Whether the policy on saving should
         *                                       be ignored (so saving happens
         *                                       regardless). By default, false.
         */
        ItemValue.prototype.updateLocalStorage = function (overrideAutoSave) {
            if (overrideAutoSave || this.ItemsHolder.getAutoSave()) {
                this.ItemsHolder.getLocalStorage()[this.ItemsHolder.getPrefix() + this.key] = JSON.stringify(this.value);
            }
        };
        /**
         * Checks if the current value should trigger a callback, and if so calls it.
         */
        ItemValue.prototype.checkTriggers = function () {
            if (this.triggers.hasOwnProperty(this.value)) {
                this.triggers[this.value].apply(this, this.ItemsHolder.getCallbackArgs());
            }
        };
        /**
         * Checks if the current value is greater than the modularity (assuming
         * modular is a non-zero Numbers), and if so, continuously reduces value and
         * calls this.onModular.
         */
        ItemValue.prototype.checkModularity = function () {
            if (this.value.constructor !== Number || !this.modularity) {
                return;
            }
            while (this.value >= this.modularity) {
                this.value = Math.max(0, this.value - this.modularity);
                if (this.onModular) {
                    this.onModular.apply(this, this.ItemsHolder.getCallbackArgs());
                }
            }
        };
        /**
         * Updates the ItemValue's element's second child to be the ItemValue's value.
         */
        ItemValue.prototype.updateElement = function () {
            if (this.ItemsHolder.hasDisplayChange(this.value)) {
                this.element.children[1].textContent = this.ItemsHolder.getDisplayChange(this.value);
            }
            else {
                this.element.children[1].textContent = this.value;
            }
        };
        /**
         * Retrieves a ItemValue's value from localStorage, making sure not to try to
         * JSON.parse an undefined or null value.
         *
         * @returns {Mixed}
         */
        ItemValue.prototype.retrieveLocalStorage = function () {
            var value = localStorage.getItem(this.ItemsHolder.getPrefix() + this.key);
            if (value === "undefined") {
                return undefined;
            }
            if (value.constructor !== String) {
                return value;
            }
            return JSON.parse(value);
        };
        return ItemValue;
    })();
    ItemsHoldr_1.ItemValue = ItemValue;
    /**
     * A versatile container to store and manipulate values in localStorage, and
     * optionally keep an updated HTML container showing these values.
     */
    var ItemsHoldr = (function () {
        /**
         * Initializes a new instance of the ItemsHoldr class.
         *
         * @param settings   Any optional custom settings.
         */
        function ItemsHoldr(settings) {
            if (settings === void 0) { settings = {}; }
            var key;
            this.prefix = settings.prefix || "";
            this.autoSave = settings.autoSave;
            this.callbackArgs = settings.callbackArgs || [];
            this.allowNewItems = settings.allowNewItems === undefined
                ? true : settings.allowNewItems;
            if (settings.localStorage) {
                this.localStorage = settings.localStorage;
            }
            else if (typeof localStorage === "undefined") {
                this.localStorage = this.createPlaceholderStorage();
            }
            else {
                this.localStorage = localStorage;
            }
            this.defaults = settings.defaults || {};
            this.displayChanges = settings.displayChanges || {};
            this.items = {};
            if (settings.values) {
                this.itemKeys = Object.keys(settings.values);
                for (key in settings.values) {
                    if (settings.values.hasOwnProperty(key)) {
                        this.addItem(key, settings.values[key]);
                    }
                }
            }
            else {
                this.itemKeys = [];
            }
            if (settings.doMakeContainer) {
                this.containersArguments = settings.containersArguments || [
                    ["div", {
                            "className": this.prefix + "_container"
                        }]
                ];
                this.container = this.makeContainer(settings.containersArguments);
            }
        }
        /* Simple gets
        */
        /**
         *
         */
        ItemsHoldr.prototype.key = function (index) {
            return this.itemKeys[index];
        };
        /**
         * @returns The values contained within, keyed by their keys.
         */
        ItemsHoldr.prototype.getValues = function () {
            return this.items;
        };
        /**
         * @returns {Mixed} Default attributes for values.
         */
        ItemsHoldr.prototype.getDefaults = function () {
            return this.defaults;
        };
        /**
         * @returns A reference to localStorage or a replacment object.
         */
        ItemsHoldr.prototype.getLocalStorage = function () {
            return this.localStorage;
        };
        /**
         * @returns Whether this should save changes to localStorage automatically.
         */
        ItemsHoldr.prototype.getAutoSave = function () {
            return this.autoSave;
        };
        /**
         * @returns The prefix to store thigns under in localStorage.
         */
        ItemsHoldr.prototype.getPrefix = function () {
            return this.prefix;
        };
        /**
         * @returns The container HTML element, if it exists.
         */
        ItemsHoldr.prototype.getContainer = function () {
            return this.container;
        };
        /**
         * @returns createElement arguments for HTML containers, outside-to-inside.
         */
        ItemsHoldr.prototype.getContainersArguments = function () {
            return this.containersArguments;
        };
        /**
         * @returns Any hard-coded changes to element content.
         */
        ItemsHoldr.prototype.getDisplayChanges = function () {
            return this.displayChanges;
        };
        /**
         * @returns Arguments to be passed to triggered event callbacks.
         */
        ItemsHoldr.prototype.getCallbackArgs = function () {
            return this.callbackArgs;
        };
        /* Retrieval
        */
        /**
         * @returns String keys for each of the stored ItemValues.
         */
        ItemsHoldr.prototype.getKeys = function () {
            return Object.keys(this.items);
        };
        /**
         * @param key   The key for a known value.
         * @returns The known value of a key, assuming that key exists.
         */
        ItemsHoldr.prototype.getItem = function (key) {
            this.checkExistence(key);
            return this.items[key].getValue();
        };
        /**
         * @param key   The key for a known value.
         * @returns The settings for that particular key.
         */
        ItemsHoldr.prototype.getObject = function (key) {
            return this.items[key];
        };
        /**
         * @param key   The key for a potentially known value.
         * @returns Whether there is a value under that key.
         */
        ItemsHoldr.prototype.hasKey = function (key) {
            return this.items.hasOwnProperty(key);
        };
        /**
         * @returns A mapping of key names to the actual values of all objects being stored.
         */
        ItemsHoldr.prototype.exportItems = function () {
            var output = {}, i;
            for (i in this.items) {
                if (this.items.hasOwnProperty(i)) {
                    output[i] = this.items[i].getValue();
                }
            }
            return output;
        };
        /* ItemValues
        */
        /**
         * Adds a new key & value pair to by linking to a newly created ItemValue.
         *
         * @param key   The key to reference by new ItemValue by.
         * @param settings   The settings for the new ItemValue.
         * @returns The newly created ItemValue.
         */
        ItemsHoldr.prototype.addItem = function (key, settings) {
            if (settings === void 0) { settings = {}; }
            this.items[key] = new ItemValue(this, key, settings);
            this.itemKeys.push(key);
            return this.items[key];
        };
        /**
         * Clears a value from the listing, and removes its element from the
         * container (if they both exist).
         *
         * @param key   The key of the element to remove.
         */
        ItemsHoldr.prototype.removeItem = function (key) {
            if (!this.items.hasOwnProperty(key)) {
                return;
            }
            if (this.container && this.items[key].hasElement) {
                this.container.removeChild(this.items[key].element);
            }
            this.itemKeys.splice(this.itemKeys.indexOf(key), 1);
            delete this.items[key];
        };
        /**
         * Completely clears all values from the ItemsHoldr, removing their
         * elements from the container (if they both exist) as well.
         */
        ItemsHoldr.prototype.clear = function () {
            var i;
            if (this.container) {
                for (i in this.items) {
                    if (this.items[i].hasElement) {
                        this.container.removeChild(this.items[i].element);
                    }
                }
            }
            this.items = {};
            this.itemKeys = [];
        };
        /**
         * Sets the value for the ItemValue under the given key, then updates the ItemValue
         * (including the ItemValue's element and localStorage, if needed).
         *
         * @param key   The key of the ItemValue.
         * @param value   The new value for the ItemValue.
         */
        ItemsHoldr.prototype.setItem = function (key, value) {
            this.checkExistence(key);
            this.items[key].setValue(value);
        };
        /**
         * Increases the value for the ItemValue under the given key, via addition for
         * Numbers or concatenation for Strings.
         *
         * @param key   The key of the ItemValue.
         * @param amount   The amount to increase by (by default, 1).
         */
        ItemsHoldr.prototype.increase = function (key, amount) {
            if (amount === void 0) { amount = 1; }
            this.checkExistence(key);
            var value = this.items[key].getValue();
            value += amount;
            this.items[key].setValue(value);
        };
        /**
         * Increases the value for the ItemValue under the given key, via addition for
         * Numbers or concatenation for Strings.
         *
         * @param key   The key of the ItemValue.
         * @param amount   The amount to increase by (by default, 1).
         */
        ItemsHoldr.prototype.decrease = function (key, amount) {
            if (amount === void 0) { amount = 1; }
            this.checkExistence(key);
            var value = this.items[key].getValue();
            value -= amount;
            this.items[key].setValue(value);
        };
        /**
         * Toggles whether a value is true or false.
         *
         * @param key   The key of the ItemValue.
         */
        ItemsHoldr.prototype.toggle = function (key) {
            this.checkExistence(key);
            var value = this.items[key].getValue();
            value = value ? false : true;
            this.items[key].setValue(value);
        };
        /**
         * Ensures a key exists in values. If it doesn't, and new values are
         * allowed, it creates it; otherwise, it throws an Error.
         *
         * @param key
         */
        ItemsHoldr.prototype.checkExistence = function (key) {
            if (!this.items.hasOwnProperty(key)) {
                if (this.allowNewItems) {
                    this.addItem(key);
                }
                else {
                    throw new Error("Unknown key given to ItemsHoldr: '" + key + "'.");
                }
            }
        };
        /**
         * Manually saves an item's value to localStorage, ignoring the autoSave flag.
         *
         * @param key   The key of the item to save.
         */
        ItemsHoldr.prototype.saveItem = function (key) {
            if (!this.items.hasOwnProperty(key)) {
                throw new Error("Unknown key given to ItemsHoldr: '" + key + "'.");
            }
            this.items[key].updateLocalStorage(true);
        };
        /**
         * Manually saves all values to localStorage, ignoring the autoSave flag.
         */
        ItemsHoldr.prototype.saveAll = function () {
            var key;
            for (key in this.items) {
                if (this.items.hasOwnProperty(key)) {
                    this.items[key].updateLocalStorage(true);
                }
            }
        };
        /* HTML helpers
        */
        /**
         * Hides the container Element by setting its visibility to hidden.
         */
        ItemsHoldr.prototype.hideContainer = function () {
            this.container.style.visibility = "hidden";
        };
        /**
         * Shows the container Element by setting its visibility to visible.
         */
        ItemsHoldr.prototype.displayContainer = function () {
            this.container.style.visibility = "visible";
        };
        /**
         * Creates the container Element, which contains a child for each ItemValue that
         * specifies hasElement to be true.
         *
         * @param containers   An Array representing the Element to be created and the
         *                     children between it and the contained ItemValues.
         *                     Each contained Object has a String tag name as its
         *                     first member, followed by any number of Objects to apply
         *                     via createElement.
         * @returns A newly created Element that can be used as a container.
         */
        ItemsHoldr.prototype.makeContainer = function (containers) {
            var output = this.createElement.apply(this, containers[0]), current = output, child, key, i;
            for (i = 1; i < containers.length; ++i) {
                child = this.createElement.apply(this, containers[i]);
                current.appendChild(child);
                current = child;
            }
            for (key in this.items) {
                if (this.items[key].hasElement) {
                    child.appendChild(this.items[key].element);
                }
            }
            return output;
        };
        /**
         * @returns Whether displayChanges has an entry for a particular value.
         */
        ItemsHoldr.prototype.hasDisplayChange = function (value) {
            return this.displayChanges.hasOwnProperty(value);
        };
        /**
         * @returns The displayChanges entry for a particular value.
         */
        ItemsHoldr.prototype.getDisplayChange = function (value) {
            return this.displayChanges[value];
        };
        /* Utilities
        */
        /**
         * Creates a new HTMLElement of the given type. For each Object given as
         * arguments after, each member is proliferated onto the element.
         *
         * @param tag   The type of the HTMLElement (by default, "div").
         * @param args   Any number of Objects to be proliferated onto the
         *               new HTMLElement.
         * @returns A newly created HTMLElement of the given tag.
         */
        ItemsHoldr.prototype.createElement = function (tag) {
            if (tag === void 0) { tag = "div"; }
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var element = document.createElement(tag), i;
            // For each provided object, add those settings to the element
            for (i = 0; i < args.length; i += 1) {
                this.proliferateElement(element, args[i]);
            }
            return element;
        };
        /**
         * Proliferates all members of the donor to the recipient recursively, as
         * a deep copy.
         *
         * @param recipient   An object receiving the donor's members.
         * @param donor   An object whose members are copied to recipient.
         * @param noOverride   If recipient properties may be overriden (by
         *                     default, false).
         * @returns The recipient, which should have the donor proliferated onto it.
         */
        ItemsHoldr.prototype.proliferate = function (recipient, donor, noOverride) {
            var setting, i;
            // For each attribute of the donor:
            for (i in donor) {
                if (donor.hasOwnProperty(i)) {
                    // If noOverride, don't override already existing properties
                    if (noOverride && recipient.hasOwnProperty(i)) {
                        continue;
                    }
                    // If it's an object, recurse on a new version of it
                    setting = donor[i];
                    if (typeof setting === "object") {
                        if (!recipient.hasOwnProperty(i)) {
                            recipient[i] = new setting.constructor();
                        }
                        this.proliferate(recipient[i], setting, noOverride);
                    }
                    else {
                        // Regular primitives are easy to copy otherwise
                        recipient[i] = setting;
                    }
                }
            }
            return recipient;
        };
        /**
         * Identical to proliferate, but tailored for HTML elements because many
         * element attributes don't play nicely with JavaScript Array standards.
         * Looking at you, HTMLCollection!
         *
         * @param recipient   An HTMLElement receiving the donor's members.
         * @param donor   An object whose members are copied to recipient.
         * @param noOverride   If recipient properties may be overriden (by
         *                     default, false).
         * @returns The recipient, which should have the donor proliferated onto it.
         */
        ItemsHoldr.prototype.proliferateElement = function (recipient, donor, noOverride) {
            var setting, i, j;
            // For each attribute of the donor:
            for (i in donor) {
                if (donor.hasOwnProperty(i)) {
                    // If noOverride, don't override already existing properties
                    if (noOverride && recipient.hasOwnProperty(i)) {
                        continue;
                    }
                    setting = donor[i];
                    // Special cases for HTML elements
                    switch (i) {
                        // Children: just append all of them directly
                        case "children":
                            if (typeof (setting) !== "undefined") {
                                for (j = 0; j < setting.length; j += 1) {
                                    recipient.appendChild(setting[j]);
                                }
                            }
                            break;
                        // Style: proliferate (instead of making a new Object)
                        case "style":
                            this.proliferate(recipient[i], setting);
                            break;
                        // By default, use the normal proliferate logic
                        default:
                            // If it's an object, recurse on a new version of it
                            if (typeof setting === "object") {
                                if (!recipient.hasOwnProperty(i)) {
                                    recipient[i] = new setting.constructor();
                                }
                                this.proliferate(recipient[i], setting, noOverride);
                            }
                            else {
                                // Regular primitives are easy to copy otherwise
                                recipient[i] = setting;
                            }
                            break;
                    }
                }
            }
            return recipient;
        };
        /**
         * Creates an Object that can be used to create a new LocalStorage
         * replacement, if the JavaScript environment doesn't have one.
         *
         * @returns {Object}
         */
        ItemsHoldr.prototype.createPlaceholderStorage = function () {
            var i, output = {
                "keys": [],
                "getItem": function (key) {
                    return this.localStorage[key];
                },
                "setItem": function (key, value) {
                    this.localStorage[key] = value;
                },
                "clear": function () {
                    for (i in this) {
                        if (this.hasOwnProperty(i)) {
                            delete this[i];
                        }
                    }
                },
                "removeItem": function (key) {
                    delete this[key];
                },
                "key": function (index) {
                    return this.keys[index];
                }
            };
            Object.defineProperties(output, {
                "length": {
                    "get": function () {
                        return output.keys.length;
                    }
                },
                "remainingSpace": {
                    "get": function () {
                        return 9001; // Is there a way to calculate this?
                    }
                }
            });
            return output;
        };
        return ItemsHoldr;
    })();
    ItemsHoldr_1.ItemsHoldr = ItemsHoldr;
})(ItemsHoldr || (ItemsHoldr = {}));
/// <reference path="ItemsHoldr-0.2.1.ts" />
var AudioPlayr;
(function (AudioPlayr_1) {
    "use strict";
    /**
     * An audio library to automate preloading and controlled playback of multiple
     * audio tracks, with support for different browsers' preferred file types.
     */
    var AudioPlayr = (function () {
        /**
         * Initializes a new instance of the AudioPlayr class.
         *
         * @param settings   Settings to use for initialization.
         */
        function AudioPlayr(settings) {
            if (typeof settings.library === "undefined") {
                throw new Error("No library given to AudioPlayr.");
            }
            if (typeof settings.directory === "undefined") {
                throw new Error("No directory given to AudioPlayr.");
            }
            if (typeof settings.fileTypes === "undefined") {
                throw new Error("No fileTypes given to AudioPlayr.");
            }
            if (!settings.ItemsHolder) {
                throw new Error("No ItemsHoldr given to AudioPlayr.");
            }
            var volumeInitial;
            this.ItemsHolder = settings.ItemsHolder;
            this.directory = settings.directory;
            this.fileTypes = settings.fileTypes;
            this.getThemeDefault = settings.getThemeDefault || "Theme";
            this.getVolumeLocal = typeof settings.getVolumeLocal === "undefined"
                ? 1 : settings.getVolumeLocal;
            // Sounds should always start blank
            this.sounds = {};
            // Preload everything!
            this.generateLibraryFromSettings(settings.library);
            volumeInitial = this.ItemsHolder.getItem("volume");
            if (volumeInitial === undefined) {
                this.setVolume(1);
            }
            else {
                this.setVolume(volumeInitial);
            }
            this.setMuted(this.ItemsHolder.getItem("muted") || false);
        }
        /* Simple getters
        */
        /**
         * @returns The listing of <audio> Elements, keyed by name.
         */
        AudioPlayr.prototype.getLibrary = function () {
            return this.library;
        };
        /**
         * @returns The allowed filetypes for audio files.
         */
        AudioPlayr.prototype.getFileTypes = function () {
            return this.fileTypes;
        };
        /**
         * @returns The currently playing <audio> Elements, keyed by name.
         */
        AudioPlayr.prototype.getSounds = function () {
            return this.sounds;
        };
        /**
         * @returns The current playing theme's <audio> Element.
         */
        AudioPlayr.prototype.getTheme = function () {
            return this.theme;
        };
        /**
         * @returns The name of the currently playing theme.
         */
        AudioPlayr.prototype.getThemeName = function () {
            return this.themeName;
        };
        /**
         * @returns The directory under which all filetype directories are to be located.
         */
        AudioPlayr.prototype.getDirectory = function () {
            return this.directory;
        };
        /* Playback modifiers
        */
        /**
         * @returns The current volume as a Number in [0,1], retrieved by the ItemsHoldr.
         */
        AudioPlayr.prototype.getVolume = function () {
            return Number(this.ItemsHolder.getItem("volume") || 0);
        };
        /**
         * Sets the current volume. If not muted, all sounds will have their volume
         * updated.
         *
         * @param volume   A Number in [0,1] to set as the current volume.
         */
        AudioPlayr.prototype.setVolume = function (volume) {
            var i;
            if (!this.getMuted()) {
                for (i in this.sounds) {
                    if (this.sounds.hasOwnProperty(i)) {
                        this.sounds[i].volume = Number(this.sounds[i].getAttribute("volumeReal")) * volume;
                    }
                }
            }
            this.ItemsHolder.setItem("volume", volume.toString());
        };
        /**
         * @returns Whether this is currently muted.
         */
        AudioPlayr.prototype.getMuted = function () {
            return Boolean(Number(this.ItemsHolder.getItem("muted")));
        };
        /**
         * Calls either setMutedOn or setMutedOff as is appropriate.
         *
         * @param muted   The new status for muted.
         */
        AudioPlayr.prototype.setMuted = function (muted) {
            this.getMuted() ? this.setMutedOn() : this.setMutedOff();
        };
        /**
         * Calls either setMutedOn or setMutedOff to toggle whether this is muted.
         */
        AudioPlayr.prototype.toggleMuted = function () {
            this.setMuted(!this.getMuted());
        };
        /**
         * Sets volume to 0 in all currently playing sounds and stores the muted
         * status as on in the internal ItemsHoldr.
         */
        AudioPlayr.prototype.setMutedOn = function () {
            var i;
            for (i in this.sounds) {
                if (this.sounds.hasOwnProperty(i)) {
                    this.sounds[i].volume = 0;
                }
            }
            this.ItemsHolder.setItem("muted", "1");
        };
        /**
         * Sets sound volumes to their actual volumes and stores the muted status
         * as off in the internal ItemsHoldr.
         */
        AudioPlayr.prototype.setMutedOff = function () {
            var volume = this.getVolume(), sound, i;
            for (i in this.sounds) {
                if (this.sounds.hasOwnProperty(i)) {
                    sound = this.sounds[i];
                    sound.volume = Number(sound.getAttribute("volumeReal")) * volume;
                }
            }
            this.ItemsHolder.setItem("muted", "0");
        };
        /* Other modifiers
        */
        /**
         * @returns The Function or Number used as the volume setter for local sounds.
         */
        AudioPlayr.prototype.getGetVolumeLocal = function () {
            return this.getVolumeLocal;
        };
        /**
         * @param getVolumeLocal   A new Function or Number to use as the volume setter
         *                         for local sounds.
         */
        AudioPlayr.prototype.setGetVolumeLocal = function (getVolumeLocalNew) {
            this.getVolumeLocal = getVolumeLocalNew;
        };
        /**
         * @returns The Function or String used to get the default theme for playTheme.
         */
        AudioPlayr.prototype.getGetThemeDefault = function () {
            return this.getThemeDefault;
        };
        /**
         * @param getThemeDefaultNew A new Function or String to use as the source for
         *                           theme names in default playTheme calls.
         */
        AudioPlayr.prototype.setGetThemeDefault = function (getThemeDefaultNew) {
            this.getThemeDefault = getThemeDefaultNew;
        };
        /* Playback
        */
        /**
         * Plays the sound of the given name.
         *
         * @param name   The name of the sound to play.
         * @returns The sound's <audio> element, now playing.
         * @remarks Internally, this stops any previously playing sound of that name
         *          and starts a new one, with volume set to the current volume and
         *          muted status. If the name wasn't previously being played (and
         *          therefore a new Element has been created), an event listener is
         *          added to delete it from sounds after.
         */
        AudioPlayr.prototype.play = function (name) {
            var sound, used;
            // If the sound isn't yet being played, see if it's in the library
            if (!this.sounds.hasOwnProperty(name)) {
                // If the sound also isn't in the library, it's unknown
                if (!this.library.hasOwnProperty(name)) {
                    throw new Error("Unknown name given to AudioPlayr.play: '" + name + "'.");
                }
                sound = this.sounds[name] = this.library[name];
            }
            else {
                sound = this.sounds[name];
            }
            this.soundStop(sound);
            if (this.getMuted()) {
                sound.volume = 0;
            }
            else {
                sound.setAttribute("volumeReal", "1");
                sound.volume = this.getVolume();
            }
            this.playSound(sound);
            used = Number(sound.getAttribute("used"));
            // If this is the song's first play, let it know how to stop
            if (!used) {
                sound.setAttribute("used", String(used + 1));
                sound.addEventListener("ended", this.soundFinish.bind(this, name));
            }
            sound.setAttribute("name", name);
            return sound;
        };
        /**
         * Pauses all currently playing sounds.
         */
        AudioPlayr.prototype.pauseAll = function () {
            var i;
            for (i in this.sounds) {
                if (this.sounds.hasOwnProperty(i)) {
                    this.pauseSound(this.sounds[i]);
                }
            }
        };
        /**
         * Un-pauses (resumes) all currently paused sounds.
         */
        AudioPlayr.prototype.resumeAll = function () {
            var i;
            for (i in this.sounds) {
                if (!this.sounds.hasOwnProperty(i)) {
                    continue;
                }
                this.playSound(this.sounds[i]);
            }
        };
        /**
         * Pauses the currently playing theme, if there is one.
         */
        AudioPlayr.prototype.pauseTheme = function () {
            if (this.theme) {
                this.pauseSound(this.theme);
            }
        };
        /**
         * Resumes the theme, if there is one and it's paused.
         */
        AudioPlayr.prototype.resumeTheme = function () {
            if (this.theme) {
                this.playSound(this.theme);
            }
        };
        /**
         * Stops all sounds and any theme, and removes all references to them.
         */
        AudioPlayr.prototype.clearAll = function () {
            this.pauseAll();
            this.clearTheme();
            this.sounds = {};
        };
        /**
         * Pauses and removes the theme, if there is one.
         */
        AudioPlayr.prototype.clearTheme = function () {
            if (!this.theme) {
                return;
            }
            this.pauseTheme();
            delete this.sounds[this.theme.getAttribute("name")];
            this.theme = undefined;
            this.themeName = undefined;
        };
        /**
         * "Local" version of play that changes the output sound's volume depending
         * on the result of a getVolumeLocal call.
         *
         * @param name   The name of the sound to play.
         * @param location   An argument for getVolumeLocal, if that's a Function.
         * @returns The sound's <audio> element, now playing.
         */
        AudioPlayr.prototype.playLocal = function (name, location) {
            var sound = this.play(name), volumeReal;
            switch (this.getVolumeLocal.constructor) {
                case Function:
                    volumeReal = this.getVolumeLocal(location);
                    break;
                case Number:
                    volumeReal = this.getVolumeLocal;
                    break;
                default:
                    volumeReal = Number(this.getVolumeLocal) || 1;
                    break;
            }
            sound.setAttribute("volumeReal", String(volumeReal));
            if (this.getMuted()) {
                sound.volume = 0;
            }
            else {
                sound.volume = volumeReal * this.getVolume();
            }
            return sound;
        };
        /**
         * Pauses any previously playing theme and starts playback of a new theme.
         *
         * @param name   The name of the sound to be used as the theme. If not
         *               provided, getThemeDefault is used to
         *                          provide one.
         * @param loop   Whether the theme should always loop (by default, true).
         * @returns The theme's <audio> element, now playing.
         * @remarks This is different from normal sounds in that it normally loops
         *          and is controlled by pauseTheme and co. If loop is on and the
         *          sound wasn't already playing, an event listener is added for
         *          when it ends.
         */
        AudioPlayr.prototype.playTheme = function (name, loop) {
            this.pauseTheme();
            // Loop defaults to true
            loop = typeof loop !== "undefined" ? loop : true;
            // If name isn't given, use the default getter
            if (typeof name === "undefined") {
                switch (this.getThemeDefault.constructor) {
                    case Function:
                        name = this.getThemeDefault();
                        break;
                    default:
                        name = this.getThemeDefault;
                        break;
                }
            }
            // If a theme already exists, kill it
            if (typeof this.theme !== "undefined" && this.theme.hasAttribute("name")) {
                delete this.sounds[this.theme.getAttribute("name")];
            }
            this.themeName = name;
            this.theme = this.sounds[name] = this.play(name);
            this.theme.loop = loop;
            // If it's used (no repeat), add the event listener to resume theme
            if (this.theme.getAttribute("used") === "1") {
                this.theme.addEventListener("ended", this.playTheme.bind(this));
            }
            return this.theme;
        };
        /**
         * Wrapper around playTheme that plays a sound, then a theme. This is
         * implemented using an event listener on the sound's ending.
         *
         * @param prefix    The name of a sound to play before the theme.
         * @param name   The name of the sound to be used as the theme. If not
         *               provided, getThemeDefault is used to
         *                          provide one.
         * @param loop   Whether the theme should always loop (by default, false).
         * @returns The sound's <audio> element, now playing.
         */
        AudioPlayr.prototype.playThemePrefixed = function (prefix, name, loop) {
            var sound = this.play(prefix);
            this.pauseTheme();
            // If name isn't given, use the default getter
            if (typeof name === "undefined") {
                switch (this.getThemeDefault.constructor) {
                    case Function:
                        name = this.getThemeDefault();
                        break;
                    default:
                        name = this.getThemeDefault;
                        break;
                }
            }
            this.addEventListener(prefix, "ended", this.playTheme.bind(this, prefix + " " + name, loop));
            return sound;
        };
        /* Public utilities
        */
        /**
         * Adds an event listener to a currently playing sound. The sound will keep
         * track of event listeners via an .addedEvents attribute, so they can be
         * cancelled later.
         *
         * @param name   The name of the sound.
         * @param event   The name of the event, such as "ended".
         * @param callback   The Function to be called by the event.
         */
        AudioPlayr.prototype.addEventListener = function (name, event, callback) {
            var sound = this.library[name];
            if (!sound) {
                throw new Error("Unknown name given to addEventListener: '" + name + "'.");
            }
            if (!sound.addedEvents) {
                sound.addedEvents = {};
            }
            if (!sound.addedEvents[event]) {
                sound.addedEvents[event] = [callback];
            }
            else {
                sound.addedEvents[event].push(callback);
            }
            sound.addEventListener(event, callback);
        };
        /**
         * Clears all events added by this.addEventListener to a sound under a given
         * event.
         *
         * @param name   The name of the sound.
         * @param event   The name of the event, such as "ended".
         */
        AudioPlayr.prototype.removeEventListeners = function (name, event) {
            var sound = this.library[name], events, i;
            if (!sound) {
                throw new Error("Unknown name given to removeEventListeners: '" + name + "'.");
            }
            if (!sound.addedEvents) {
                return;
            }
            events = sound.addedEvents[event];
            if (!events) {
                return;
            }
            for (i = 0; i < events.length; i += 1) {
                sound.removeEventListener(event, events[i]);
            }
            events.length = 0;
        };
        /**
         * Adds an event listener to a sound. If the sound doesn't exist or has
         * finished playing, it's called immediately.
         *
         * @param name   The name of the sound.
         * @param event   The name of the event, such as "onended".
         * @param callback   The Function to be called by the event.
         */
        AudioPlayr.prototype.addEventImmediate = function (name, event, callback) {
            if (!this.sounds.hasOwnProperty(name) || this.sounds[name].paused) {
                callback();
                return;
            }
            this.sounds[name].addEventListener(event, callback);
        };
        /* Private utilities
        */
        /**
         * Called when a sound has completed to get it out of sounds.
         *
         * @param name   The name of the sound that just finished.
         */
        AudioPlayr.prototype.soundFinish = function (name) {
            if (this.sounds.hasOwnProperty(name)) {
                delete this.sounds[name];
            }
        };
        /**
         * Carefully stops a sound. HTMLAudioElement don't natively have a .stop()
         * function, so this is the shim to do that.
         */
        AudioPlayr.prototype.soundStop = function (sound) {
            this.pauseSound(sound);
            if (sound.readyState) {
                sound.currentTime = 0;
            }
        };
        /* Private loading / resetting
        */
        /**
         * Loads every sound defined in the library via AJAX. Sounds are loaded
         * into <audio> elements via createAudio and stored in the library.
         */
        AudioPlayr.prototype.generateLibraryFromSettings = function (librarySettings) {
            var directory = {}, directorySoundNames, directoryName, name, j;
            this.library = {};
            this.directories = {};
            // For each given directory (e.g. names, themes):
            for (directoryName in librarySettings) {
                if (!librarySettings.hasOwnProperty(directoryName)) {
                    continue;
                }
                directory = {};
                directorySoundNames = librarySettings[directoryName];
                // For each audio file to be loaded in that directory:
                for (j = 0; j < directorySoundNames.length; j += 1) {
                    name = directorySoundNames[j];
                    // Create the sound and store it in the container
                    this.library[name] = directory[name] = this.createAudio(name, directoryName);
                }
                // The full directory is stored in the master directories
                this.directories[directoryName] = directory;
            }
        };
        /**
         * Creates an audio element, gives it sources, and starts preloading.
         *
         * @param name   The name of the sound to play.
         * @param sectionName   The name of the directory containing the sound.
         * @returns An <audio> element ocntaining the sound, currently playing.
         */
        AudioPlayr.prototype.createAudio = function (name, directory) {
            var sound = document.createElement("audio"), sourceType, child, i;
            // Create an audio source for each child
            for (i = 0; i < this.fileTypes.length; i += 1) {
                sourceType = this.fileTypes[i];
                child = document.createElement("source");
                child.type = "audio/" + sourceType;
                child.src = this.directory + "/" + directory + "/" + sourceType + "/" + name + "." + sourceType;
                sound.appendChild(child);
            }
            // This preloads the sound.
            sound.volume = 0;
            sound.setAttribute("volumeReal", "1");
            sound.setAttribute("used", "0");
            this.playSound(sound);
            return sound;
        };
        /**
         * Utility to try to play a sound, which may not be possible in headless
         * environments like PhantomJS.
         *
         * @param sound   An <audio> element to play.
         * @returns Whether the sound was able to play.
         */
        AudioPlayr.prototype.playSound = function (sound) {
            if (sound && sound.play) {
                sound.play();
                return true;
            }
            return false;
        };
        /**
         * Utility to try to pause a sound, which may not be possible in headless
         * environments like PhantomJS.
         *
         * @param sound   An <audio> element to pause.
         * @returns Whether the sound was able to pause.
         */
        AudioPlayr.prototype.pauseSound = function (sound) {
            if (sound && sound.pause) {
                sound.pause();
                return true;
            }
            return false;
        };
        return AudioPlayr;
    })();
    AudioPlayr_1.AudioPlayr = AudioPlayr;
})(AudioPlayr || (AudioPlayr = {}));
var ChangeLinr;
(function (ChangeLinr_1) {
    "use strict";
    /**
     * A general utility class for transforming raw input to processed output.
     * Transformation functions for inputs are kept along with an order.
     */
    var ChangeLinr = (function () {
        /**
         * @param {IChangeLinrSettings} settings
         */
        function ChangeLinr(settings) {
            if (typeof settings === "undefined") {
                throw new Error("No settings object given to ChangeLinr.");
            }
            if (typeof settings.pipeline === "undefined") {
                throw new Error("No pipeline given to ChangeLinr.");
            }
            if (typeof settings.transforms === "undefined") {
                throw new Error("No transforms given to ChangeLinr.");
            }
            var i;
            this.pipeline = settings.pipeline || [];
            this.transforms = settings.transforms || {};
            this.doMakeCache = typeof settings.doMakeCache === "undefined"
                ? true : settings.doMakeCache;
            this.doUseCache = typeof settings.doUseCache === "undefined"
                ? true : settings.doUseCache;
            this.cache = {};
            this.cacheFull = {};
            for (i = 0; i < this.pipeline.length; i += 1) {
                if (!this.pipeline[i]) {
                    throw new Error("Pipe[" + i + "] is invalid.");
                }
                if (!this.transforms.hasOwnProperty(this.pipeline[i])) {
                    throw new Error("Pipe[" + i + "] ('" + this.pipeline[i] + "') not found in transforms.");
                }
                if (!(this.transforms[this.pipeline[i]] instanceof Function)) {
                    throw new Error("Pipe[" + i + "] ('" + this.pipeline[i] + "') is not a valid Function from transforms.");
                }
                this.cacheFull[i] = this.cacheFull[this.pipeline[i]] = {};
            }
        }
        /* Simple gets
        */
        /**
         * @returns The cached output of this.process and this.processFull.
         */
        ChangeLinr.prototype.getCache = function () {
            return this.cache;
        };
        /**
         * @param key   The key under which the output was processed
         * @returns The cached output filed under the given key.
         */
        ChangeLinr.prototype.getCached = function (key) {
            return this.cache[key];
        };
        /**
         * @returns A complete listing of the cached outputs from all
         *          processed information, from each pipeline transform.
         */
        ChangeLinr.prototype.getCacheFull = function () {
            return this.cacheFull;
        };
        /**
         * @returns Whether the cache object is being kept.
         */
        ChangeLinr.prototype.getDoMakeCache = function () {
            return this.doMakeCache;
        };
        /**
         * @returns Whether previously cached output is being used in new
         *          process requests.
         */
        ChangeLinr.prototype.getDoUseCache = function () {
            return this.doUseCache;
        };
        /* Core processing
        */
        /**
         * Applies a series of transforms to input data. If doMakeCache is on, the
         * outputs of this are stored in cache and cacheFull.
         *
         * @param data   The data to be transformed.
         * @param [key]   They key under which the data is to be stored. If needed
         *                for caching but not provided, defaults to data.
         * @param [attributes]   Any extra attributes to be given to transforms.
         * @returns The final output of the pipeline.
         */
        ChangeLinr.prototype.process = function (data, key, attributes) {
            var i;
            if (typeof key === "undefined" && (this.doMakeCache || this.doUseCache)) {
                key = data;
            }
            // If this keyed input was already processed, get that
            if (this.doUseCache && this.cache.hasOwnProperty(key)) {
                return this.cache[key];
            }
            // Apply (and optionally cache) each transform in order
            for (i = 0; i < this.pipeline.length; i += 1) {
                data = this.transforms[this.pipeline[i]](data, key, attributes, this);
                if (this.doMakeCache) {
                    this.cacheFull[this.pipeline[i]][key] = data;
                }
            }
            if (this.doMakeCache) {
                this.cache[key] = data;
            }
            return data;
        };
        /**
         * A version of this.process that returns the complete output from each
         * pipelined transform Function in an Object.
         *
         * @param data   The data to be transformed.
         * @param key   They key under which the data is to be stored.
         * @param [attributes]   Any extra attributes to be given to the transforms.
         * @returns The final output of the transforms.
         */
        ChangeLinr.prototype.processFull = function (data, key, attributes) {
            var output = {}, i;
            this.process(data, key, attributes);
            for (i = 0; i < this.pipeline.length; i += 1) {
                output[i] = output[this.pipeline[i]] = this.cacheFull[this.pipeline[i]][key];
            }
            return output;
        };
        return ChangeLinr;
    })();
    ChangeLinr_1.ChangeLinr = ChangeLinr;
})(ChangeLinr || (ChangeLinr = {}));
var InputWritr;
(function (InputWritr_1) {
    "use strict";
    /**
     * A general utility for automating interactions with user-called events linked
     * with callbacks. Pipe functions are available that take in user input, switch
     * on the event code, and call the appropriate callback. Further utilities allow
     * for saving and playback of input histories in JSON format.
     */
    var InputWritr = (function () {
        /**
         * Initializes a new instance of the InputWritr class.
         *
         * @param settings   Settings to be used for initialization.
         */
        function InputWritr(settings) {
            if (typeof settings === "undefined") {
                throw new Error("No settings object given to InputWritr.");
            }
            if (typeof settings.triggers === "undefined") {
                throw new Error("No triggers given to InputWritr.");
            }
            this.triggers = settings.triggers;
            // Headless browsers like PhantomJS might not contain the performance
            // class, so Date.now is used as a backup
            if (typeof settings.getTimestamp === "undefined") {
                if (typeof performance === "undefined") {
                    this.getTimestamp = function () {
                        return Date.now();
                    };
                }
                else {
                    this.getTimestamp = (performance.now
                        || performance.webkitNow
                        || performance.mozNow
                        || performance.msNow
                        || performance.oNow).bind(performance);
                }
            }
            else {
                this.getTimestamp = settings.getTimestamp;
            }
            this.eventInformation = settings.eventInformation;
            this.canTrigger = settings.hasOwnProperty("canTrigger")
                ? settings.canTrigger
                : function () {
                    return true;
                };
            this.isRecording = settings.hasOwnProperty("isRecording")
                ? settings.isRecording
                : function () {
                    return true;
                };
            this.currentHistory = {};
            this.histories = {};
            this.aliases = {};
            this.addAliases(settings.aliases || {});
            this.keyAliasesToCodes = settings.keyAliasesToCodes || {
                "shift": 16,
                "ctrl": 17,
                "space": 32,
                "left": 37,
                "up": 38,
                "right": 39,
                "down": 40
            };
            this.keyCodesToAliases = settings.keyCodesToAliases || {
                "16": "shift",
                "17": "ctrl",
                "32": "space",
                "37": "left",
                "38": "up",
                "39": "right",
                "40": "down"
            };
        }
        /* Simple gets
        */
        /**
         * @returns The stored mapping of aliases to values.
         */
        InputWritr.prototype.getAliases = function () {
            return this.aliases;
        };
        /**
         * @returns The stored mapping of aliases to values, with values
         *          mapped to their equivalent key Strings.
         */
        InputWritr.prototype.getAliasesAsKeyStrings = function () {
            var output = {}, alias;
            for (alias in this.aliases) {
                if (this.aliases.hasOwnProperty(alias)) {
                    output[alias] = this.getAliasAsKeyStrings(alias);
                }
            }
            return output;
        };
        /**
         * Determines the allowed key strings for a given alias.
         *
         * @param alias   An alias allowed to be passed in, typically a
         *                character code.
         * @returns The mapped key Strings corresponding to that alias,
         *          typically the human-readable Strings representing
         *          input names, such as "a" or "left".
         */
        InputWritr.prototype.getAliasAsKeyStrings = function (alias) {
            return this.aliases[alias].map(this.convertAliasToKeyString.bind(this));
        };
        /**
         * @param alias   The alias of an input, typically a character code.
         * @returns The human-readable String representing the input name,
         *          such as "a" or "left".
         */
        InputWritr.prototype.convertAliasToKeyString = function (alias) {
            if (alias.constructor === String) {
                return alias;
            }
            if (alias > 96 && alias < 105) {
                return String.fromCharCode(alias - 48);
            }
            if (alias > 64 && alias < 97) {
                return String.fromCharCode(alias);
            }
            return typeof this.keyCodesToAliases[alias] !== "undefined"
                ? this.keyCodesToAliases[alias]
                : "?";
        };
        /**
         * @param key   The number code of an input.
         * @returns The machine-usable character code of the input.
         */
        InputWritr.prototype.convertKeyStringToAlias = function (key) {
            if (key.constructor === Number) {
                return key;
            }
            if (key.length === 1) {
                return key.charCodeAt(0) - 32;
            }
            return typeof this.keyAliasesToCodes[key] !== "undefined"
                ? this.keyAliasesToCodes[key]
                : -1;
        };
        /**
         * Getter for the currently recording history.
         *
         * @returns The currently recording history of inputs in JSON-friendly form.
         */
        InputWritr.prototype.getCurrentHistory = function () {
            return this.currentHistory;
        };
        /**
         * Getter for a single saved history.
         *
         * @param name   The identifier for the old history to return.
         * @returns A history of inputs in JSON-friendly form.
         */
        InputWritr.prototype.getHistory = function (name) {
            return this.histories[name];
        };
        /**
         * @returns All previously stored histories.
         */
        InputWritr.prototype.getHistories = function () {
            return this.histories;
        };
        /**
         * @returns Whether this is currently allowing inputs.
         */
        InputWritr.prototype.getCanTrigger = function () {
            return this.canTrigger;
        };
        /**
         * @returns Whether this is currently recording allowed inputs.
         */
        InputWritr.prototype.getIsRecording = function () {
            return this.isRecording;
        };
        /* Simple sets
        */
        /**
         * Sets whether this is to allow inputs.
         *
         * @param canTriggerNew   Whether this is now allowing inputs. This
         *                        may be either a Function (to be evaluated
         *                        on each input) or a general Boolean.
         */
        InputWritr.prototype.setCanTrigger = function (canTriggerNew) {
            if (canTriggerNew.constructor === Boolean) {
                this.canTrigger = function () {
                    return canTriggerNew;
                };
            }
            else {
                this.canTrigger = canTriggerNew;
            }
        };
        /**
         * Sets whether this is recording.
         *
         * @param isRecordingNew   Whether this is now recording inputs.
         */
        InputWritr.prototype.setIsRecording = function (isRecordingNew) {
            if (isRecordingNew.constructor === Boolean) {
                this.isRecording = function () {
                    return isRecordingNew;
                };
            }
            else {
                this.isRecording = isRecordingNew;
            }
        };
        /**
         * Sets the first argument for event callbacks.
         *
         * @param eventInformationNew   A new first argument for event callbacks.
         */
        InputWritr.prototype.setEventInformation = function (eventInformationNew) {
            this.eventInformation = eventInformationNew;
        };
        /* Aliases
        */
        /**
         * Adds a list of values by which an event may be triggered.
         *
         * @param name   The name of the event that is being given aliases,
         *               such as "left".
         * @param values   An array of aliases by which the event will also
         *                 be callable.
         */
        InputWritr.prototype.addAliasValues = function (name, values) {
            var triggerName, triggerGroup, i;
            if (!this.aliases.hasOwnProperty(name)) {
                this.aliases[name] = values;
            }
            else {
                this.aliases[name].push.apply(this.aliases[name], values);
            }
            // triggerName = "onkeydown", "onkeyup", ...
            for (triggerName in this.triggers) {
                if (this.triggers.hasOwnProperty(triggerName)) {
                    // triggerGroup = { "left": function, ... }, ...
                    triggerGroup = this.triggers[triggerName];
                    if (triggerGroup.hasOwnProperty(name)) {
                        // values[i] = 37, 65, ...
                        for (i = 0; i < values.length; i += 1) {
                            triggerGroup[values[i]] = triggerGroup[name];
                        }
                    }
                }
            }
        };
        /**
         * Removes a list of values by which an event may be triggered.
         *
         * @param name   The name of the event that is having aliases removed,
         *               such as "left".
         * @param values   Aliases by which the event will no longer be callable.
         */
        InputWritr.prototype.removeAliasValues = function (name, values) {
            var triggerName, triggerGroup, i;
            if (!this.aliases.hasOwnProperty(name)) {
                return;
            }
            for (i = 0; i < values.length; i += 1) {
                this.aliases[name].splice(this.aliases[name].indexOf(values[i], 1));
            }
            // triggerName = "onkeydown", "onkeyup", ...
            for (triggerName in this.triggers) {
                if (this.triggers.hasOwnProperty(triggerName)) {
                    // triggerGroup = { "left": function, ... }, ...
                    triggerGroup = this.triggers[triggerName];
                    if (triggerGroup.hasOwnProperty(name)) {
                        // values[i] = 37, 65, ...
                        for (i = 0; i < values.length; i += 1) {
                            if (triggerGroup.hasOwnProperty(values[i])) {
                                delete triggerGroup[values[i]];
                            }
                        }
                    }
                }
            }
        };
        /**
         * Shortcut to remove old alias values and add new ones in.
         *
         *
         * @param name   The name of the event that is having aliases
         *               added and removed, such as "left".
         * @param valuesOld   An array of aliases by which the event will no
         *                    longer be callable.
         * @param valuesNew   An array of aliases by which the event will
         *                    now be callable.
         */
        InputWritr.prototype.switchAliasValues = function (name, valuesOld, valuesNew) {
            this.removeAliasValues(name, valuesOld);
            this.addAliasValues(name, valuesNew);
        };
        /**
         * Adds a set of alises from an Object containing "name" => [values] pairs.
         *
         * @param aliasesRaw   Aliases to be added via this.addAliasvalues.
         */
        InputWritr.prototype.addAliases = function (aliasesRaw) {
            var aliasName;
            for (aliasName in aliasesRaw) {
                if (aliasesRaw.hasOwnProperty(aliasName)) {
                    this.addAliasValues(aliasName, aliasesRaw[aliasName]);
                }
            }
        };
        /* Functions
        */
        /**
         * Adds a triggerable event by marking a new callback under the trigger's
         * triggers. Any aliases for the label are also given the callback.
         *
         * @param trigger   The name of the triggered event.
         * @param label   The code within the trigger to call within,
         *                typically either a character code or an alias.
         * @param callback   The callback Function to be triggered.
         */
        InputWritr.prototype.addEvent = function (trigger, label, callback) {
            var i;
            if (!this.triggers.hasOwnProperty(trigger)) {
                throw new Error("Unknown trigger requested: '" + trigger + "'.");
            }
            this.triggers[trigger][label] = callback;
            if (this.aliases.hasOwnProperty(label)) {
                for (i = 0; i < this.aliases[label].length; i += 1) {
                    this.triggers[trigger][this.aliases[label][i]] = callback;
                }
            }
        };
        /**
         * Removes a triggerable event by deleting any callbacks under the trigger's
         * triggers. Any aliases for the label are also given the callback.
         *
         * @param trigger   The name of the triggered event.
         * @param label   The code within the trigger to call within,
         *                typically either a character code or an alias.
         */
        InputWritr.prototype.removeEvent = function (trigger, label) {
            var i;
            if (!this.triggers.hasOwnProperty(trigger)) {
                throw new Error("Unknown trigger requested: '" + trigger + "'.");
            }
            delete this.triggers[trigger][label];
            if (this.aliases.hasOwnProperty(label)) {
                for (i = 0; i < this.aliases[label].length; i += 1) {
                    if (this.triggers[trigger][this.aliases[label][i]]) {
                        delete this.triggers[trigger][this.aliases[label][i]];
                    }
                }
            }
        };
        /**
         * Stores the current history in the histories listing. this.restartHistory
         * is typically called directly after.
         *
         * @param name   A key to store the history under (by default, one greater than
         *               the length of Object.keys(this.histories)).
         */
        InputWritr.prototype.saveHistory = function (name) {
            if (name === void 0) { name = Object.keys(this.histories).length.toString(); }
            this.histories[name] = this.currentHistory;
        };
        /**
         * Clears the currently tracked inputs history and resets the starting time,
         * and (optionally) saves the current history.
         *
         * @param keepHistory   Whether the currently tracked history of inputs should
         *                      be added to the master listing (by default, true).
         */
        InputWritr.prototype.restartHistory = function (keepHistory) {
            if (keepHistory === void 0) { keepHistory = true; }
            if (keepHistory) {
                this.saveHistory();
            }
            this.currentHistory = {};
            this.startingTime = this.getTimestamp();
        };
        /**
         * "Plays" back a history of event information by simulating each keystroke
         * in a new call, timed by setTimeout.
         *
         * @param history   The events history to play back.
         * @remarks This will execute the same actions in the same order as before,
         *          but the arguments object may be different.
         * @remarks Events will be added to history again, as duplicates.
         */
        InputWritr.prototype.playHistory = function (history) {
            var time;
            for (time in history) {
                if (history.hasOwnProperty(time)) {
                    setTimeout(this.makeEventCall(history[time]), (Number(time) - this.startingTime) | 0);
                }
            }
        };
        /**
         * Primary driver function to run an event. The event is chosen from the
         * triggers object, and called with eventInformation as the input.
         *
         * @param event   The event Function (or String alias thereof) to call.
         * @param [keyCode]   The alias of the event Function under triggers[event],
         *                    if event is a String.
         * @param [sourceEvent]   The raw event that caused the calling Pipe
         *                        to be triggered, such as a MouseEvent.
         * @returns The result of calling the triggered event.
         */
        InputWritr.prototype.callEvent = function (event, keyCode, sourceEvent) {
            if (!event) {
                throw new Error("Blank event given to InputWritr.");
            }
            if (!this.canTrigger(event, keyCode, sourceEvent)) {
                return;
            }
            if (event.constructor === String) {
                event = this.triggers[event][keyCode];
            }
            return event(this.eventInformation, sourceEvent);
        };
        /**
         * Creates and returns a Function to run a trigger.
         *
         * @param trigger   The label for the Array of functions that the
         *                  pipe function should choose from.
         * @param codeLabel   A mapping String for the alias to get the
         *                    alias from the event.
         * @param [preventDefaults]   Whether the input to the pipe Function
         *                            will be an DOM-style event, where
         *                            .preventDefault() should be called.
         * @returns A Function that, when called on an event, runs this.callEvent
         *          on the appropriate trigger event.
         */
        InputWritr.prototype.makePipe = function (trigger, codeLabel, preventDefaults) {
            var _this = this;
            var functions = this.triggers[trigger];
            if (!functions) {
                throw new Error("No trigger of label '" + trigger + "' defined.");
            }
            return function (event) {
                var alias = event[codeLabel];
                // Typical usage means alias will be an event from a key/mouse input
                if (preventDefaults && event.preventDefault instanceof Function) {
                    event.preventDefault();
                }
                // If there's a Function under that alias, run it
                if (functions.hasOwnProperty(alias)) {
                    if (_this.isRecording()) {
                        _this.saveEventInformation([trigger, alias]);
                    }
                    _this.callEvent(functions[alias], alias, event);
                }
            };
        };
        /**
         * Curry utility to create a closure that runs callEvent when called.
         *
         * @param info   An array containing [trigger, alias].
         * @returns A closure that activates a trigger when called.
         */
        InputWritr.prototype.makeEventCall = function (info) {
            var _this = this;
            return function () {
                _this.callEvent(info[0], info[1]);
                if (_this.isRecording()) {
                    _this.saveEventInformation(info);
                }
            };
        };
        /**
         * Records event information in this.currentHistory.
         *
         * @param info   Information on the event, as [trigger, alias].
         */
        InputWritr.prototype.saveEventInformation = function (info) {
            this.currentHistory[this.getTimestamp() | 0] = info;
        };
        return InputWritr;
    })();
    InputWritr_1.InputWritr = InputWritr;
})(InputWritr || (InputWritr = {}));
/// <reference path="InputWritr-0.2.0.ts" />
var DeviceLayr;
(function (DeviceLayr_1) {
    "use strict";
    /**
     * Status possibilities for an axis. Neutral is the default; positive is above
     * its threshold; negative is below the threshold / -1.
     */
    (function (AxisStatus) {
        /**
         * Low axis status (lower than the negative of the threshold).
         */
        AxisStatus[AxisStatus["negative"] = 0] = "negative";
        /**
         * Default axis status (absolutely closer to 0 than the threshold).
         */
        AxisStatus[AxisStatus["neutral"] = 1] = "neutral";
        /**
         * High axis status (higher than the threshold).
         */
        AxisStatus[AxisStatus["positive"] = 2] = "positive";
    })(DeviceLayr_1.AxisStatus || (DeviceLayr_1.AxisStatus = {}));
    var AxisStatus = DeviceLayr_1.AxisStatus;
    /**
     * A layer on InputWritr to map GamePad API device actions to InputWritr pipes.
     */
    var DeviceLayr = (function () {
        /**
         * Initializes a new instance of the DeviceLayr class.
         *
         * @param settings   Settings to use for initialization.
         */
        function DeviceLayr(settings) {
            if (typeof settings === "undefined") {
                throw new Error("No settings object given to DeviceLayr.");
            }
            if (typeof settings.InputWriter === "undefined") {
                throw new Error("No InputWriter given to DeviceLayr.");
            }
            this.InputWritr = settings.InputWriter;
            this.triggers = settings.triggers || {};
            this.aliases = settings.aliases || {
                "on": "on",
                "off": "off"
            };
            this.gamepads = [];
        }
        /* Simple gets
        */
        /**
         * @returns The InputWritr being piped button and joystick triggers.
         */
        DeviceLayr.prototype.getInputWritr = function () {
            return this.InputWritr;
        };
        /**
         * @returns Mapping of which device controls should cause what triggers,
         *          along with their current statuses.
         */
        DeviceLayr.prototype.getTriggers = function () {
            return this.triggers;
        };
        /**
         * @returns For "on" and "off" activations, the equivalent event keys
         *          to pass to the internal InputWritr.
         */
        DeviceLayr.prototype.getAliases = function () {
            return this.aliases;
        };
        /**
         * @returns Any added gamepads (devices), in order of activation.
         */
        DeviceLayr.prototype.getGamepads = function () {
            return this.gamepads;
        };
        /* Registration
        */
        /**
         * If possible, checks the navigator for new gamepads, and adds them if found.
         *
         * @returns How many gamepads were added.
         */
        DeviceLayr.prototype.checkNavigatorGamepads = function () {
            if (typeof navigator.getGamepads === "undefined" || !navigator.getGamepads()[this.gamepads.length]) {
                return 0;
            }
            this.registerGamepad(navigator.getGamepads()[this.gamepads.length]);
            return this.checkNavigatorGamepads() + 1;
        };
        /**
         * Registers a new gamepad.
         *
         * @param gamepad   The gamepad to register.
         */
        DeviceLayr.prototype.registerGamepad = function (gamepad) {
            this.gamepads.push(gamepad);
            this.setDefaultTriggerStatuses(gamepad, this.triggers);
        };
        /* Triggers
        */
        /**
         * Checks the trigger statuses of all known gamepads.
         */
        DeviceLayr.prototype.activateAllGamepadTriggers = function () {
            for (var i = 0; i < this.gamepads.length; i += 1) {
                this.activateGamepadTriggers(this.gamepads[i]);
            }
        };
        /**
         * Checks the trigger status of a gamepad, calling the equivalent InputWritr
         * events if any triggers have occurred.
         *
         * @param gamepad   The gamepad whose status is to be checked.
         */
        DeviceLayr.prototype.activateGamepadTriggers = function (gamepad) {
            var mapping = DeviceLayr.controllerMappings[gamepad.mapping || "standard"], i;
            for (i = Math.min(mapping.axes.length, gamepad.axes.length) - 1; i >= 0; i -= 1) {
                this.activateAxisTrigger(gamepad, mapping.axes[i].name, mapping.axes[i].axis, gamepad.axes[i]);
            }
            for (i = Math.min(mapping.buttons.length, gamepad.buttons.length) - 1; i >= 0; i -= 1) {
                this.activateButtonTrigger(gamepad, mapping.buttons[i], gamepad.buttons[i].pressed);
            }
        };
        /**
         * Checks for triggered changes to an axis, and calls the equivalent InputWritr
         * event if one is found.
         *
         * @param gamepad   The gamepad whose triggers are to be checked.
         * @param name   The name of the axis, typically "x" or "y".
         * @param magnitude   The current value of the axis, in [1, -1].
         * @returns Whether the trigger was activated.
         */
        DeviceLayr.prototype.activateAxisTrigger = function (gamepad, name, axis, magnitude) {
            var listing = this.triggers[name][axis], status;
            if (!listing) {
                return;
            }
            // If the axis' current status matches the new one, don't do anything
            status = this.getAxisStatus(gamepad, magnitude);
            if (listing.status === status) {
                return false;
            }
            // If it exists, release the old axis via the InputWritr using the off alias
            if (listing.status !== undefined && listing[AxisStatus[listing.status]] !== undefined) {
                this.InputWritr.callEvent(this.aliases.off, listing[AxisStatus[listing.status]]);
            }
            // Mark the new status in the listing
            listing.status = status;
            // Trigger the new status via the InputWritr using the on alias
            if (listing[AxisStatus[status]] !== undefined) {
                this.InputWritr.callEvent(this.aliases.on, listing[AxisStatus[status]]);
            }
            return true;
        };
        /**
         * Checks for triggered changes to a button, and calls the equivalent InputWritr
         * event if one is found.
         *
         * @param gamepad   The gamepad whose triggers are to be checked.
         * @param {String} name   The name of the button, such as "a" or "left".
         * @param {Boolean} status   Whether the button is activated (pressed).
         * @returns {Boolean} Whether the trigger was activated.
         */
        DeviceLayr.prototype.activateButtonTrigger = function (gamepad, name, status) {
            var listing = this.triggers[name];
            // If the button's current status matches the new one, don't do anything
            if (!listing || listing.status === status) {
                return false;
            }
            listing.status = status;
            // Trigger the new status via the InputWritr using the new alias
            this.InputWritr.callEvent(status ? this.aliases.on : this.aliases.off, listing.trigger);
            return true;
        };
        /**
         * Clears the statuses of all axes and buttons on all known gamepads.
         */
        DeviceLayr.prototype.clearAllGamepadTriggers = function () {
            for (var i = 0; i < this.gamepads.length; i += 1) {
                this.clearGamepadTriggers(this.gamepads[i]);
            }
        };
        /**
         * Clears the status of all axes and buttons on a gamepad.
         *
         * @param gamepad   The gamepad whose triggers are to be cleared.
         */
        DeviceLayr.prototype.clearGamepadTriggers = function (gamepad) {
            var mapping = DeviceLayr.controllerMappings[gamepad.mapping || "standard"], i;
            for (i = 0; i < mapping.axes.length; i += 1) {
                this.clearAxisTrigger(gamepad, mapping.axes[i].name, mapping.axes[i].axis);
            }
            for (i = 0; i < mapping.buttons.length; i += 1) {
                this.clearButtonTrigger(gamepad, mapping.buttons[i]);
            }
        };
        /**
         * Sets the status of an axis to neutral.
         *
         * @param gamepad   The gamepad whose axis is to be cleared.
         * @param name   The name of the axis, typically "x" or "y".
         */
        DeviceLayr.prototype.clearAxisTrigger = function (gamepad, name, axis) {
            var listing = this.triggers[name][axis];
            listing.status = AxisStatus.neutral;
        };
        /**
         * Sets the status of a button to off.
         *
         * @param gamepad   The gamepad whose button is to be checked.
         * @param name   The name of the button, such as "a" or "left".
         */
        DeviceLayr.prototype.clearButtonTrigger = function (gamepad, name) {
            var listing = this.triggers[name];
            listing.status = false;
        };
        /* Private utilities
        */
        /**
         * Puts the default values for all buttons and joystick axes that don't already
         * have statuses. This is useful so activation checks don't glitch out.
         *
         * @param gamepad   The gamepad whose triggers are to be defaulted.
         * @param triggers   The triggers to default, as listings keyed by name.
         */
        DeviceLayr.prototype.setDefaultTriggerStatuses = function (gamepad, triggers) {
            var mapping = DeviceLayr.controllerMappings[gamepad.mapping || "standard"], button, joystick, i, j;
            for (i = 0; i < mapping.buttons.length; i += 1) {
                button = triggers[mapping.buttons[i]];
                if (button && button.status === undefined) {
                    button.status = false;
                }
            }
            for (i = 0; i < mapping.axes.length; i += 1) {
                joystick = triggers[mapping.axes[i].name];
                for (j in joystick) {
                    if (!joystick.hasOwnProperty(j)) {
                        continue;
                    }
                    if (joystick[j].status === undefined) {
                        joystick[j].status = AxisStatus.neutral;
                    }
                }
            }
        };
        /**
         * @param gamepad   The gamepad whose axis is being looked up.
         * @param magnitude   The direction an axis is measured at, in [-1, 1].
         * @returns What direction a magnitude is relative to 0.
         */
        DeviceLayr.prototype.getAxisStatus = function (gamepad, magnitude) {
            var joystickThreshold = DeviceLayr.controllerMappings[gamepad.mapping || "standard"].joystickThreshold;
            if (magnitude > joystickThreshold) {
                return AxisStatus.positive;
            }
            if (magnitude < -joystickThreshold) {
                return AxisStatus.negative;
            }
            return AxisStatus.neutral;
        };
        /**
         * Known mapping schemas for standard controllers. These are referenced
         * by added gamepads via the gamepads' .name attribute.
         */
        DeviceLayr.controllerMappings = {
            /**
             * Controller mapping for a typical Xbox style controller.
             */
            "standard": {
                "axes": [
                    {
                        "axis": "x",
                        "joystick": 0,
                        "name": "leftJoystick"
                    },
                    {
                        "axis": "y",
                        "joystick": 0,
                        "name": "leftJoystick"
                    },
                    {
                        "axis": "x",
                        "joystick": 1,
                        "name": "rightJoystick"
                    },
                    {
                        "axis": "y",
                        "joystick": 1,
                        "name": "rightJoystick"
                    }
                ],
                "buttons": [
                    "a",
                    "b",
                    "x",
                    "y",
                    "leftTop",
                    "rightTop",
                    "leftTrigger",
                    "rightTrigger",
                    "select",
                    "start",
                    "leftStick",
                    "rightStick",
                    "dpadUp",
                    "dpadDown",
                    "dpadLeft",
                    "dpadRight"
                ],
                "joystickThreshold": .49
            }
        };
        return DeviceLayr;
    })();
    DeviceLayr_1.DeviceLayr = DeviceLayr;
})(DeviceLayr || (DeviceLayr = {}));
var FPSAnalyzr;
(function (FPSAnalyzr_1) {
    "use strict";
    /**
     * A general utility for obtaining and analyzing framerate measurements. The
     * most recent measurements are kept up to a certain point (either an infinite
     * number or a set amount). Options for analyzing the data such as getting the
     * mean, median, extremes, etc. are available.
     */
    var FPSAnalyzr = (function () {
        /**
         * Initializes a new instance of the FPSAnalyzr class.
         *
         * @param [settings]
         */
        function FPSAnalyzr(settings) {
            if (settings === void 0) { settings = {}; }
            this.maxKept = settings.maxKept || 35;
            this.numRecorded = 0;
            this.ticker = -1;
            // If maxKept is a Number, make the measurements array that long.
            // If it's infinite, make measurements an {} (infinite Array).
            this.measurements = isFinite(this.maxKept) ? new Array(this.maxKept) : {};
            // Headless browsers like PhantomJS won't know performance, so Date.now
            // is used as a backup
            if (typeof settings.getTimestamp === "undefined") {
                if (typeof performance === "undefined") {
                    this.getTimestamp = function () {
                        return Date.now();
                    };
                }
                else {
                    this.getTimestamp = (performance.now
                        || performance.webkitNow
                        || performance.mozNow
                        || performance.msNow
                        || performance.oNow).bind(performance);
                }
            }
            else {
                this.getTimestamp = settings.getTimestamp;
            }
        }
        /* Public interface
        */
        /**
         * Standard public measurement function.
         * Marks the current timestamp as timeCurrent, and adds an FPS measurement
         * if there was a previous timeCurrent.
         *
         * @param [time]   An optional timestamp (by default, getTimestamp() is used).
         */
        FPSAnalyzr.prototype.measure = function (time) {
            if (time === void 0) { time = this.getTimestamp(); }
            if (this.timeCurrent) {
                this.addFPS(1000 / (time - this.timeCurrent));
            }
            this.timeCurrent = time;
        };
        /**
         * Adds an FPS measurement to measurements, and increments the associated
         * count variables.
         *
         * @param fps   An FPS calculated as the difference between two timestamps.
         */
        FPSAnalyzr.prototype.addFPS = function (fps) {
            this.ticker = (this.ticker += 1) % this.maxKept;
            this.measurements[this.ticker] = fps;
            this.numRecorded += 1;
        };
        /* Gets
        */
        /**
         * @returns The number of FPS measurements to keep.
         */
        FPSAnalyzr.prototype.getMaxKept = function () {
            return this.maxKept;
        };
        /**
         * @returns The actual number of FPS measurements currently known.
         */
        FPSAnalyzr.prototype.getNumRecorded = function () {
            return this.numRecorded;
        };
        /**
         * @returns The most recent performance.now timestamp.
         */
        FPSAnalyzr.prototype.getTimeCurrent = function () {
            return this.timeCurrent;
        };
        /**
         * @returns The current position in measurements.
         */
        FPSAnalyzr.prototype.getTicker = function () {
            return this.ticker;
        };
        /**
         * Get function for a copy of the measurements listing (if the number of
         * measurements is less than the max, that size is used)
         *
         * @returns A Number[] of the most recent FPS measurements.
         */
        FPSAnalyzr.prototype.getMeasurements = function () {
            var fpsKeptReal = Math.min(this.maxKept, this.numRecorded), copy, i;
            if (isFinite(this.maxKept)) {
                copy = new Array(fpsKeptReal);
            }
            else {
                copy = {};
                copy.length = fpsKeptReal;
            }
            for (i = fpsKeptReal - 1; i >= 0; --i) {
                copy[i] = this.measurements[i];
            }
            return copy;
        };
        /**
         * Get function for a copy of the measurements listing, but with the FPS
         * measurements transformed back into time differences
         *
         * @returns A container of the most recent FPS time differences.
         */
        FPSAnalyzr.prototype.getDifferences = function () {
            var copy = this.getMeasurements(), i;
            for (i = copy.length - 1; i >= 0; --i) {
                copy[i] = 1000 / copy[i];
            }
            return copy;
        };
        /**
         * @returns The average recorded FPS measurement.
         */
        FPSAnalyzr.prototype.getAverage = function () {
            var total = 0, max = Math.min(this.maxKept, this.numRecorded), i;
            for (i = max - 1; i >= 0; --i) {
                total += this.measurements[i];
            }
            return total / max;
        };
        /**
         * @returns The median recorded FPS measurement.
         * @remarks This is O(n*log(n)), where n is the size of the history,
         *          as it creates a copy of the history and sorts it.
         */
        FPSAnalyzr.prototype.getMedian = function () {
            var copy = this.getMeasurementsSorted(), fpsKeptReal = copy.length, fpsKeptHalf = Math.floor(fpsKeptReal / 2);
            if (copy.length % 2 === 0) {
                return copy[fpsKeptHalf];
            }
            else {
                return (copy[fpsKeptHalf - 2] + copy[fpsKeptHalf]) / 2;
            }
        };
        /**
         * @returns Array containing the lowest and highest recorded FPS
         *          measurements, in that order.
         */
        FPSAnalyzr.prototype.getExtremes = function () {
            var lowest = this.measurements[0], highest = lowest, max = Math.min(this.maxKept, this.numRecorded), fps, i;
            for (i = max - 1; i >= 0; --i) {
                fps = this.measurements[i];
                if (fps > highest) {
                    highest = fps;
                }
                else if (fps < lowest) {
                    lowest = fps;
                }
            }
            return [lowest, highest];
        };
        /**
         * @returns The range of recorded FPS measurements.
         */
        FPSAnalyzr.prototype.getRange = function () {
            var extremes = this.getExtremes();
            return extremes[1] - extremes[0];
        };
        /**
         * Converts all measurements to a Number[] in sorted order, regardless
         * of whether they're initially stored in an Array or Object.
         *
         * @returns All measurements, sorted.
         */
        FPSAnalyzr.prototype.getMeasurementsSorted = function () {
            var copy, i;
            if (this.measurements.constructor === Array) {
                copy = [].slice.call(this.measurements).sort();
            }
            else {
                copy = [];
                for (i in this.measurements) {
                    if (this.measurements.hasOwnProperty(i)) {
                        if (typeof this.measurements[i] !== "undefined") {
                            copy[i] = this.measurements[i];
                        }
                    }
                }
                copy.sort();
            }
            if (this.numRecorded < this.maxKept) {
                copy.length = this.numRecorded;
            }
            return copy.sort();
        };
        return FPSAnalyzr;
    })();
    FPSAnalyzr_1.FPSAnalyzr = FPSAnalyzr;
})(FPSAnalyzr || (FPSAnalyzr = {}));
/// <reference path="FPSAnalyzr-0.2.1.ts" />
var GamesRunnr;
(function (GamesRunnr_1) {
    "use strict";
    /**
     * A class to continuously series of "game" Functions. Each game is run in a
     * set order and the group is run as a whole at a particular interval, with a
     * configurable speed. Playback can be triggered manually, or driven by a timer
     * with pause and play hooks. For automated playback, statistics are
     * available via an internal FPSAnalyzer.
     */
    var GamesRunnr = (function () {
        /**
         * Initializes a new instance of the GamesRunnr class.
         *
         * @param settings   Settings to be used for initialization.
         */
        function GamesRunnr(settings) {
            if (typeof settings === "undefined") {
                throw new Error("No settings object given GamesRunnr.");
            }
            if (typeof settings.games === "undefined") {
                throw new Error("No games given to GamesRunnr.");
            }
            var i;
            this.games = settings.games;
            this.interval = settings.interval || 1000 / 60;
            this.speed = settings.speed || 1;
            this.onPause = settings.onPause;
            this.onPlay = settings.onPlay;
            this.callbackArguments = settings.callbackArguments || [this];
            this.adjustFramerate = settings.adjustFramerate;
            this.FPSAnalyzer = settings.FPSAnalyzer || new FPSAnalyzr.FPSAnalyzr(settings.FPSAnalyzerSettings);
            this.scope = settings.scope || this;
            this.paused = true;
            this.upkeepScheduler = settings.upkeepScheduler || function (handler, timeout) {
                return setTimeout(handler, timeout);
            };
            this.upkeepCanceller = settings.upkeepCanceller || function (handle) {
                clearTimeout(handle);
            };
            this.upkeepBound = this.upkeep.bind(this);
            for (i = 0; i < this.games.length; i += 1) {
                this.games[i] = this.games[i].bind(this.scope);
            }
            this.setIntervalReal();
        }
        /* Gets
        */
        /**
         * @returns The FPSAnalyzer used in the GamesRunnr.
         */
        GamesRunnr.prototype.getFPSAnalyzer = function () {
            return this.FPSAnalyzer;
        };
        /**
         * @returns Whether this is paused.
         */
        GamesRunnr.prototype.getPaused = function () {
            return this.paused;
        };
        /**
         * @returns The Array of game Functions.
         */
        GamesRunnr.prototype.getGames = function () {
            return this.games;
        };
        /**
         * @returns The interval between upkeeps.
         */
        GamesRunnr.prototype.getInterval = function () {
            return this.interval;
        };
        /**
         * @returns The speed multiplier being applied to the interval.
         */
        GamesRunnr.prototype.getSpeed = function () {
            return this.speed;
        };
        /**
         * @returns The optional trigger to be called on pause.
         */
        GamesRunnr.prototype.getOnPause = function () {
            return this.onPause;
        };
        /**
         * @returns The optional trigger to be called on play.
         */
        GamesRunnr.prototype.getOnPlay = function () {
            return this.onPlay;
        };
        /**
         * @returns Arguments to be given to the optional trigger Functions.
         */
        GamesRunnr.prototype.getCallbackArguments = function () {
            return this.callbackArguments;
        };
        /**
         * @returns Function used to schedule the next upkeep.
         */
        GamesRunnr.prototype.getUpkeepScheduler = function () {
            return this.upkeepScheduler;
        };
        /**
         * @returns {Function} Function used to cancel the next upkeep.
         */
        GamesRunnr.prototype.getUpkeepCanceller = function () {
            return this.upkeepCanceller;
        };
        /* Runtime
        */
        /**
         * Meaty function, run every <interval*speed> milliseconds, to mark an FPS
         * measurement and run every game once.
         */
        GamesRunnr.prototype.upkeep = function () {
            if (this.paused) {
                return;
            }
            // Prevents double upkeeping, in case a new upkeepNext was scheduled.
            this.upkeepCanceller(this.upkeepNext);
            if (this.adjustFramerate) {
                this.upkeepNext = this.upkeepScheduler(this.upkeepBound, this.intervalReal - (this.upkeepTimed() | 0));
            }
            else {
                this.upkeepNext = this.upkeepScheduler(this.upkeepBound, this.intervalReal);
                this.runAllGames();
            }
            if (this.FPSAnalyzer) {
                this.FPSAnalyzer.measure();
            }
        };
        /**
         * A utility for this.upkeep that calls the same games.forEach(run), timing
         * the total execution time.
         *
         * @returns The total time spent, in milliseconds.
         */
        GamesRunnr.prototype.upkeepTimed = function () {
            if (!this.FPSAnalyzer) {
                throw new Error("An internal FPSAnalyzr is required for upkeepTimed.");
            }
            var now = this.FPSAnalyzer.getTimestamp();
            this.runAllGames();
            return this.FPSAnalyzer.getTimestamp() - now;
        };
        /**
         * Continues execution of this.upkeep by calling it. If an onPlay has been
         * defined, it's called before.
         */
        GamesRunnr.prototype.play = function () {
            if (!this.paused) {
                return;
            }
            this.paused = false;
            if (this.onPlay) {
                this.onPlay.apply(this, this.callbackArguments);
            }
            this.upkeep();
        };
        /**
         * Stops execution of this.upkeep, and cancels the next call. If an onPause
         * has been defined, it's called after.
         */
        GamesRunnr.prototype.pause = function () {
            if (this.paused) {
                return;
            }
            this.paused = true;
            if (this.onPause) {
                this.onPause.apply(this, this.callbackArguments);
            }
            this.upkeepCanceller(this.upkeepNext);
        };
        /**
         * Calls upkeep a <num or 1> number of times, immediately.
         *
         * @param [num]   How many times to upkeep (by default, 1).
         */
        GamesRunnr.prototype.step = function (times) {
            if (times === void 0) { times = 1; }
            this.play();
            this.pause();
            if (times > 0) {
                this.step(times - 1);
            }
        };
        /**
         * Toggles whether this is paused, and calls the appropriate Function.
         */
        GamesRunnr.prototype.togglePause = function () {
            this.paused ? this.play() : this.pause();
        };
        /* Games manipulations
        */
        /**
         * Sets the interval between between upkeeps.
         *
         * @param interval   The new time interval in milliseconds.
         */
        GamesRunnr.prototype.setInterval = function (interval) {
            var intervalReal = Number(interval);
            if (isNaN(intervalReal)) {
                throw new Error("Invalid interval given to setInterval: " + interval);
            }
            this.interval = intervalReal;
            this.setIntervalReal();
        };
        /**
         * Sets the speed multiplier for the interval.
         *
         * @param speed   The new speed multiplier. 2 will cause interval to be
         *                twice as fast, and 0.5 will be half as fast.
         */
        GamesRunnr.prototype.setSpeed = function (speed) {
            var speedReal = Number(speed);
            if (isNaN(speedReal)) {
                throw new Error("Invalid speed given to setSpeed: " + speed);
            }
            this.speed = speedReal;
            this.setIntervalReal();
        };
        /* Utilities
        */
        /**
         * Sets the intervalReal variable, which is interval * (inverse of speed).
         */
        GamesRunnr.prototype.setIntervalReal = function () {
            this.intervalReal = (1 / this.speed) * this.interval;
        };
        /**
         * Runs all games in this.games.
         */
        GamesRunnr.prototype.runAllGames = function () {
            for (var i = 0; i < this.games.length; i += 1) {
                this.games[i]();
            }
        };
        return GamesRunnr;
    })();
    GamesRunnr_1.GamesRunnr = GamesRunnr;
})(GamesRunnr || (GamesRunnr = {}));
var StringFilr;
(function (StringFilr_1) {
    "use strict";
    /**
     * A general utility for retrieving data from an Object based on nested class
     * names. Class names may be given in any order ro retrieve nested data.
     */
    var StringFilr = (function () {
        /**
         * Initializes a new instance of the StringFilr class.
         *
         * @param settings   Settings to be used for initialization.
         */
        function StringFilr(settings) {
            if (!settings) {
                throw new Error("No settings given to StringFilr.");
            }
            if (!settings.library) {
                throw new Error("No library given to StringFilr.");
            }
            this.library = settings.library;
            this.normal = settings.normal;
            this.requireNormalKey = settings.requireNormalKey;
            this.cache = {};
            if (this.requireNormalKey) {
                if (typeof this.normal === "undefined") {
                    throw new Error("StringFilr is given requireNormalKey, but no normal class.");
                }
                this.ensureLibraryNormal();
            }
        }
        /**
         * @returns The base library of stored information.
         */
        StringFilr.prototype.getLibrary = function () {
            return this.library;
        };
        /**
         * @returns The optional normal class String.
         */
        StringFilr.prototype.getNormal = function () {
            return this.normal;
        };
        /**
         * @returns The complete cache of previously completed lookups.
         */
        StringFilr.prototype.getCache = function () {
            return this.cache;
        };
        /**
         * @returns A cached value, if it exists.
         */
        StringFilr.prototype.getCached = function (key) {
            return this.cache[key];
        };
        /**
         * Completely clears the lookup cache.
         */
        StringFilr.prototype.clearCache = function () {
            this.cache = {};
        };
        /**
         * Clears the cached entry for a key.
         *
         * @param keyRaw   The raw key whose lookup is to be cleared.
         */
        StringFilr.prototype.clearCached = function (keyRaw) {
            delete this.cache[keyRaw];
            if (this.normal) {
                delete this.cache[keyRaw.replace(this.normal, "")];
            }
        };
        /**
         * Retrieves the deepest matching data in the library for a key.
         *
         * @param keyRaw   The raw key for data to look up, in String form.
         * @returns The deepest matching data in the library.
         */
        StringFilr.prototype.get = function (keyRaw) {
            var key, result;
            if (this.normal) {
                key = keyRaw.replace(this.normal, "");
            }
            else {
                key = keyRaw;
            }
            // Quickly return a cached result if it exists
            if (this.cache.hasOwnProperty(key)) {
                return this.cache[key];
            }
            // Since a cache didn't exist, it must be found within the library
            result = this.followClass(key.split(/\s+/g), this.library);
            this.cache[key] = this.cache[keyRaw] = result;
            return result;
        };
        /**
         * Utility Function to follow a path into the library (this is the driver
         * for searching into the library). For each available key, if it matches
         * a key in current, it is removed from keys and recursion happens on the
         * sub-directory in current.
         *
         * @param keys   The currently available keys to search within.
         * @param current   The current location being searched within the library.
         * @returns The most deeply matched part of the library.
         */
        StringFilr.prototype.followClass = function (keys, current) {
            var key, i;
            // If keys runs out, we're done
            if (!keys || !keys.length) {
                return current;
            }
            // For each key in the current array...
            for (i = 0; i < keys.length; i += 1) {
                key = keys[i];
                // ...if it matches, recurse on the other keys
                if (current.hasOwnProperty(key)) {
                    keys.splice(i, 1);
                    return this.followClass(keys, current[key]);
                }
            }
            // If no key matched, try the normal (default)
            if (this.normal && current.hasOwnProperty(this.normal)) {
                return this.followClass(keys, current[this.normal]);
            }
            // Nothing matches anything; we're done.
            return current;
        };
        /**
         * Utility helper to recursively check for tree branches in the library
         * that don't have a key equal to the normal. For each sub-directory that
         * is caught, the path to it is added to output.
         *
         * @param current   The current location being searched within the library.
         * @param path   The current path within the library.
         * @param output   Paths to parts that don't have a matching key.
         * @returns output
         */
        StringFilr.prototype.findLackingNormal = function (current, path, output) {
            var i;
            if (!current.hasOwnProperty(this.normal)) {
                output.push(path);
            }
            if (typeof current[i] === "object") {
                for (i in current) {
                    if (current.hasOwnProperty(i)) {
                        this.findLackingNormal(current[i], path + " " + i, output);
                    }
                }
            }
            return output;
        };
        /**
         * Driver for this.findLackingNormal. If library directories are found to
         * not have a normal, it throws an error.
         */
        StringFilr.prototype.ensureLibraryNormal = function () {
            var caught = this.findLackingNormal(this.library, "base", []);
            if (caught.length) {
                throw new Error("Found " + caught.length + " library "
                    + "sub-directories missing the normal: "
                    + "\r\n  " + caught.join("\r\n  "));
            }
        };
        return StringFilr;
    })();
    StringFilr_1.StringFilr = StringFilr;
})(StringFilr || (StringFilr = {}));
/// <reference path="ChangeLinr-0.2.0.ts" />
/// <reference path="StringFilr-0.2.1.ts" />
var PixelRendr;
(function (PixelRendr) {
    "use strict";
    /**
     * Container for a "multiple" sprite, which is a sprite that contains separate
     * Uint8ClampedArray pieces of data for different sections (such as top, middle, etc.)
     */
    var SpriteMultiple = (function () {
        /**
         * Initializes a new instance of the SpriteMultiple class.
         *
         * @param sprites   Data for each sprite to import, keyed by container.
         * @param render   The parsed sprite source.
         */
        function SpriteMultiple(sprites, render) {
            var sources = render.source[2];
            this.sprites = sprites;
            this.direction = render.source[1];
            if (this.direction === "vertical" || this.direction === "corners") {
                this.topheight = sources.topheight | 0;
                this.bottomheight = sources.bottomheight | 0;
            }
            if (this.direction === "horizontal" || this.direction === "corners") {
                this.rightwidth = sources.rightwidth | 0;
                this.leftwidth = sources.leftwidth | 0;
            }
            this.middleStretch = sources.middleStretch || false;
        }
        return SpriteMultiple;
    })();
    PixelRendr.SpriteMultiple = SpriteMultiple;
})(PixelRendr || (PixelRendr = {}));
var PixelRendr;
(function (PixelRendr) {
    "use strict";
    /**
     * Summary container for a single PixelRendr sprite source. The original source
     * is stored, along with any generated outputs, information on its container,
     * and any filter.
     */
    var Render = (function () {
        /**
         * Initializes a new instance of the Render clsas.
         *
         * @param source   The original command to create this render.
         * @param filter   An optional filter to change colors by, if source
         *                 is a "filter" command.
         */
        function Render(source, filter) {
            this.source = source;
            this.filter = filter;
            this.sprites = {};
            this.containers = [];
        }
        return Render;
    })();
    PixelRendr.Render = Render;
})(PixelRendr || (PixelRendr = {}));
var PixelRendr;
(function (PixelRendr_1) {
    "use strict";
    /**
     * A moderately unusual graphics module designed to compress images as
     * compressed text blobs and store the text blobs in a StringFilr. These tasks
     * are performed and cached quickly enough for use in real-time environments,
     * such as real-time video games.
     */
    var PixelRendr = (function () {
        /**
         * Initializes a new instance of the PixelRendr class.
         *
         * @param settings   Settings to be used for initialization.
         */
        function PixelRendr(settings) {
            if (!settings) {
                throw new Error("No settings given to PixelRendr.");
            }
            if (!settings.paletteDefault) {
                throw new Error("No paletteDefault given to PixelRendr.");
            }
            this.paletteDefault = settings.paletteDefault;
            this.digitsizeDefault = this.getDigitSizeFromArray(this.paletteDefault);
            this.digitsplit = new RegExp(".{1," + this.digitsizeDefault + "}", "g");
            this.library = {
                "raws": settings.library || {}
            };
            this.scale = settings.scale || 1;
            this.filters = settings.filters || {};
            this.flipVert = settings.flipVert || "flip-vert";
            this.flipHoriz = settings.flipHoriz || "flip-horiz";
            this.spriteWidth = settings.spriteWidth || "spriteWidth";
            this.spriteHeight = settings.spriteHeight || "spriteHeight";
            this.Uint8ClampedArray = settings.Uint8ClampedArray || window.Uint8ClampedArray || window.Uint8Array;
            // The first ChangeLinr does the raw processing of Strings to sprites
            // This is used to load & parse sprites into memory on startup
            this.ProcessorBase = new ChangeLinr.ChangeLinr({
                "transforms": {
                    "spriteUnravel": this.spriteUnravel.bind(this),
                    "spriteApplyFilter": this.spriteApplyFilter.bind(this),
                    "spriteExpand": this.spriteExpand.bind(this),
                    "spriteGetArray": this.spriteGetArray.bind(this)
                },
                "pipeline": ["spriteUnravel", "spriteApplyFilter", "spriteExpand", "spriteGetArray"]
            });
            // The second ChangeLinr does row repeating and flipping
            // This is done on demand when given a sprite's settings Object
            this.ProcessorDims = new ChangeLinr.ChangeLinr({
                "transforms": {
                    "spriteRepeatRows": this.spriteRepeatRows.bind(this),
                    "spriteFlipDimensions": this.spriteFlipDimensions.bind(this)
                },
                "pipeline": ["spriteRepeatRows", "spriteFlipDimensions"]
            });
            // As a utility, a processor is included to encode image data to sprites
            this.ProcessorEncode = new ChangeLinr.ChangeLinr({
                "transforms": {
                    "imageGetData": this.imageGetData.bind(this),
                    "imageGetPixels": this.imageGetPixels.bind(this),
                    "imageMapPalette": this.imageMapPalette.bind(this),
                    "imageCombinePixels": this.imageCombinePixels.bind(this)
                },
                "pipeline": ["imageGetData", "imageGetPixels", "imageMapPalette", "imageCombinePixels"],
                "doUseCache": false
            });
            this.library.sprites = this.libraryParse(this.library.raws);
            // The BaseFiler provides a searchable 'view' on the library of sprites
            this.BaseFiler = new StringFilr.StringFilr({
                "library": this.library.sprites,
                "normal": "normal" // to do: put this somewhere more official?
            });
            this.commandGenerators = {
                "multiple": this.generateSpriteCommandMultipleFromRender.bind(this),
                "same": this.generateSpriteCommandSameFromRender.bind(this),
                "filter": this.generateSpriteCommandFilterFromRender.bind(this)
            };
        }
        /* Simple gets
        */
        /**
         * @returns The base container for storing sprite information.
         */
        PixelRendr.prototype.getBaseLibrary = function () {
            return this.BaseFiler.getLibrary();
        };
        /**
         * @returns The StringFilr interface on top of the base library.
         */
        PixelRendr.prototype.getBaseFiler = function () {
            return this.BaseFiler;
        };
        /**
         * @returns The processor that turns raw strings into partial sprites.
         */
        PixelRendr.prototype.getProcessorBase = function () {
            return this.ProcessorBase;
        };
        /**
         * @returns The processor that converts partial sprites and repeats rows.
         */
        PixelRendr.prototype.getProcessorDims = function () {
            return this.ProcessorDims;
        };
        /**
         * @returns The processor that takes real images and compresses their data
         *          into sprite Strings.
         */
        PixelRendr.prototype.getProcessorEncode = function () {
            return this.ProcessorEncode;
        };
        /**
         * Retrieves the base sprite under the given key.
         *
         * @param key   A key for a base sprite.
         * @returns The base sprite for the key. This will be a Uint8ClampedArray
         *          or SpriteMultiple if a sprite is found, or the deepest matching
         *          Object in the library if not.
         */
        PixelRendr.prototype.getSpriteBase = function (key) {
            return this.BaseFiler.get(key);
        };
        /* External APIs
        */
        /**
         * Standard render function. Given a key, this finds the raw information via
         * BaseFiler and processes it using ProcessorDims. Attributes are needed so
         * the ProcessorDims can stretch it on width and height.
         *
         * @param key   The general key for the sprite.
         * @param attributes   Additional attributes for the sprite; width and height
         *                     Numbers are required.
         * @returns A sprite for the given key and attributes.
         */
        PixelRendr.prototype.decode = function (key, attributes) {
            var render = this.BaseFiler.get(key), sprite;
            if (!render) {
                throw new Error("No sprite found for " + key + ".");
            }
            // If the render doesn't have a listing for this key, create one
            if (!render.sprites.hasOwnProperty(key)) {
                this.generateRenderSprite(render, key, attributes);
            }
            sprite = render.sprites[key];
            if (!sprite || (sprite.constructor === this.Uint8ClampedArray && sprite.length === 0)) {
                throw new Error("Could not generate sprite for " + key + ".");
            }
            return sprite;
        };
        /**
         * Encodes an image into a sprite via ProcessorEncode.process.
         *
         * @param image   An image to encode.
         * @param callback   An optional callback to call with image and the result.
         * @param args   Any additional arguments to pass to the callback.
         */
        PixelRendr.prototype.encode = function (image, callback) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            var result = this.ProcessorEncode.process(image);
            if (callback) {
                callback.apply(void 0, [result, image].concat(args));
            }
            return result;
        };
        /**
         * Fetches an image from a source and encodes it into a sprite via
         * ProcessEncode.process. An HtmlImageElement is created and given an onload
         * of this.encode.
         *
         * @param uri   The URI of an image to encode.
         * @param callback   A callback to call on the results.
         */
        PixelRendr.prototype.encodeUri = function (uri, callback) {
            var image = document.createElement("img");
            image.onload = this.encode.bind(this, image, callback);
            image.src = uri;
        };
        /**
         * Miscellaneous utility to generate a complete palette from raw image pixel
         * data. Unique [r,g,b,a] values are found using tree-based caching, and
         * separated into grayscale (r,g,b equal) and general (r,g,b unequal). If a
         * pixel has a=0, it's completely transparent and goes before anything else
         * in the palette. Grayscale colors come next in order of light to dark, and
         * general colors come next sorted by decreasing r, g, and b in order.
         *
         * @param data   The equivalent data from a context's getImageData(...).data.
         * @param forceZeroColor   Whether the palette should have a [0,0,0,0] color
         *                         as the first element even if data does not contain
         *                         it (by default, false).
         * @param giveArrays   Whether the resulting palettes should be converted to
         *                     Arrays (by default, false).
         * @returns A working palette that may be used in sprite settings (Array[] if
         *          giveArrays is true).
         */
        PixelRendr.prototype.generatePaletteFromRawData = function (data, forceZeroColor, giveArrays) {
            var tree = {}, colorsGeneral = [], colorsGrayscale = [], output, i;
            for (i = 0; i < data.length; i += 4) {
                if (data[i + 3] === 0) {
                    forceZeroColor = true;
                    continue;
                }
                if (tree[data[i]]
                    && tree[data[i]][data[i + 1]]
                    && tree[data[i]][data[i + 1]][data[i + 2]]
                    && tree[data[i]][data[i + 1]][data[i + 2]][data[i + 3]]) {
                    continue;
                }
                if (!tree[data[i]]) {
                    tree[data[i]] = {};
                }
                if (!tree[data[i]][data[i + 1]]) {
                    tree[data[i]][data[i + 1]] = {};
                }
                if (!tree[data[i]][data[i + 1]][data[i + 2]]) {
                    tree[data[i]][data[i + 1]][data[i + 2]] = {};
                }
                if (!tree[data[i]][data[i + 1]][data[i + 2]][data[i + 3]]) {
                    tree[data[i]][data[i + 1]][data[i + 2]][data[i + 3]] = true;
                    if (data[i] === data[i + 1] && data[i + 1] === data[i + 2]) {
                        colorsGrayscale.push(data.subarray(i, i + 4));
                    }
                    else {
                        colorsGeneral.push(data.subarray(i, i + 4));
                    }
                }
            }
            // It's safe to sort grayscale colors just on their first values, since
            // grayscale implies they're all the same.
            colorsGrayscale.sort(function (a, b) {
                return a[0] - b[0];
            });
            // For regular colors, sort by the first color that's not equal, so in 
            // order red, green, blue, alpha.
            colorsGeneral.sort(function (a, b) {
                for (i = 0; i < 4; i += 1) {
                    if (a[i] !== b[i]) {
                        return b[i] - a[i];
                    }
                }
            });
            if (forceZeroColor) {
                output = [new this.Uint8ClampedArray([0, 0, 0, 0])]
                    .concat(colorsGrayscale)
                    .concat(colorsGeneral);
            }
            else {
                output = colorsGrayscale.concat(colorsGeneral);
            }
            if (!giveArrays) {
                return output;
            }
            for (i = 0; i < output.length; i += 1) {
                output[i] = Array.prototype.slice.call(output[i]);
            }
            return output;
        };
        /**
         * Copies a stretch of members from one Uint8ClampedArray or number[] to
         * another. This is a useful utility Function for code that may use this
         * PixelRendr to draw its output sprites, such as PixelDrawr.
         *
         * @param source   An Array-like source to copy from.
         * @param destination   An Array-like destination to copy to.
         * @param readloc   Where to start reading from in the source.
         * @param writeloc   Where to start writing to in the source.
         * @param writelength   How many members to copy over.
         * @see http://www.html5rocks.com/en/tutorials/webgl/typed_arrays/
         * @see http://www.javascripture.com/Uint8ClampedArray
         */
        PixelRendr.prototype.memcpyU8 = function (source, destination, readloc, writeloc, writelength) {
            if (readloc === void 0) { readloc = 0; }
            if (writeloc === void 0) { writeloc = 0; }
            if (writelength === void 0) { writelength = Math.max(0, Math.min(source.length, destination.length)); }
            // JIT compilation help
            var lwritelength = writelength + 0, lwriteloc = writeloc + 0, lreadloc = readloc + 0;
            while (lwritelength--) {
                destination[lwriteloc++] = source[lreadloc++];
            }
        };
        /* Library parsing
         */
        /**
         * Recursively travels through a library, turning all raw sprites and
         * commands into Renders.
         *
         * @param reference   The raw source structure to be parsed.
         * @param path   The path to the current place within the library.
         * @returns The parsed library Object.
         */
        PixelRendr.prototype.libraryParse = function (reference) {
            var setNew = {}, source, i;
            // For each child of the current layer:
            for (i in reference) {
                if (!reference.hasOwnProperty(i)) {
                    continue;
                }
                source = reference[i];
                switch (source.constructor) {
                    case String:
                        // Strings directly become IRenders
                        setNew[i] = new PixelRendr_1.Render(source);
                        break;
                    case Array:
                        // Arrays contain a String filter, a String[] source, and any
                        // number of following arguments
                        setNew[i] = new PixelRendr_1.Render(source, source[1]);
                        break;
                    default:
                        // If it's anything else, simply recurse
                        setNew[i] = this.libraryParse(source);
                        break;
                }
                // If a Render was created, mark setNew as a container
                if (setNew[i].constructor === PixelRendr_1.Render) {
                    setNew[i].containers.push({
                        "container": setNew,
                        "key": i
                    });
                }
            }
            return setNew;
        };
        /**
         * Generates a sprite for a Render based on its internal source and an
         * externally given String key and attributes Object. The sprite is stored
         * in the Render's sprites container under that key.
         *
         * @param render   A render whose sprite is being generated.
         * @param key   The key under which the sprite is stored.
         * @param attributes   Any additional information to pass to the sprite
         *                     generation process.
         */
        PixelRendr.prototype.generateRenderSprite = function (render, key, attributes) {
            var sprite;
            if (render.source.constructor === String) {
                sprite = this.generateSpriteSingleFromRender(render, key, attributes);
            }
            else {
                sprite = this.commandGenerators[render.source[0]](render, key, attributes);
            }
            render.sprites[key] = sprite;
        };
        /**
         * Generates the pixel data for a single sprite.
         *
         * @param render   A render whose sprite is being generated.
         * @param key   The key under which the sprite is stored.
         * @param attributes   Any additional information to pass to the sprite generation
         *                     process.
         * @returns   The output sprite.
         */
        PixelRendr.prototype.generateSpriteSingleFromRender = function (render, key, attributes) {
            var base = this.ProcessorBase.process(render.source, key, render.filter), sprite = this.ProcessorDims.process(base, key, attributes);
            return sprite;
        };
        /**
         * Generates the pixel data for a SpriteMultiple to be generated by creating
         * a container in a new SpriteMultiple and filing it with processed single
         * sprites.
         *
         * @param render   A render whose sprite is being generated.
         * @param key   The key under which the sprite is stored.
         * @param attributes   Any additional information to pass to the sprite generation
         *                     process.
         * @returns The output sprite.
         */
        PixelRendr.prototype.generateSpriteCommandMultipleFromRender = function (render, key, attributes) {
            var sources = render.source[2], sprites = {}, sprite, path, output = new PixelRendr_1.SpriteMultiple(sprites, render), i;
            for (i in sources) {
                if (sources.hasOwnProperty(i)) {
                    path = key + " " + i;
                    sprite = this.ProcessorBase.process(sources[i], path, render.filter);
                    sprites[i] = this.ProcessorDims.process(sprite, path, attributes);
                }
            }
            return output;
        };
        /**
         * Generates the output of a "same" command. The referenced Render or
         * directory are found, assigned to the old Render's directory, and
         * this.decode is used to find the output.
         *
         * @param render   A render whose sprite is being generated.
         * @param key   The key under which the sprite is stored.
         * @param attributes   Any additional information to pass to the
         *                              sprite generation process.
         * @returns The output sprite.
         */
        PixelRendr.prototype.generateSpriteCommandSameFromRender = function (render, key, attributes) {
            var replacement = this.followPath(this.library.sprites, render.source[1], 0);
            // The (now temporary) Render's containers are given the Render or directory
            // referenced by the source path
            this.replaceRenderInContainers(render, replacement);
            // BaseFiler will need to remember the new entry for the key,
            // so the cache is cleared and decode restarted
            this.BaseFiler.clearCached(key);
            return this.decode(key, attributes);
        };
        /**
         * Generates the output of a "filter" command. The referenced Render or
         * directory are found, converted into a filtered Render or directory, and
         * this.decode is used to find the output.
         *
         * @param render   A render whose sprite is being generated.
         * @param key   The key under which the sprite is stored.
         * @param attributes   Any additional information to pass to the sprite generation
         *                     process.
         * @returns The output sprite.
         */
        PixelRendr.prototype.generateSpriteCommandFilterFromRender = function (render, key, attributes) {
            var filter = this.filters[render.source[2]], found = this.followPath(this.library.sprites, render.source[1], 0), filtered;
            if (!filter) {
                console.warn("Invalid filter provided: " + render.source[2]);
            }
            // If found is a Render, create a new one as a filtered copy
            if (found.constructor === PixelRendr_1.Render) {
                filtered = new PixelRendr_1.Render(found.source, { filter: filter });
                this.generateRenderSprite(filtered, key, attributes);
            }
            else {
                // Otherwise it's an IRenderLibrary; go through that recursively
                filtered = this.generateRendersFromFilter(found, filter);
            }
            // The (now unused) render gives the filtered Render or directory to its containers
            this.replaceRenderInContainers(render, filtered);
            if (filtered.constructor === PixelRendr_1.Render) {
                return filtered.sprites[key];
            }
            else {
                this.BaseFiler.clearCached(key);
                return this.decode(key, attributes);
            }
        };
        /**
         * Recursively generates a directory of Renders from a filter. This is
         * similar to this.libraryParse, though the filter is added and references
         * aren't.
         *
         * @param directory   The current directory of Renders to create filtered versions
         *                    of.
         * @param filter   The filter being applied.
         * @returns An output directory containing Renders with the filter.
         */
        PixelRendr.prototype.generateRendersFromFilter = function (directory, filter) {
            var output = {}, child, i;
            for (i in directory) {
                if (!directory.hasOwnProperty(i)) {
                    continue;
                }
                child = directory[i];
                if (child.constructor === PixelRendr_1.Render) {
                    output[i] = new PixelRendr_1.Render(child.source, {
                        "filter": filter
                    });
                }
                else {
                    output[i] = this.generateRendersFromFilter(child, filter);
                }
            }
            return output;
        };
        /**
         * Switches all of a given Render's containers to point to a replacement instead.
         *
         * @param render   A Render being replaced.
         * @param replacement   A replacement for render.
         */
        PixelRendr.prototype.replaceRenderInContainers = function (render, replacement) {
            var listing, i;
            for (i = 0; i < render.containers.length; i += 1) {
                listing = render.containers[i];
                listing.container[listing.key] = replacement;
                if (replacement.constructor === PixelRendr_1.Render) {
                    replacement.containers.push(listing);
                }
            }
        };
        /* Core pipeline functions
        */
        /**
         * Given a compressed raw sprite data string, this 'unravels' it. This is
         * the first Function called in the base processor. It could output the
         * Uint8ClampedArray immediately if given the area - deliberately does not
         * to simplify sprite library storage.
         *
         * @param colors   The raw sprite String, including commands like "p" and "x".
         * @returns A version of the sprite with fancy commands replaced by numbers.
         */
        PixelRendr.prototype.spriteUnravel = function (colors) {
            var paletteref = this.getPaletteReferenceStarting(this.paletteDefault), digitsize = this.digitsizeDefault, clength = colors.length, current, rep, nixloc, output = "", loc = 0;
            while (loc < clength) {
                switch (colors[loc]) {
                    // A loop, ordered as 'x char times ,'
                    case "x":
                        // Get the location of the ending comma
                        nixloc = colors.indexOf(",", ++loc);
                        // Get the color
                        current = this.makeDigit(paletteref[colors.slice(loc, loc += digitsize)], this.digitsizeDefault);
                        // Get the rep times
                        rep = Number(colors.slice(loc, nixloc));
                        // Add that int to output, rep many times
                        while (rep--) {
                            output += current;
                        }
                        loc = nixloc + 1;
                        break;
                    // A palette changer, in the form 'p[X,Y,Z...]' (or "p" for default)
                    case "p":
                        // If the next character is a "[", customize.
                        if (colors[++loc] === "[") {
                            nixloc = colors.indexOf("]");
                            // Isolate and split the new palette's numbers
                            paletteref = this.getPaletteReference(colors.slice(loc + 1, nixloc).split(","));
                            loc = nixloc + 1;
                            digitsize = this.getDigitSizeFromObject(paletteref);
                        }
                        else {
                            // Otherwise go back to default
                            paletteref = this.getPaletteReference(this.paletteDefault);
                            digitsize = this.digitsizeDefault;
                        }
                        break;
                    // A typical number
                    default:
                        output += this.makeDigit(paletteref[colors.slice(loc, loc += digitsize)], this.digitsizeDefault);
                        break;
                }
            }
            return output;
        };
        /**
         * Repeats each number in the given string a number of times equal to the
         * scale. This is the second Function called by the base processor.
         *
         * @param colors   A series of sprite colors.
         * @returns   The same series, with each character repeated.
         */
        PixelRendr.prototype.spriteExpand = function (colors) {
            var output = "", clength = colors.length, i = 0, j, current;
            // For each number,
            while (i < clength) {
                current = colors.slice(i, i += this.digitsizeDefault);
                // Put it into output as many times as needed
                for (j = 0; j < this.scale; ++j) {
                    output += current;
                }
            }
            return output;
        };
        /**
         * Used during post-processing before spriteGetArray to filter colors. This
         * is the third Function used by the base processor, but it just returns the
         * original sprite if no filter should be applied from attributes.
         * Filters are applied here because the sprite is just the numbers repeated,
         * so it's easy to loop through and replace them.
         *
         * @param colors   A series of color characters.
         * @param key   The unique key identifying this chain of transforms.
         * @param attributes   Attributes describing the filter to use.
         * @returns The original series of color characters, filtered.
         */
        PixelRendr.prototype.spriteApplyFilter = function (colors, key, attributes) {
            // If there isn't a filter (as is the norm), just return the sprite
            if (!attributes || !attributes.filter) {
                return colors;
            }
            var filter = attributes.filter, filterName = filter[0];
            if (!filterName) {
                return colors;
            }
            switch (filterName) {
                // Palette filters switch all instances of one color with another
                case "palette":
                    // Split the colors on on each digit
                    // ("...1234..." => [..., "12", "34", ...]
                    var split = colors.match(this.digitsplit), i;
                    // For each color filter to be applied, replace it
                    for (i in filter[1]) {
                        if (filter[1].hasOwnProperty(i)) {
                            this.arrayReplace(split, i, filter[1][i]);
                        }
                    }
                    return split.join("");
                default:
                    console.warn("Unknown filter: '" + filterName + "'.");
            }
            return colors;
        };
        /**
         * Converts an unraveled String of sprite numbers to the equivalent RGBA
         * Uint8ClampedArray. Each colors number will be represented by four numbers
         * in the output. This is the fourth Function called in the base processor.
         *
         * @param colors   A series of color characters.
         * @returns A series of pixels equivalent to the colors.
         */
        PixelRendr.prototype.spriteGetArray = function (colors) {
            var clength = colors.length, numcolors = clength / this.digitsizeDefault, split = colors.match(this.digitsplit), olength = numcolors * 4, output = new this.Uint8ClampedArray(olength), reference, i, j, k;
            // For each color,
            for (i = 0, j = 0; i < numcolors; ++i) {
                // Grab its RGBA ints
                reference = this.paletteDefault[Number(split[i])];
                // Place each in output
                for (k = 0; k < 4; ++k) {
                    output[j + k] = reference[k];
                }
                j += 4;
            }
            return output;
        };
        /**
         * Repeats each row of a sprite based on the container attributes to create
         * the actual sprite (before now, the sprite was 1 / scale as high as it
         * should have been). This is the first Function called in the dimensions
         * processor.
         *
         * @param sprite   A series of sprite pixels.
         * @param key   The unique key identifying this chain of transforms.
         * @param attributes   The container Object (commonly a Thing in GameStarter),
         *                     which must contain width and height numbers.
         * @returns A version of the original sprite, with rows repeated.
         */
        PixelRendr.prototype.spriteRepeatRows = function (sprite, key, attributes) {
            var parsed = new this.Uint8ClampedArray(sprite.length * this.scale), rowsize = attributes[this.spriteWidth] * 4, height = attributes[this.spriteHeight] / this.scale, readloc = 0, writeloc = 0, i, j;
            // For each row:
            for (i = 0; i < height; ++i) {
                // Add it to parsed x scale
                for (j = 0; j < this.scale; ++j) {
                    this.memcpyU8(sprite, parsed, readloc, writeloc, rowsize);
                    writeloc += rowsize;
                }
                readloc += rowsize;
            }
            return parsed;
        };
        /**
         * Optionally flips a sprite based on the flipVert and flipHoriz keys. This
         * is the second Function in the dimensions processor and the last step
         * before a sprite is deemed usable.
         *
         * @param sprite   A series of sprite pixels.
         * @param key   The unique key identifying this chain of transforms.
         * @param attributes   The container Object (commonly a Thing in GameStarter),
         *                     which must contain width and height numbers.
         * @returns A version of the original sprite, with dimensions flipped.
         */
        PixelRendr.prototype.spriteFlipDimensions = function (sprite, key, attributes) {
            if (key.indexOf(this.flipHoriz) !== -1) {
                if (key.indexOf(this.flipVert) !== -1) {
                    return this.flipSpriteArrayBoth(sprite);
                }
                else {
                    return this.flipSpriteArrayHoriz(sprite, attributes);
                }
            }
            else if (key.indexOf(this.flipVert) !== -1) {
                return this.flipSpriteArrayVert(sprite, attributes);
            }
            return sprite;
        };
        /**
         * Flips a sprite horizontally by reversing the pixels within each row. Rows
         * are computing using the spriteWidth in attributes.
         *
         * @param sprite   A series of sprite pixels.
         * @param attributes   The container Object (commonly a Thing in GameStarter),
         *                     which must contain width and height numbers.
         * @returns A version of the original sprite, flipped horizontally.
         */
        PixelRendr.prototype.flipSpriteArrayHoriz = function (sprite, attributes) {
            var length = sprite.length + 0, width = attributes[this.spriteWidth] + 0, newsprite = new this.Uint8ClampedArray(length), rowsize = width * 4, newloc, oldloc, i, j, k;
            // For each row:
            for (i = 0; i < length; i += rowsize) {
                newloc = i;
                oldloc = i + rowsize - 4;
                // For each pixel:
                for (j = 0; j < rowsize; j += 4) {
                    // Copy it over
                    for (k = 0; k < 4; ++k) {
                        newsprite[newloc + k] = sprite[oldloc + k];
                    }
                    newloc += 4;
                    oldloc -= 4;
                }
            }
            return newsprite;
        };
        /**
         * Flips a sprite horizontally by reversing the order of the rows. Rows are
         * computing using the spriteWidth in attributes.
         *
         * @param sprite   A series of sprite pixels.
         * @param attributes   The container Object (commonly a Thing in GameStarter),
         *                     which must contain width and height numbers.
         * @returns A version of the original sprite, flipped vertically.
         */
        PixelRendr.prototype.flipSpriteArrayVert = function (sprite, attributes) {
            var length = sprite.length, width = attributes[this.spriteWidth] + 0, newsprite = new this.Uint8ClampedArray(length), rowsize = width * 4, newloc = 0, oldloc = length - rowsize, i, j;
            // For each row
            while (newloc < length) {
                // For each pixel in the rows
                for (i = 0; i < rowsize; i += 4) {
                    // For each rgba value
                    for (j = 0; j < 4; ++j) {
                        newsprite[newloc + i + j] = sprite[oldloc + i + j];
                    }
                }
                newloc += rowsize;
                oldloc -= rowsize;
            }
            return newsprite;
        };
        /**
         * Flips a sprite horizontally and vertically by reversing the order of the
         * pixels. This doesn't actually need attributes.
         *
         * @param sprite   A series of sprite pixels.
         * @param attributes   The container Object (commonly a Thing in GameStarter),
         *                     which must contain width and height numbers.
         * @returns A version of the original sprite, flipped horizontally and vertically.
         */
        PixelRendr.prototype.flipSpriteArrayBoth = function (sprite) {
            var length = sprite.length, newsprite = new this.Uint8ClampedArray(length), oldloc = sprite.length - 4, newloc = 0, i;
            while (newloc < length) {
                for (i = 0; i < 4; ++i) {
                    newsprite[newloc + i] = sprite[oldloc + i];
                }
                newloc += 4;
                oldloc -= 4;
            }
            return newsprite;
        };
        /* Encoding pipeline functions
        */
        /**
         * Retrives the raw pixel data from an image element. It is copied onto a
         * canvas, which as its context return the .getImageDate().data results.
         * This is the first Fiunction used in the encoding processor.
         *
         * @param image   An image whose data is to be retrieved.
         */
        PixelRendr.prototype.imageGetData = function (image) {
            var canvas = document.createElement("canvas"), context = canvas.getContext("2d");
            canvas.width = image.width;
            canvas.height = image.height;
            context.drawImage(image, 0, 0);
            return context.getImageData(0, 0, image.width, image.height).data;
        };
        /**
         * Determines which pixels occur in the data and at what frequency. This is
         * the second Function used in the encoding processor.
         *
         * @param data   The raw pixel data obtained from the imageData of a canvas.
         * @returns [pixels, occurences], where pixels is an array of [rgba] values
         *          and occurences is an Object mapping occurence frequencies of
         *          palette colors in pisels.
         */
        PixelRendr.prototype.imageGetPixels = function (data) {
            var pixels = new Array(data.length / 4), occurences = {}, pixel, i, j;
            for (i = 0, j = 0; i < data.length; i += 4, j += 1) {
                pixel = this.getClosestInPalette(this.paletteDefault, data.subarray(i, i + 4));
                pixels[j] = pixel;
                if (occurences.hasOwnProperty(pixel)) {
                    occurences[pixel] += 1;
                }
                else {
                    occurences[pixel] = 1;
                }
            }
            return [pixels, occurences];
        };
        /**
         * Concretely defines the palette to be used for a new sprite. This is the
         * third Function used in the encoding processor, and creates a technically
         * usable (but uncompressed) sprite with information to compress it.
         *
         * @param information   [pixels, occurences], a result directly from imageGetPixels.
         * @returns [palette, numbers, digitsize], where palette is a String[] of palette
         *          numbers, numbers is the actual sprite data, and digitsize is the sprite's
         *          digit size.
         */
        PixelRendr.prototype.imageMapPalette = function (information) {
            var pixels = information[0], occurences = information[1], palette = Object.keys(occurences), digitsize = this.getDigitSizeFromArray(palette), paletteIndices = this.getValueIndices(palette), numbers = pixels.map(function (pixel) { return paletteIndices[pixel]; });
            return [palette, numbers, digitsize];
        };
        /**
         * Compresses a nearly complete sprite from imageMapPalette into a
         * compressed, storage-ready String. This is the last Function in the
         * encoding processor.
         *
         * @param information   [palette, numbers, digitsize], a result directly from
         *                      imageMapPalette.
         * @returns The pixels from information, combined.
         */
        PixelRendr.prototype.imageCombinePixels = function (information) {
            var palette = information[0], numbers = information[1], digitsize = information[2], threshold = Math.max(3, Math.round(4 / digitsize)), output, current, digit, i = 0, j;
            output = "p[" + palette.map(this.makeSizedDigit.bind(this, digitsize)).join(",") + "]";
            while (i < numbers.length) {
                j = i + 1;
                current = numbers[i];
                digit = this.makeDigit(current, digitsize);
                while (current === numbers[j]) {
                    j += 1;
                }
                if (j - i > threshold) {
                    output += "x" + digit + String(j - i) + ",";
                    i = j;
                }
                else {
                    do {
                        output += digit;
                        i += 1;
                    } while (i < j);
                }
            }
            return output;
        };
        /* Misc. utility functions
        */
        /**
         * Determines how many digits will be required to represent a member of
         * the palette.
         *
         * @param palette   A palette of colors.
         * @returns The equivalent digitsize for the palette.
         */
        PixelRendr.prototype.getDigitSizeFromArray = function (palette) {
            var digitsize = 0, i;
            for (i = palette.length; i >= 1; i /= 10) {
                digitsize += 1;
            }
            return digitsize;
        };
        /**
         * Determines how many digits will be required to represent a member of
         * the palette.
         *
         * @param palette   A palette of colors.
         * @returns The equivalent digitsize for the palette.
         */
        PixelRendr.prototype.getDigitSizeFromObject = function (palette) {
            return this.getDigitSizeFromArray(Object.keys(palette));
        };
        /**
         * Generates an actual palette Object for a given palette, using a digitsize
         * calculated from the palette.
         *
         * @param palette   A palette of colors
         * @returns The actual palette Object for the given palette, with an index
         *          for every palette member.
         */
        PixelRendr.prototype.getPaletteReference = function (palette) {
            var output = {}, digitsize = this.getDigitSizeFromArray(palette), i;
            for (i = 0; i < palette.length; i += 1) {
                output[this.makeDigit(i, digitsize)] = this.makeDigit(palette[i], digitsize);
            }
            return output;
        };
        /**
         * Generates an actual palette Object for a given palette, using the default
         * digitsize.
         *
         * @param palette   A palette of colors.
         * @returns The actual palette Object for the given palette, with an index
         *          for every palette member.
         */
        PixelRendr.prototype.getPaletteReferenceStarting = function (palette) {
            var output = {}, digit, i;
            for (i = 0; i < palette.length; i += 1) {
                digit = this.makeDigit(i, this.digitsizeDefault);
                output[digit] = digit;
            }
            return output;
        };
        /**
         * Finds which rgba value in a palette is closest to a given value. This is
         * useful for determining which color in a pre-existing palette matches up
         * with a raw image's pixel. This is determined by which palette color has
         * the lowest total difference in integer values between r, g, b, and a.
         *
         * @param palette   The palette of pre-existing colors.
         * @param rgba   The RGBA values being assigned, as Numbers in [0, 255].
         * @returns The closest matching color index.
         */
        PixelRendr.prototype.getClosestInPalette = function (palette, rgba) {
            var bestDifference = Infinity, difference, bestIndex, i;
            for (i = palette.length - 1; i >= 0; i -= 1) {
                difference = this.arrayDifference(palette[i], rgba);
                if (difference < bestDifference) {
                    bestDifference = difference;
                    bestIndex = i;
                }
            }
            return bestIndex;
        };
        /**
         * Creates a new String equivalent to an old String repeated any number of
         * times. If times is 0, a blank String is returned.
         *
         * @param string   The characters to repeat.
         * @param times   How many times to repeat (by default, 1).
         * @returns The original string, repeated.
         */
        PixelRendr.prototype.stringOf = function (string, times) {
            return (times === 0) ? "" : new Array(1 + (times || 1)).join(string);
        };
        /**
         * Turns a Number into a String with a prefix added to pad it to a certain
         * number of digits.
         *
         * @param number   The original Number being padded.
         * @param size   How many digits the output must contain.
         * @param prefix   A prefix to repeat for padding (by default, "0").
         * @returns A Stringified digit of the given length.
         * @example makeDigit(7, 3); // '007'
         * @example makeDigit(7, 3, 1); // '117'
         */
        PixelRendr.prototype.makeDigit = function (num, size, prefix) {
            if (prefix === void 0) { prefix = "0"; }
            return this.stringOf(prefix, Math.max(0, size - String(num).length)) + num;
        };
        /**
         * Curry wrapper around makeDigit that reverses size and number argument
         * order. Useful for binding makeDigit.
         *
         * @param number   The original Number being padded.
         * @param size   How many digits the output must contain.
         * @returns A stringified digit of the given length.
         */
        PixelRendr.prototype.makeSizedDigit = function (size, number) {
            return this.makeDigit(number, size, "0");
        };
        /**
         * Replaces all instances of an element in an Array.
         *
         * @param array   The original elements.
         * @param removed   The element to remove.
         * @param inserted   The element to insert.
         * @returns The original Array, with the element replaced.
         */
        PixelRendr.prototype.arrayReplace = function (array, removed, inserted) {
            for (var i = 0; i < array.length; i += 1) {
                if (array[i] === removed) {
                    array[i] = inserted;
                }
            }
            return array;
        };
        /**
         * Computes the sum of the differences of elements between two Arrays of
         * equal length.
         *
         * @param a   An Array of Numbers.
         * @param b   An Array of Numbers.
         * @returns The sum of differences between a and b.
         */
        PixelRendr.prototype.arrayDifference = function (a, b) {
            var sum = 0, i;
            for (i = a.length - 1; i >= 0; i -= 1) {
                sum += Math.abs(a[i] - b[i]) | 0;
            }
            return sum;
        };
        /**
         * Converts an Array to an Object mapping values to indices.
         *
         * @param array   An Array to convert.
         * @returns An Object with an index equal to each element of the Array.
         */
        PixelRendr.prototype.getValueIndices = function (array) {
            var output = {}, i;
            for (i = 0; i < array.length; i += 1) {
                output[array[i]] = i;
            }
            return output;
        };
        /**
         * Follows a path inside an Object recursively, based on a given path.
         *
         * @param object   An Object to delve within.
         * @param path   The ordered names of attributes to descend into.
         * @param index   The starting index in path.
         * @returns A found element within object.
         */
        PixelRendr.prototype.followPath = function (object, path, index) {
            if (index < path.length && object.hasOwnProperty(path[index])) {
                return this.followPath(object[path[index]], path, index + 1);
            }
            return object;
        };
        return PixelRendr;
    })();
    PixelRendr_1.PixelRendr = PixelRendr;
})(PixelRendr || (PixelRendr = {}));
/// <reference path="ObjectMakr-0.2.2.ts" />
var QuadsKeepr;
(function (QuadsKeepr_1) {
    "use strict";
    /**
     * Quadrant-based collision detection. A grid structure of Quadrants is kept,
     * with Things placed within quadrants they intersect. Operations are available
     * to shift quadrants horizontally or vertically and add/remove rows and columns.
     */
    var QuadsKeepr = (function () {
        /**
         * @param {IQuadsKeeprSettings} settings
         */
        function QuadsKeepr(settings) {
            if (!settings) {
                throw new Error("No settings object given to QuadsKeepr.");
            }
            if (!settings.ObjectMaker) {
                throw new Error("No ObjectMaker given to QuadsKeepr.");
            }
            if (!settings.numRows) {
                throw new Error("No numRows given to QuadsKeepr.");
            }
            if (!settings.numCols) {
                throw new Error("No numCols given to QuadsKeepr.");
            }
            if (!settings.quadrantWidth) {
                throw new Error("No quadrantWidth given to QuadsKeepr.");
            }
            if (!settings.quadrantHeight) {
                throw new Error("No quadrantHeight given to QuadsKeepr.");
            }
            if (!settings.groupNames) {
                throw new Error("No groupNames given to QuadsKeepr.");
            }
            this.ObjectMaker = settings.ObjectMaker;
            this.numRows = settings.numRows | 0;
            this.numCols = settings.numCols | 0;
            this.quadrantWidth = settings.quadrantWidth | 0;
            this.quadrantHeight = settings.quadrantHeight | 0;
            this.groupNames = settings.groupNames;
            this.onAdd = settings.onAdd;
            this.onRemove = settings.onRemove;
            this.startLeft = settings.startLeft | 0;
            this.startTop = settings.startTop | 0;
            this.keyTop = settings.keyTop || "top";
            this.keyLeft = settings.keyLeft || "left";
            this.keyBottom = settings.keyBottom || "bottom";
            this.keyRight = settings.keyRight || "right";
            this.keyNumQuads = settings.keyNumQuads || "numquads";
            this.keyQuadrants = settings.keyQuadrants || "quadrants";
            this.keyChanged = settings.keyChanged || "changed";
            this.keyToleranceX = settings.keyToleranceX || "tolx";
            this.keyToleranceY = settings.keyToleranceY || "toly";
            this.keyGroupName = settings.keyGroupName || "group";
            this.keyOffsetX = settings.keyOffsetX;
            this.keyOffsetY = settings.keyOffsetY;
        }
        /* Simple gets
        */
        /**
         * @returns The listing of Quadrants grouped by row.
         */
        QuadsKeepr.prototype.getQuadrantRows = function () {
            return this.quadrantRows;
        };
        /**
         * @returns The listing of Quadrants grouped by column.
         */
        QuadsKeepr.prototype.getQuadrantCols = function () {
            return this.quadrantCols;
        };
        /**
         * @returns How many Quadrant rows there are.
         */
        QuadsKeepr.prototype.getNumRows = function () {
            return this.numRows;
        };
        /**
         * @returns How many Quadrant columns there are.
         */
        QuadsKeepr.prototype.getNumCols = function () {
            return this.numCols;
        };
        /**
         * @returns How wide each Quadrant is.
         */
        QuadsKeepr.prototype.getQuadrantWidth = function () {
            return this.quadrantWidth;
        };
        /**
         * @returns How high each Quadrant is.
         */
        QuadsKeepr.prototype.getQuadrantHeight = function () {
            return this.quadrantHeight;
        };
        /* Quadrant updates
        */
        /**
         * Completely resets all Quadrants. The grid structure of rows and columns
         * is remade with new Quadrants according to startLeft and startTop.
         */
        QuadsKeepr.prototype.resetQuadrants = function () {
            var left = this.startLeft, top = this.startTop, quadrant, i, j;
            this.top = this.startTop;
            this.right = this.startLeft + this.quadrantWidth * this.numCols;
            this.bottom = this.startTop + this.quadrantHeight * this.numRows;
            this.left = this.startLeft;
            this.quadrantRows = [];
            this.quadrantCols = [];
            this.offsetX = 0;
            this.offsetY = 0;
            for (i = 0; i < this.numRows; i += 1) {
                this.quadrantRows.push({
                    "left": this.startLeft,
                    "top": top,
                    "quadrants": []
                });
                top += this.quadrantHeight;
            }
            for (j = 0; j < this.numCols; j += 1) {
                this.quadrantCols.push({
                    "left": left,
                    "top": this.startTop,
                    "quadrants": []
                });
                left += this.quadrantWidth;
            }
            top = this.startTop;
            for (i = 0; i < this.numRows; i += 1) {
                left = this.startLeft;
                for (j = 0; j < this.numCols; j += 1) {
                    quadrant = this.createQuadrant(left, top);
                    this.quadrantRows[i].quadrants.push(quadrant);
                    this.quadrantCols[j].quadrants.push(quadrant);
                    left += this.quadrantWidth;
                }
                top += this.quadrantHeight;
            }
            if (this.onAdd) {
                this.onAdd("xInc", this.top, this.right, this.bottom, this.left);
            }
        };
        /**
         * Shifts each Quadrant horizontally and vertically, along with the row and
         * column containers. Offsets are adjusted to check for row or column
         * deletion and insertion.
         *
         * @param dx   How much to shift horizontally (will be rounded).
         * @param dy   How much to shift vertically (will be rounded).
         */
        QuadsKeepr.prototype.shiftQuadrants = function (dx, dy) {
            if (dx === void 0) { dx = 0; }
            if (dy === void 0) { dy = 0; }
            var row, col;
            dx = dx | 0;
            dy = dy | 0;
            this.offsetX += dx;
            this.offsetY += dy;
            this.top += dy;
            this.right += dx;
            this.bottom += dy;
            this.left += dx;
            for (row = 0; row < this.numRows; row += 1) {
                this.quadrantRows[row].left += dx;
                this.quadrantRows[row].top += dy;
            }
            for (col = 0; col < this.numCols; col += 1) {
                this.quadrantCols[col].left += dx;
                this.quadrantCols[col].top += dy;
            }
            for (row = 0; row < this.numRows; row += 1) {
                for (col = 0; col < this.numCols; col += 1) {
                    this.shiftQuadrant(this.quadrantRows[row].quadrants[col], dx, dy);
                }
            }
            this.adjustOffsets();
        };
        /**
         * Adds a QuadrantRow to the end of the quadrantRows Array.
         *
         * @param callUpdate   Whether this should call the onAdd trigger
         *                     with the new row's bounding box.
         * @returns The newly created QuadrantRow.
         */
        QuadsKeepr.prototype.pushQuadrantRow = function (callUpdate) {
            var row = this.createQuadrantRow(this.left, this.bottom), i;
            this.numRows += 1;
            this.quadrantRows.push(row);
            for (i = 0; i < this.quadrantCols.length; i += 1) {
                this.quadrantCols[i].quadrants.push(row.quadrants[i]);
            }
            this.bottom += this.quadrantHeight;
            if (callUpdate && this.onAdd) {
                this.onAdd("yInc", this.bottom, this.right, this.bottom - this.quadrantHeight, this.left);
            }
            return row;
        };
        /**
         * Adds a QuadrantCol to the end of the quadrantCols Array.
         *
         * @param callUpdate   Whether this should call the onAdd trigger
         *                     with the new col's bounding box.
         * @returns The newly created QuadrantCol.
         */
        QuadsKeepr.prototype.pushQuadrantCol = function (callUpdate) {
            var col = this.createQuadrantCol(this.right, this.top), i;
            this.numCols += 1;
            this.quadrantCols.push(col);
            for (i = 0; i < this.quadrantRows.length; i += 1) {
                this.quadrantRows[i].quadrants.push(col.quadrants[i]);
            }
            this.right += this.quadrantWidth;
            if (callUpdate && this.onAdd) {
                this.onAdd("xInc", this.top, this.right - this.offsetY, this.bottom, this.right - this.quadrantWidth - this.offsetY);
            }
            return col;
        };
        /**
         * Removes the last QuadrantRow from the end of the quadrantRows Array.
         *
         * @param callUpdate   Whether this should call the onRemove trigger
         *                     with the new row's bounding box.
         * @returns The newly created QuadrantRow.
         */
        QuadsKeepr.prototype.popQuadrantRow = function (callUpdate) {
            for (var i = 0; i < this.quadrantCols.length; i += 1) {
                this.quadrantCols[i].quadrants.pop();
            }
            this.numRows -= 1;
            this.quadrantRows.pop();
            if (callUpdate && this.onRemove) {
                this.onRemove("yInc", this.bottom, this.right, this.bottom - this.quadrantHeight, this.left);
            }
            this.bottom -= this.quadrantHeight;
        };
        /**
         * Removes the last QuadrantCol from the end of the quadrantCols Array.
         *
         * @param callUpdate   Whether this should call the onRemove trigger
         *                     with the new row's bounding box.
         */
        QuadsKeepr.prototype.popQuadrantCol = function (callUpdate) {
            for (var i = 0; i < this.quadrantRows.length; i += 1) {
                this.quadrantRows[i].quadrants.pop();
            }
            this.numCols -= 1;
            this.quadrantCols.pop();
            if (callUpdate && this.onRemove) {
                this.onRemove("xDec", this.top, this.right - this.offsetY, this.bottom, this.right - this.quadrantWidth - this.offsetY);
            }
            this.right -= this.quadrantWidth;
        };
        /**
         * Adds a QuadrantRow to the beginning of the quadrantRows Array.
         *
         * @param callUpdate   Whether this should call the onAdd trigger
         *                     with the new row's bounding box.
         * @returns The newly created QuadrantRow.
         */
        QuadsKeepr.prototype.unshiftQuadrantRow = function (callUpdate) {
            var row = this.createQuadrantRow(this.left, this.top - this.quadrantHeight), i;
            this.numRows += 1;
            this.quadrantRows.unshift(row);
            for (i = 0; i < this.quadrantCols.length; i += 1) {
                this.quadrantCols[i].quadrants.unshift(row.quadrants[i]);
            }
            this.top -= this.quadrantHeight;
            if (callUpdate && this.onAdd) {
                this.onAdd("yDec", this.top, this.right, this.top + this.quadrantHeight, this.left);
            }
            return row;
        };
        /**
         * Adds a QuadrantCol to the beginning of the quadrantCols Array.
         *
         * @param callUpdate   Whether this should call the onAdd trigger
         *                     with the new row's bounding box.
         * @returns The newly created QuadrantCol.
         */
        QuadsKeepr.prototype.unshiftQuadrantCol = function (callUpdate) {
            var col = this.createQuadrantCol(this.left - this.quadrantWidth, this.top), i;
            this.numCols += 1;
            this.quadrantCols.unshift(col);
            for (i = 0; i < this.quadrantRows.length; i += 1) {
                this.quadrantRows[i].quadrants.unshift(col.quadrants[i]);
            }
            this.left -= this.quadrantWidth;
            if (callUpdate && this.onAdd) {
                this.onAdd("xDec", this.top, this.left, this.bottom, this.left + this.quadrantWidth);
            }
            return col;
        };
        /**
         * Removes a QuadrantRow from the beginning of the quadrantRows Array.
         *
         * @param callUpdate   Whether this should call the onAdd trigger
         *                     with the new row's bounding box.
         */
        QuadsKeepr.prototype.shiftQuadrantRow = function (callUpdate) {
            for (var i = 0; i < this.quadrantCols.length; i += 1) {
                this.quadrantCols[i].quadrants.shift();
            }
            this.numRows -= 1;
            this.quadrantRows.pop();
            if (callUpdate && this.onRemove) {
                this.onRemove("yInc", this.top, this.right, this.top + this.quadrantHeight, this.left);
            }
            this.top += this.quadrantHeight;
        };
        /**
         * Removes a QuadrantCol from the beginning of the quadrantCols Array.
         *
         * @param callUpdate   Whether this should call the onAdd trigger
         *                     with the new row's bounding box.
         */
        QuadsKeepr.prototype.shiftQuadrantCol = function (callUpdate) {
            for (var i = 0; i < this.quadrantRows.length; i += 1) {
                this.quadrantRows[i].quadrants.shift();
            }
            this.numCols -= 1;
            this.quadrantCols.pop();
            if (callUpdate && this.onRemove) {
                this.onRemove("xInc", this.top, this.left + this.quadrantWidth, this.bottom, this.left);
            }
            this.left += this.quadrantWidth;
        };
        /* Thing manipulations
        */
        /**
         * Determines the Quadrants for an entire Array of Things. This is done by
         * wiping each quadrant's memory of that Array's group type and determining
         * each Thing's quadrants.
         *
         * @param group   The name of the group to have Quadrants determined.
         * @param things   The listing of Things in that group.
         */
        QuadsKeepr.prototype.determineAllQuadrants = function (group, things) {
            var row, col;
            for (row = 0; row < this.numRows; row += 1) {
                for (col = 0; col < this.numCols; col += 1) {
                    this.quadrantRows[row].quadrants[col].numthings[group] = 0;
                }
            }
            things.forEach(this.determineThingQuadrants.bind(this));
        };
        /**
         * Determines the Quadrants for a single Thing. The starting row and column
         * indices are calculated so every Quadrant within them should contain the
         * Thing. In the process, its old Quadrants and new Quadrants are marked as
         * changed if it was.
         *
         * @param thing   A Thing whose Quadrants are to be determined.
         */
        QuadsKeepr.prototype.determineThingQuadrants = function (thing) {
            var group = thing[this.keyGroupName], rowStart = this.findQuadrantRowStart(thing), colStart = this.findQuadrantColStart(thing), rowEnd = this.findQuadrantRowEnd(thing), colEnd = this.findQuadrantColEnd(thing), row, col;
            // Mark each of the Thing's Quadrants as changed
            // This is done first because the old Quadrants are changed
            if (thing[this.keyChanged]) {
                this.markThingQuadrantsChanged(thing);
            }
            // The Thing no longer has any Quadrants: rebuild them!
            thing[this.keyNumQuads] = 0;
            for (row = rowStart; row <= rowEnd; row += 1) {
                for (col = colStart; col <= colEnd; col += 1) {
                    this.setThingInQuadrant(thing, this.quadrantRows[row].quadrants[col], group);
                }
            }
            // The thing is no longer considered changed, since quadrants know it
            thing[this.keyChanged] = false;
        };
        /**
         * Sets a Thing to be inside a Quadrant. The two are marked so they can
         * recognize each other's existence later.
         *
         * @param thing   A Thing to be placed in the Quadrant.
         * @param quadrant   A Quadrant that now contains the Thing.
         * @param group   The grouping under which the Quadrant should store the
         *                Thing.
         */
        QuadsKeepr.prototype.setThingInQuadrant = function (thing, quadrant, group) {
            // Mark the Quadrant in the Thing
            thing[this.keyQuadrants][thing[this.keyNumQuads]] = quadrant;
            thing[this.keyNumQuads] += 1;
            // Mark the Thing in the Quadrant
            quadrant.things[group][quadrant.numthings[group]] = thing;
            quadrant.numthings[group] += 1;
            // If necessary, mark the Quadrant as changed
            if (thing[this.keyChanged]) {
                quadrant[this.keyChanged] = true;
            }
        };
        /* Internal rearranging
        */
        /**
         * Adjusts the offset measurements by checking if rows or columns have gone
         * over the limit, which requires rows or columns be removed and new ones
         * added.
         */
        QuadsKeepr.prototype.adjustOffsets = function () {
            // Quadrant shift: add to the right
            while (-this.offsetX > this.quadrantWidth) {
                this.shiftQuadrantCol(true);
                this.pushQuadrantCol(true);
                this.offsetX += this.quadrantWidth;
            }
            // Quadrant shift: add to the left
            while (this.offsetX > this.quadrantWidth) {
                this.popQuadrantCol(true);
                this.unshiftQuadrantCol(true);
                this.offsetX -= this.quadrantWidth;
            }
            // Quadrant shift: add to the bottom
            while (-this.offsetY > this.quadrantHeight) {
                this.unshiftQuadrantRow(true);
                this.pushQuadrantRow(true);
                this.offsetY += this.quadrantHeight;
            }
            // Quadrant shift: add to the top
            while (this.offsetY > this.quadrantHeight) {
                this.popQuadrantRow(true);
                this.unshiftQuadrantRow(true);
                this.offsetY -= this.quadrantHeight;
            }
        };
        /**
         * Shifts a Quadrant horizontally and vertically.
         *
         * @param dx   How much to shift horizontally.
         * @param dy   How much to shift vertically.
         */
        QuadsKeepr.prototype.shiftQuadrant = function (quadrant, dx, dy) {
            quadrant.top += dy;
            quadrant.right += dx;
            quadrant.bottom += dy;
            quadrant.left += dx;
            quadrant[this.keyChanged] = true;
        };
        /* Quadrant placements
        */
        /**
         * Creates a new Quadrant using the internal ObjectMaker and sets its position.
         *
         * @param left   The horizontal displacement of the Quadrant.
         * @param top   The vertical displacement of the Quadrant.
         * @returns The newly created Quadrant.
         */
        QuadsKeepr.prototype.createQuadrant = function (left, top) {
            var quadrant = this.ObjectMaker.make("Quadrant"), i;
            quadrant[this.keyChanged] = true;
            quadrant.things = {};
            quadrant.numthings = {};
            for (i = 0; i < this.groupNames.length; i += 1) {
                quadrant.things[this.groupNames[i]] = [];
                quadrant.numthings[this.groupNames[i]] = 0;
            }
            quadrant.left = left;
            quadrant.top = top;
            quadrant.right = left + this.quadrantWidth;
            quadrant.bottom = top + this.quadrantHeight;
            return quadrant;
        };
        /**
         * Creates a QuadrantRow, with length determined by numCols.
         *
         * @param left   The initial horizontal displacement of the col.
         * @param top   The vertical displacement of the col.
         * @returns The newly created QuadrantRow.
         */
        QuadsKeepr.prototype.createQuadrantRow = function (left, top) {
            if (left === void 0) { left = 0; }
            if (top === void 0) { top = 0; }
            var row = {
                "left": left,
                "top": top,
                "quadrants": []
            }, i;
            for (i = 0; i < this.numCols; i += 1) {
                row.quadrants.push(this.createQuadrant(left, top));
                left += this.quadrantWidth;
            }
            return row;
        };
        /**
         * Creates a QuadrantCol, with length determined by numRows.
         *
         * @param left   The horizontal displacement of the col.
         * @param top   The initial vertical displacement of the col.
         * @returns The newly created QuadrantCol.
         */
        QuadsKeepr.prototype.createQuadrantCol = function (left, top) {
            var col = {
                "left": left,
                "top": top,
                "quadrants": []
            }, i;
            for (i = 0; i < this.numRows; i += 1) {
                col.quadrants.push(this.createQuadrant(left, top));
                top += this.quadrantHeight;
            }
            return col;
        };
        /* Position utilities
        */
        /**
         * @param thing   A Thing to check the bounding box of.
         * @returns The Thing's top position, accounting for vertical offset
         *          if needed.
         */
        QuadsKeepr.prototype.getTop = function (thing) {
            if (this.keyOffsetY) {
                return thing[this.keyTop] - Math.abs(thing[this.keyOffsetY]);
            }
            else {
                return thing[this.keyTop];
            }
        };
        /**
         * @param thing   A Thing to check the bounding box of.
         * @returns The Thing's right position, accounting for horizontal offset
         *          if needed.
         */
        QuadsKeepr.prototype.getRight = function (thing) {
            if (this.keyOffsetX) {
                return thing[this.keyRight] + Math.abs(thing[this.keyOffsetX]);
            }
            else {
                return thing[this.keyRight];
            }
        };
        /**
         * @param thing   A Thing to check the bounding box of.
         * @returns The Thing's bottom position, accounting for vertical
         *          offset if needed.
         */
        QuadsKeepr.prototype.getBottom = function (thing) {
            if (this.keyOffsetX) {
                return thing[this.keyBottom] + Math.abs(thing[this.keyOffsetY]);
            }
            else {
                return thing[this.keyBottom];
            }
        };
        /**
         * @param thing   A Thing to check the bounding box of.
         * @returns The Thing's left position, accounting for horizontal offset
         *          if needed.
         */
        QuadsKeepr.prototype.getLeft = function (thing) {
            if (this.keyOffsetX) {
                return thing[this.keyLeft] - Math.abs(thing[this.keyOffsetX]);
            }
            else {
                return thing[this.keyLeft];
            }
        };
        /**
         * Marks all Quadrants a Thing is contained within as changed.
         */
        QuadsKeepr.prototype.markThingQuadrantsChanged = function (thing) {
            for (var i = 0; i < thing[this.keyNumQuads]; i += 1) {
                thing[this.keyQuadrants][i][this.keyChanged] = true;
            }
        };
        /**
         * @param thing   A Thing to check the bounding box of.
         * @returns The index of the first row the Thing is inside.
         */
        QuadsKeepr.prototype.findQuadrantRowStart = function (thing) {
            return Math.max(Math.floor((this.getTop(thing) - this.top) / this.quadrantHeight), 0);
        };
        /**
         * @param thing   A Thing to check the bounding box of.
         * @returns The index of the last row the Thing is inside.
         */
        QuadsKeepr.prototype.findQuadrantRowEnd = function (thing) {
            return Math.min(Math.floor((this.getBottom(thing) - this.top) / this.quadrantHeight), this.numRows - 1);
        };
        /**
         * @param thing   A Thing to check the bounding box of.
         * @returns The index of the first column the Thing is inside.
         */
        QuadsKeepr.prototype.findQuadrantColStart = function (thing) {
            return Math.max(Math.floor((this.getLeft(thing) - this.left) / this.quadrantWidth), 0);
        };
        /**
         * @param thing   A Thing to check the bounding box of.
         * @returns The index of the last column the Thing is inside.
         */
        QuadsKeepr.prototype.findQuadrantColEnd = function (thing) {
            return Math.min(Math.floor((this.getRight(thing) - this.left) / this.quadrantWidth), this.numCols - 1);
        };
        return QuadsKeepr;
    })();
    QuadsKeepr_1.QuadsKeepr = QuadsKeepr;
})(QuadsKeepr || (QuadsKeepr = {}));
/// <reference path="ChangeLinr-0.2.0.ts" />
/// <reference path="ObjectMakr-0.2.2.ts" />
/// <reference path="PixelRendr-0.2.0.ts" />
/// <reference path="QuadsKeepr-0.2.1.ts" />
/// <reference path="StringFilr-0.2.1.ts" />
var PixelDrawr;
(function (PixelDrawr_1) {
    "use strict";
    /**
     * A front-end to PixelRendr to automate drawing mass amounts of sprites.
     */
    var PixelDrawr = (function () {
        /**
         * Initializes a new instance of the PixelDrawr class.
         *
         * @param settings   Settings to be used for initialization.
         */
        function PixelDrawr(settings) {
            if (!settings) {
                throw new Error("No settings object given to PixelDrawr.");
            }
            if (typeof settings.PixelRender === "undefined") {
                throw new Error("No PixelRender given to PixelDrawr.");
            }
            if (typeof settings.MapScreener === "undefined") {
                throw new Error("No MapScreener given to PixelDrawr.");
            }
            if (typeof settings.createCanvas === "undefined") {
                throw new Error("No createCanvas given to PixelDrawr.");
            }
            this.PixelRender = settings.PixelRender;
            this.MapScreener = settings.MapScreener;
            this.createCanvas = settings.createCanvas;
            this.unitsize = settings.unitsize || 1;
            this.noRefill = settings.noRefill;
            this.spriteCacheCutoff = settings.spriteCacheCutoff || 0;
            this.groupNames = settings.groupNames;
            this.framerateSkip = settings.framerateSkip || 1;
            this.framesDrawn = 0;
            this.epsilon = settings.epsilon || .007;
            this.keyWidth = settings.keyWidth || "width";
            this.keyHeight = settings.keyHeight || "height";
            this.keyTop = settings.keyTop || "top";
            this.keyRight = settings.keyRight || "right";
            this.keyBottom = settings.keyBottom || "bottom";
            this.keyLeft = settings.keyLeft || "left";
            this.keyOffsetX = settings.keyOffsetX;
            this.keyOffsetY = settings.keyOffsetY;
            this.generateObjectKey = settings.generateObjectKey || function (thing) {
                return thing.toString();
            };
            this.resetBackground();
        }
        /* Simple gets
        */
        /**
         * @returns How often refill calls should be skipped.
         */
        PixelDrawr.prototype.getFramerateSkip = function () {
            return this.framerateSkip;
        };
        /**
         * @returns The Arrays to be redrawn during refill calls.
         */
        PixelDrawr.prototype.getThingArray = function () {
            return this.thingArrays;
        };
        /**
         * @returns The canvas element each Thing is to drawn on.
         */
        PixelDrawr.prototype.getCanvas = function () {
            return this.canvas;
        };
        /**
         * @returns The 2D canvas context associated with the canvas.
         */
        PixelDrawr.prototype.getContext = function () {
            return this.context;
        };
        /**
         * @returns The canvas element used for the background.
         */
        PixelDrawr.prototype.getBackgroundCanvas = function () {
            return this.backgroundCanvas;
        };
        /**
         * @returns The 2D canvas context associated with the background canvas.
         */
        PixelDrawr.prototype.getBackgroundContext = function () {
            return this.backgroundContext;
        };
        /**
         * @returns Whether refills should skip redrawing the background each time.
         */
        PixelDrawr.prototype.getNoRefill = function () {
            return this.noRefill;
        };
        /**
         * @returns The minimum opacity that will be drawn.
         */
        PixelDrawr.prototype.getEpsilon = function () {
            return this.epsilon;
        };
        /* Simple sets
        */
        /**
         * @param framerateSkip   How often refill calls should be skipped.
         */
        PixelDrawr.prototype.setFramerateSkip = function (framerateSkip) {
            this.framerateSkip = framerateSkip;
        };
        /**
         * @param thingArrays   The Arrays to be redrawn during refill calls.
         */
        PixelDrawr.prototype.setThingArrays = function (thingArrays) {
            this.thingArrays = thingArrays;
        };
        /**
         * Sets the currently drawn canvas and context, and recreates
         * drawThingOnContextBound.
         *
         * @param canvas   The new primary canvas to be used.
         */
        PixelDrawr.prototype.setCanvas = function (canvas) {
            this.canvas = canvas;
            this.context = canvas.getContext("2d");
        };
        /**
         * @param noRefill   Whether refills should now skip redrawing the
         *                   background each time.
         */
        PixelDrawr.prototype.setNoRefill = function (noRefill) {
            this.noRefill = noRefill;
        };
        /**
         * @param epsilon   The minimum opacity that will be drawn.
         */
        PixelDrawr.prototype.setEpsilon = function (epsilon) {
            this.epsilon = epsilon;
        };
        /* Background manipulations
        */
        /**
         * Creates a new canvas the size of MapScreener and sets the background
         * canvas to it, then recreates backgroundContext.
         */
        PixelDrawr.prototype.resetBackground = function () {
            this.backgroundCanvas = this.createCanvas(this.MapScreener[this.keyWidth], this.MapScreener[this.keyHeight]);
            this.backgroundContext = this.backgroundCanvas.getContext("2d");
        };
        /**
         * Refills the background canvas with a new fillStyle.
         *
         * @param fillStyle   The new fillStyle for the background context.
         */
        PixelDrawr.prototype.setBackground = function (fillStyle) {
            this.backgroundContext.fillStyle = fillStyle;
            this.backgroundContext.fillRect(0, 0, this.MapScreener[this.keyWidth], this.MapScreener[this.keyHeight]);
        };
        /**
         * Draws the background canvas onto the main canvas' context.
         */
        PixelDrawr.prototype.drawBackground = function () {
            this.context.drawImage(this.backgroundCanvas, 0, 0);
        };
        /* Core rendering
        */
        /**
         * Goes through all the motions of finding and parsing a Thing's sprite.
         * This should be called whenever the sprite's appearance changes.
         *
         * @param thing   A Thing whose sprite must be updated.
         */
        PixelDrawr.prototype.setThingSprite = function (thing) {
            // If it's set as hidden, don't bother updating it
            if (thing.hidden) {
                return;
            }
            // PixelRender does most of the work in fetching the rendered sprite
            thing.sprite = this.PixelRender.decode(this.generateObjectKey(thing), thing);
            // To do: remove dependency on .numSprites
            // For now, it's used to know whether it's had its sprite set, but 
            // wouldn't physically having a .sprite do that?
            if (thing.sprite.constructor === PixelRendr.SpriteMultiple) {
                thing.numSprites = 0;
                this.refillThingCanvasMultiple(thing);
            }
            else {
                thing.numSprites = 1;
                this.refillThingCanvasSingle(thing);
            }
        };
        /* Core drawing APIs
        */
        /**
         * Called every upkeep to refill the entire main canvas. All Thing arrays
         * are made to call this.refillThingArray in order.
         */
        PixelDrawr.prototype.refillGlobalCanvas = function () {
            this.framesDrawn += 1;
            if (this.framesDrawn % this.framerateSkip !== 0) {
                return;
            }
            if (!this.noRefill) {
                this.drawBackground();
            }
            for (var i = 0; i < this.thingArrays.length; i += 1) {
                this.refillThingArray(this.thingArrays[i]);
            }
        };
        /**
         * Calls drawThingOnContext on each Thing in the Array.
         *
         * @param array   A listing of Things to be drawn onto the canvas.
         */
        PixelDrawr.prototype.refillThingArray = function (array) {
            for (var i = 0; i < array.length; i += 1) {
                this.drawThingOnContext(this.context, array[i]);
            }
        };
        /**
         * General Function to draw a Thing onto a context. This will call
         * drawThingOnContext[Single/Multiple] with more arguments
         *
         * @param context   The context to have the Thing drawn on it.
         * @param thing   The Thing to be drawn onto the context.
         */
        PixelDrawr.prototype.drawThingOnContext = function (context, thing) {
            if (thing.hidden
                || thing.opacity < this.epsilon
                || thing[this.keyHeight] < 1
                || thing[this.keyWidth] < 1
                || this.getTop(thing) > this.MapScreener[this.keyHeight]
                || this.getRight(thing) < 0
                || this.getBottom(thing) < 0
                || this.getLeft(thing) > this.MapScreener[this.keyWidth]) {
                return;
            }
            // If Thing hasn't had a sprite yet (previously hidden), do that first
            if (typeof thing.numSprites === "undefined") {
                this.setThingSprite(thing);
            }
            // Whether or not the thing has a regular sprite or a SpriteMultiple, 
            // that sprite has already been drawn to the thing's canvas, unless it's
            // above the cutoff, in which case that logic happens now.
            if (thing.canvas[this.keyWidth] > 0) {
                this.drawThingOnContextSingle(context, thing.canvas, thing, this.getLeft(thing), this.getTop(thing));
            }
            else {
                this.drawThingOnContextMultiple(context, thing.canvases, thing, this.getLeft(thing), this.getTop(thing));
            }
        };
        /* Core drawing internals
        */
        /**
         * Simply draws a thing's sprite to its canvas by getting and setting
         * a canvas::imageData object via context.getImageData(...).
         *
         * @param thing   A Thing whose canvas must be updated.
         */
        PixelDrawr.prototype.refillThingCanvasSingle = function (thing) {
            // Don't draw small Things.
            if (thing[this.keyWidth] < 1 || thing[this.keyHeight] < 1) {
                return;
            }
            // Retrieve the imageData from the Thing's canvas & renderingContext
            var canvas = thing.canvas, context = thing.context, imageData = context.getImageData(0, 0, canvas[this.keyWidth], canvas[this.keyHeight]);
            // Copy the thing's sprite to that imageData and into the contextz
            this.PixelRender.memcpyU8(thing.sprite, imageData.data);
            context.putImageData(imageData, 0, 0);
        };
        /**
         * For SpriteMultiples, this copies the sprite information for each
         * sub-sprite into its own canvas, sets thing.sprites, then draws the newly
         * rendered information onto the thing's canvas.
         *
         * @param thing   A Thing whose canvas and sprites must be updated.
         */
        PixelDrawr.prototype.refillThingCanvasMultiple = function (thing) {
            if (thing[this.keyWidth] < 1 || thing[this.keyHeight] < 1) {
                return;
            }
            var spritesRaw = thing.sprite, canvases = thing.canvases = {
                "direction": spritesRaw.direction,
                "multiple": true
            }, canvas, context, imageData, i;
            thing.numSprites = 1;
            for (i in spritesRaw.sprites) {
                if (!spritesRaw.sprites.hasOwnProperty(i)) {
                    continue;
                }
                // Make a new sprite for this individual component
                canvas = this.createCanvas(thing.spritewidth * this.unitsize, thing.spriteheight * this.unitsize);
                context = canvas.getContext("2d");
                // Copy over this sprite's information the same way as refillThingCanvas
                imageData = context.getImageData(0, 0, canvas[this.keyWidth], canvas[this.keyHeight]);
                this.PixelRender.memcpyU8(spritesRaw.sprites[i], imageData.data);
                context.putImageData(imageData, 0, 0);
                // Record the canvas and context in thing.sprites
                canvases[i] = {
                    "canvas": canvas,
                    "context": context
                };
                thing.numSprites += 1;
            }
            // Only pre-render multiple sprites if they're below the cutoff
            if (thing[this.keyWidth] * thing[this.keyHeight] < this.spriteCacheCutoff) {
                thing.canvas[this.keyWidth] = thing[this.keyWidth] * this.unitsize;
                thing.canvas[this.keyHeight] = thing[this.keyHeight] * this.unitsize;
                this.drawThingOnContextMultiple(thing.context, thing.canvases, thing, 0, 0);
            }
            else {
                thing.canvas[this.keyWidth] = thing.canvas[this.keyHeight] = 0;
            }
        };
        /**
         * Draws a Thing's single canvas onto a context, commonly called by
         * this.drawThingOnContext.
         *
         * @param context    The context being drawn on.
         * @param canvas   The Thing's canvas being drawn onto the context.
         * @param thing   The Thing whose canvas is being drawn.
         * @param left   The x-position to draw the Thing from.
         * @param top   The y-position to draw the Thing from.
         */
        PixelDrawr.prototype.drawThingOnContextSingle = function (context, canvas, thing, left, top) {
            // If the sprite should repeat, use the pattern equivalent
            if (thing.repeat) {
                this.drawPatternOnContext(context, canvas, left, top, thing.unitwidth, thing.unitheight, thing.opacity || 1);
            }
            else if (thing.opacity !== 1) {
                // Opacities not equal to one must reset the context afterwards
                context.globalAlpha = thing.opacity;
                context.drawImage(canvas, left, top, canvas.width * thing.scale, canvas.height * thing.scale);
                context.globalAlpha = 1;
            }
            else {
                context.drawImage(canvas, left, top, canvas.width * thing.scale, canvas.height * thing.scale);
            }
        };
        /**
         * Draws a Thing's multiple canvases onto a context, typicall called by
         * drawThingOnContext. A variety of cases for canvases is allowed:
         * "vertical", "horizontal", and "corners".
         *
         * @param context    The context being drawn on.
         * @param canvases   The canvases being drawn onto the context.
         * @param thing   The Thing whose canvas is being drawn.
         * @param left   The x-position to draw the Thing from.
         * @param top   The y-position to draw the Thing from.
         */
        PixelDrawr.prototype.drawThingOnContextMultiple = function (context, canvases, thing, left, top) {
            var sprite = thing.sprite, topreal = top, leftreal = left, rightreal = left + thing.unitwidth, bottomreal = top + thing.unitheight, widthreal = thing.unitwidth, heightreal = thing.unitheight, spritewidthpixels = thing.spritewidthpixels, spriteheightpixels = thing.spriteheightpixels, widthdrawn = Math.min(widthreal, spritewidthpixels), heightdrawn = Math.min(heightreal, spriteheightpixels), opacity = thing.opacity, diffhoriz, diffvert, canvasref;
            switch (canvases.direction) {
                // Vertical sprites may have "top", "bottom", "middle"
                case "vertical":
                    // If there's a bottom, draw that and push up bottomreal
                    if ((canvasref = canvases[this.keyBottom])) {
                        diffvert = sprite.bottomheight ? sprite.bottomheight * this.unitsize : spriteheightpixels;
                        this.drawPatternOnContext(context, canvasref.canvas, leftreal, bottomreal - diffvert, widthreal, heightdrawn, opacity);
                        bottomreal -= diffvert;
                        heightreal -= diffvert;
                    }
                    // If there's a top, draw that and push down topreal
                    if ((canvasref = canvases[this.keyTop])) {
                        diffvert = sprite.topheight ? sprite.topheight * this.unitsize : spriteheightpixels;
                        this.drawPatternOnContext(context, canvasref.canvas, leftreal, topreal, widthreal, heightdrawn, opacity);
                        topreal += diffvert;
                        heightreal -= diffvert;
                    }
                    break;
                // Horizontal sprites may have "left", "right", "middle"
                case "horizontal":
                    // If there's a left, draw that and push forward leftreal
                    if ((canvasref = canvases[this.keyLeft])) {
                        diffhoriz = sprite.leftwidth ? sprite.leftwidth * this.unitsize : spritewidthpixels;
                        this.drawPatternOnContext(context, canvasref.canvas, leftreal, topreal, widthdrawn, heightreal, opacity);
                        leftreal += diffhoriz;
                        widthreal -= diffhoriz;
                    }
                    // If there's a right, draw that and push back rightreal
                    if ((canvasref = canvases[this.keyRight])) {
                        diffhoriz = sprite.rightwidth ? sprite.rightwidth * this.unitsize : spritewidthpixels;
                        this.drawPatternOnContext(context, canvasref.canvas, rightreal - diffhoriz, topreal, widthdrawn, heightreal, opacity);
                        rightreal -= diffhoriz;
                        widthreal -= diffhoriz;
                    }
                    break;
                // Corner (vertical + horizontal + corner) sprites must have corners
                // in "topRight", "bottomRight", "bottomLeft", and "topLeft".
                case "corners":
                    // topLeft, left, bottomLeft
                    diffvert = sprite.topheight ? sprite.topheight * this.unitsize : spriteheightpixels;
                    diffhoriz = sprite.leftwidth ? sprite.leftwidth * this.unitsize : spritewidthpixels;
                    this.drawPatternOnContext(context, canvases.topLeft.canvas, leftreal, topreal, widthdrawn, heightdrawn, opacity);
                    this.drawPatternOnContext(context, canvases[this.keyLeft].canvas, leftreal, topreal + diffvert, widthdrawn, heightreal - diffvert * 2, opacity);
                    this.drawPatternOnContext(context, canvases.bottomLeft.canvas, leftreal, bottomreal - diffvert, widthdrawn, heightdrawn, opacity);
                    leftreal += diffhoriz;
                    widthreal -= diffhoriz;
                    // top, topRight
                    diffhoriz = sprite.rightwidth ? sprite.rightwidth * this.unitsize : spritewidthpixels;
                    this.drawPatternOnContext(context, canvases[this.keyTop].canvas, leftreal, topreal, widthreal - diffhoriz, heightdrawn, opacity);
                    this.drawPatternOnContext(context, canvases.topRight.canvas, rightreal - diffhoriz, topreal, widthdrawn, heightdrawn, opacity);
                    topreal += diffvert;
                    heightreal -= diffvert;
                    // right, bottomRight, bottom
                    diffvert = sprite.bottomheight ? sprite.bottomheight * this.unitsize : spriteheightpixels;
                    this.drawPatternOnContext(context, canvases[this.keyRight].canvas, rightreal - diffhoriz, topreal, widthdrawn, heightreal - diffvert, opacity);
                    this.drawPatternOnContext(context, canvases.bottomRight.canvas, rightreal - diffhoriz, bottomreal - diffvert, widthdrawn, heightdrawn, opacity);
                    this.drawPatternOnContext(context, canvases[this.keyBottom].canvas, leftreal, bottomreal - diffvert, widthreal - diffhoriz, heightdrawn, opacity);
                    rightreal -= diffhoriz;
                    widthreal -= diffhoriz;
                    bottomreal -= diffvert;
                    heightreal -= diffvert;
                    break;
                default:
                    throw new Error("Unknown or missing direction given in SpriteMultiple.");
            }
            // If there's still room, draw the actual canvas
            if ((canvasref = canvases.middle) && topreal < bottomreal && leftreal < rightreal) {
                if (sprite.middleStretch) {
                    context.globalAlpha = opacity;
                    context.drawImage(canvasref.canvas, leftreal, topreal, widthreal, heightreal);
                    context.globalAlpha = 1;
                }
                else {
                    this.drawPatternOnContext(context, canvasref.canvas, leftreal, topreal, widthreal, heightreal, opacity);
                }
            }
        };
        /* Position utilities (which should almost always be optimized)
        */
        /**
         * @param thing   Any Thing.
         * @returns The Thing's top position, accounting for vertical offset if needed.
         */
        PixelDrawr.prototype.getTop = function (thing) {
            if (this.keyOffsetY) {
                return thing[this.keyTop] + thing[this.keyOffsetY];
            }
            else {
                return thing[this.keyTop];
            }
        };
        /**
         * @param thing   Any Thing.
         * @returns The Thing's right position, accounting for horizontal offset if needed.
         */
        PixelDrawr.prototype.getRight = function (thing) {
            if (this.keyOffsetX) {
                return thing[this.keyRight] + thing[this.keyOffsetX];
            }
            else {
                return thing[this.keyRight];
            }
        };
        /**
         * @param thing   Any Thing.
         * @returns {Number} The Thing's bottom position, accounting for vertical
         *                  offset if needed.
         */
        PixelDrawr.prototype.getBottom = function (thing) {
            if (this.keyOffsetX) {
                return thing[this.keyBottom] + thing[this.keyOffsetY];
            }
            else {
                return thing[this.keyBottom];
            }
        };
        /**
         * @param thing   Any Thing.
         * @returns The Thing's left position, accounting for horizontal offset if needed.
         */
        PixelDrawr.prototype.getLeft = function (thing) {
            if (this.keyOffsetX) {
                return thing[this.keyLeft] + thing[this.keyOffsetX];
            }
            else {
                return thing[this.keyLeft];
            }
        };
        /* Utilities
        */
        /**
         * Draws a source pattern onto a context. The pattern is clipped to the size
         * of MapScreener.
         *
         * @param context   The context the pattern will be drawn onto.
         * @param source   The image being repeated as a pattern. This can be a canvas,
         *                 an image, or similar.
         * @param left   The x-location to draw from.
         * @param top   The y-location to draw from.
         * @param width   How many pixels wide the drawing area should be.
         * @param left   How many pixels high the drawing area should be.
         * @param opacity   How transparent the drawing is, in [0,1].
         */
        PixelDrawr.prototype.drawPatternOnContext = function (context, source, left, top, width, height, opacity) {
            context.globalAlpha = opacity;
            context.translate(left, top);
            context.fillStyle = context.createPattern(source, "repeat");
            context.fillRect(0, 0, 
            // Math.max(width, left - MapScreener[keyRight]),
            // Math.max(height, top - MapScreener[keyBottom])
            width, height);
            context.translate(-left, -top);
            context.globalAlpha = 1;
        };
        return PixelDrawr;
    })();
    PixelDrawr_1.PixelDrawr = PixelDrawr;
})(PixelDrawr || (PixelDrawr = {}));
var TimeHandlr;
(function (TimeHandlr) {
    "use strict";
    /**
     * An event to be played, including a callback, repetition settings, and arguments.
     */
    var TimeEvent = (function () {
        /**
         * Initializes a new instance of the Event class.
         *
         * @param callback   A callback to be run some number of times. If it returns
         *                   truthy, repetition stops.
         * @param repeat   How many times to run the event.
         * @param time   The current time in the parent TimeHandlr.
         * @param timeRepeat   How long from now to run the callback, and how many
         *                     steps between each call.
         * @param args   Any additional arguments to pass to the callback.
         */
        function TimeEvent(callback, repeat, time, timeRepeat, args) {
            /**
             * How many times this has been called.
             */
            this.count = 0;
            this.callback = callback;
            this.repeat = repeat;
            this.timeRepeat = timeRepeat;
            this.time = time + TimeEvent.runCalculator(timeRepeat, this);
            this.args = args;
        }
        /**
         * Computes a value as either a raw Number or a Function.
         *
         * @param value   The value to be computed.
         * @param args   Any additional arguments, if value is a Function.
         * @returns A numeric equivalent of the value.
         */
        TimeEvent.runCalculator = function (value) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (value.constructor === Number) {
                return value;
            }
            else {
                return value.apply(void 0, args);
            }
        };
        /**
         * Set the next call time using timeRepeat.
         *
         * @returns The new call time.
         */
        TimeEvent.prototype.scheduleNextRepeat = function () {
            return this.time += TimeEvent.runCalculator(this.timeRepeat);
        };
        return TimeEvent;
    })();
    TimeHandlr.TimeEvent = TimeEvent;
})(TimeHandlr || (TimeHandlr = {}));
var TimeHandlr;
(function (TimeHandlr_1) {
    "use strict";
    /**
     * A timed events library providing a flexible alternative to setTimeout
     * and setInterval that respects pauses and resumes. Events are assigned
     * integer timestamps, and can be set to repeat multiple times.
     */
    var TimeHandlr = (function () {
        /**
         * Initializes a new instance of the TimeHandlr class.
         *
         * @param settings   Settings to be used for initialization.
         */
        function TimeHandlr(settings) {
            if (settings === void 0) { settings = {}; }
            this.time = 0;
            this.events = {};
            this.timingDefault = settings.timingDefault || 1;
            this.keyCycles = settings.keyCycles || "cycles";
            this.keyClassName = settings.keyClassName || "className";
            this.keyOnClassCycleStart = settings.keyOnClassCycleStart || "onClassCycleStart";
            this.keyDoClassCycleStart = settings.keyDoClassCycleStart || "doClassCycleStart";
            this.keyCycleCheckValidity = settings.keyCycleCheckValidity;
            this.copyCycleSettings = typeof settings.copyCycleSettings === "undefined" ? true : settings.copyCycleSettings;
            this.classAdd = settings.classAdd || this.classAddGeneric;
            this.classRemove = settings.classRemove || this.classRemoveGeneric;
        }
        /* Simple gets
        */
        /**
         * @returns The current time.
         */
        TimeHandlr.prototype.getTime = function () {
            return this.time;
        };
        /**
         * @returns The catalog of events, keyed by their time triggers.
         */
        TimeHandlr.prototype.getEvents = function () {
            return this.events;
        };
        /* Event adding
        */
        /**
         * Adds an event in a manner similar to setTimeout, though any arguments
         * past the timeDelay will be passed to the event callback. The added event
         * is inserted into the events container and set to only repeat once.
         *
         * @param callback   A callback to be run after some time.
         * @param timeDelay   How long from now to run the callback (by default, 1).
         * @param args   Any additional arguments to pass to the callback.
         * @returns An event with the given callback and time information.
         */
        TimeHandlr.prototype.addEvent = function (callback, timeDelay) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            var event = new TimeHandlr_1.TimeEvent(callback, 1, this.time, timeDelay || 1, args);
            this.insertEvent(event);
            return event;
        };
        /**
         * Adds an event in a manner similar to setInterval, though any arguments past
         * the numRepeats will be passed to the event callback. The added event is
         * inserted into the events container and is set to repeat a numRepeat amount
         * of times, though if the callback returns true, it will stop.
         *
         * @param callback   A callback to be run some number of times. If it returns
         *                   truthy, repetition stops.
         * @param timeDelay   How long from now to run the callback, and how many
         *                    steps between each call (by default, 1).
         * @param numRepeats   How many times to run the event. Infinity is an
         *                     acceptable option (by default, 1).
         * @param args   Any additional arguments to pass to the callback.
         * @returns An event with the given callback and time information.
         */
        TimeHandlr.prototype.addEventInterval = function (callback, timeDelay, numRepeats) {
            var args = [];
            for (var _i = 3; _i < arguments.length; _i++) {
                args[_i - 3] = arguments[_i];
            }
            var event = new TimeHandlr_1.TimeEvent(callback, numRepeats || 1, this.time, timeDelay || 1, args);
            this.insertEvent(event);
            return event;
        };
        /**
         * A wrapper around addEventInterval that delays starting the event
         * until the current time is modular with the repeat delay, so that all
         * event intervals synched to the same period are in unison.
         *
         * @param callback   A callback to be run some number of times. If it returns
         *                   truthy, repetition stops.
         * @param timeDelay   How long from now to run the callback, and how many
         *                    steps between each call (by default, 1).
         * @param numRepeats   How many times to run the event. Infinity is an
         *                     acceptable option (by default, 1).
         * @param thing   Some data container to be manipulated.
         * @param args   Any additional arguments to pass to the callback.
         * @returns An event with the given callback and time information.
         */
        TimeHandlr.prototype.addEventIntervalSynched = function (callback, timeDelay, numRepeats) {
            var args = [];
            for (var _i = 3; _i < arguments.length; _i++) {
                args[_i - 3] = arguments[_i];
            }
            timeDelay = timeDelay || 1;
            numRepeats = numRepeats || 1;
            var calcTime = TimeHandlr_1.TimeEvent.runCalculator(timeDelay || this.timingDefault), entryTime = Math.ceil(this.time / calcTime) * calcTime;
            if (entryTime === this.time) {
                return this.addEventInterval.apply(this, [callback, timeDelay, numRepeats].concat(args));
            }
            else {
                return this.addEvent.apply(this, [this.addEventInterval, entryTime - this.time, callback, timeDelay, numRepeats].concat(args));
            }
        };
        /* Class cycles
        */
        /**
         * Adds a sprite cycle (settings) for a thing, to be referenced by the given
         * name in the thing's cycles Object.
         *
         * @param thing   The object whose class is to be cycled.
         * @param settings   A container for repetition settings, particularly .length.
         * @param name   The name of the cycle, to be referenced in the thing's cycles.
         * @param timing   A way to determine how long to wait between classes.
         */
        TimeHandlr.prototype.addClassCycle = function (thing, settings, name, timing) {
            // Make sure the object has a holder for keyCycles...
            if (!thing[this.keyCycles]) {
                thing[this.keyCycles] = {};
            }
            // ...and nothing previously existing for that name
            this.cancelClassCycle(thing, name);
            settings = thing[this.keyCycles][name || "0"] = this.setClassCycle(thing, settings, timing);
            // Immediately run the first class cycle, then return
            this.cycleClass(thing, settings);
            return settings;
        };
        /**
         * Adds a synched sprite cycle (settings) for a thing, to be referenced by
         * the given name in the thing's cycles Object, and in tune with all other
         * cycles of the same period.
         *
         * @param thing   The object whose class is to be cycled.
         * @param settings   A container for repetition settings, particularly .length.
         * @param name   The name of the cycle, to be referenced in the thing's cycles.
         * @param timing   A way to determine how long to wait between classes.
         */
        TimeHandlr.prototype.addClassCycleSynched = function (thing, settings, name, timing) {
            // Make sure the object has a holder for keyCycles...
            if (!thing[this.keyCycles]) {
                thing[this.keyCycles] = {};
            }
            // ...and nothing previously existing for that name
            this.cancelClassCycle(thing, name);
            settings = thing[this.keyCycles][name || "0"] = this.setClassCycle(thing, settings, timing, true);
            // Immediately run the first class cycle, then return
            this.cycleClass(thing, settings);
            return settings;
        };
        /* General event handling
        */
        /**
         * Increments time and handles all now-current events.
         */
        TimeHandlr.prototype.handleEvents = function () {
            var currentEvents, i;
            this.time += 1;
            currentEvents = this.events[this.time];
            if (!currentEvents) {
                return;
            }
            for (i = 0; i < currentEvents.length; i += 1) {
                this.handleEvent(currentEvents[i]);
            }
            // Once all these events are done, ignore the memory
            delete this.events[this.time];
        };
        /**
         * Handles a single event by calling its callback then checking its repeatability.
         * If it is repeatable, it is re-added at a later time to the events listing.
         *
         * @param event   An event to be handled.
         * @returns A new time the event is scheduled for (or undefined if it isn't).
         */
        TimeHandlr.prototype.handleEvent = function (event) {
            // Events return truthy values to indicate a stop.
            if (event.repeat <= 0 || event.callback.apply(this, event.args)) {
                return;
            }
            if (typeof event.repeat === "function") {
                // Repeat calculators return truthy values to indicate to keep going
                if (!event.repeat.apply(this, event.args)) {
                    return;
                }
            }
            else {
                if (!event.repeat) {
                    return;
                }
                event.repeat = event.repeat - 1;
                if (event.repeat <= 0) {
                    return;
                }
            }
            event.scheduleNextRepeat();
            this.insertEvent(event);
            return event.time;
        };
        /**
         * Cancels an event by making its .repeat value 0.
         *
         * @param event   The event to cancel.
         */
        TimeHandlr.prototype.cancelEvent = function (event) {
            event.repeat = 0;
        };
        /**
         * Cancels all events by clearing the events Object.
         */
        TimeHandlr.prototype.cancelAllEvents = function () {
            this.events = {};
        };
        /**
         * Cancels the class cycle of a thing by finding the cycle under the thing's
         * cycles and making it appear to be empty.
         *
         * @param thing   The thing whose cycle is to be cancelled.
         * @param name   The name of the cycle to be cancelled.
         */
        TimeHandlr.prototype.cancelClassCycle = function (thing, name) {
            var cycle;
            if (!thing[this.keyCycles] || !thing[this.keyCycles][name]) {
                return;
            }
            cycle = thing[this.keyCycles][name];
            cycle.event.repeat = 0;
            delete thing[this.keyCycles][name];
        };
        /**
         * Cancels all class cycles of a thing under the thing's sycles.
         *
         * @param thing   The thing whose cycles are to be cancelled.
         */
        TimeHandlr.prototype.cancelAllCycles = function (thing) {
            var keyCycles = thing[this.keyCycles], cycle, name;
            for (name in keyCycles) {
                if (!keyCycles.hasOwnProperty(name)) {
                    continue;
                }
                cycle = keyCycles[name];
                cycle.length = 1;
                cycle[0] = false;
                delete keyCycles[name];
            }
        };
        /* Internal handling
        */
        /**
         * Initialization utility for sprite cycles of things. The settings are
         * added at the right time (immediately if not synched, or on a delay if
         * synched).
         *
         * @param thing   The object whose class is to be cycled.
         * @param settings   A container for repetition settings, particularly .length.
         * @param timing   A way to determine how often to do the cycle.
         * @param synched   Whether the animations should be synched to their period.
         * @returns The cycle containing settings and the new event.
         */
        TimeHandlr.prototype.setClassCycle = function (thing, settings, timing, synched) {
            var _this = this;
            timing = TimeHandlr_1.TimeEvent.runCalculator(timing || this.timingDefault);
            if (this.copyCycleSettings) {
                settings = this.makeSettingsCopy(settings);
            }
            // Start off before the beginning of the cycle
            settings.location = settings.oldclass = -1;
            // Let the object know to start the cycle when needed
            if (synched) {
                thing[this.keyOnClassCycleStart] = function () {
                    var calcTime = settings.length * timing, entryDelay = Math.ceil(_this.time / calcTime) * calcTime - _this.time, event;
                    if (entryDelay === 0) {
                        event = _this.addEventInterval(_this.cycleClass, timing, Infinity, thing, settings);
                    }
                    else {
                        event = _this.addEvent(_this.addEventInterval, entryDelay, _this.cycleClass, timing, Infinity, thing, settings);
                    }
                    settings.event = event;
                };
            }
            else {
                thing[this.keyOnClassCycleStart] = function () {
                    settings.event = _this.addEventInterval(_this.cycleClass, timing, Infinity, thing, settings);
                };
            }
            // If it should already start, do that
            if (thing[this.keyDoClassCycleStart]) {
                thing[this.keyOnClassCycleStart]();
            }
            return settings;
        };
        /**
         * Moves an object from its current class in the sprite cycle to the next.
         * If the next object is === false, or the repeat function returns false,
         * stop by returning true.
         *
         * @param thing   The object whose class is to be cycled.
         * @param settings   A container for repetition settings, particularly .length.
         * @returns Whether the class cycle should stop (normally false).
         */
        TimeHandlr.prototype.cycleClass = function (thing, settings) {
            // If anything has been invalidated, return true to stop
            if (!thing || !settings || !settings.length || (this.keyCycleCheckValidity && !thing[this.keyCycleCheckValidity])) {
                return true;
            }
            var current, name;
            // Get rid of the previous class from settings, if it's a String
            if (settings.oldclass !== -1 && typeof settings[settings.oldclass] === "string") {
                this.classRemove(thing, settings[settings.oldclass]);
            }
            // Move to the next location in settings, as a circular list
            settings.location = (settings.location += 1) % settings.length;
            // Current is the class, bool, or Function currently added and/or run
            current = settings[settings.location];
            if (!current) {
                return false;
            }
            if (current.constructor === Function) {
                name = current(thing, settings);
            }
            else {
                name = current;
            }
            settings.oldclass = settings.location;
            // Strings are classes to be added directly
            if (typeof name === "string") {
                this.classAdd(thing, name);
                return false;
            }
            else {
                // Truthy non-String names imply a stop is required
                return !!name;
            }
        };
        /* Utilities
        */
        /**
         * Quick handler to add an event to events at a particular time. If the time
         * doesn't have any events listed, a new Array is made to hold this event.
         */
        TimeHandlr.prototype.insertEvent = function (event) {
            if (!this.events[event.time]) {
                this.events[event.time] = [event];
            }
            else {
                this.events[event.time].push(event);
            }
        };
        /**
         * Creates a copy of an Object/Array. This is useful for passing settings
         * Objects by value instead of reference.
         *
         * @param original   The original object.
         * @returns A copy of the original object.
         */
        TimeHandlr.prototype.makeSettingsCopy = function (original) {
            var output = new original.constructor(), i;
            for (i in original) {
                if (original.hasOwnProperty(i)) {
                    output[i] = original[i];
                }
            }
            return output;
        };
        /**
         * Default classAdd Function.
         *
         * @param element   The element whose class is being modified.
         * @param className   The String to be added to the thing's class.
         */
        TimeHandlr.prototype.classAddGeneric = function (thing, className) {
            thing[this.keyClassName] += " " + className;
        };
        /**
         * Default classRemove Function.
         *
         * @param element   The element whose class is being modified.
         * @param className   The String to be removed from the thing's class.
         */
        TimeHandlr.prototype.classRemoveGeneric = function (thing, className) {
            thing[this.keyClassName] = thing[this.keyClassName].replace(className, "");
        };
        return TimeHandlr;
    })();
    TimeHandlr_1.TimeHandlr = TimeHandlr;
})(TimeHandlr || (TimeHandlr = {}));
/// <reference path="ChangeLinr-0.2.0.ts" />
/// <reference path="GroupHoldr-0.2.1.ts" />
/// <reference path="InputWritr-0.2.0.ts" />
/// <reference path="MapsCreatr-0.2.1.ts" />
/// <reference path="MapScreenr-0.2.1.ts" />
/// <reference path="AreaSpawnr-0.2.0.ts" />
/// <reference path="ObjectMakr-0.2.2.ts" />
/// <reference path="PixelDrawr-0.2.0.ts" />
/// <reference path="PixelRendr-0.2.0.ts" />
/// <reference path="QuadsKeepr-0.2.1.ts" />
/// <reference path="ItemsHoldr-0.2.1.ts" />
/// <reference path="StringFilr-0.2.1.ts" />
/// <reference path="TimeHandlr-0.2.0.ts" />
var LevelEditr;
(function (LevelEditr_1) {
    "use strict";
    /**
     * A level editor designed to work natively on top of an existing GameStartr
     * sub-class.
     */
    var LevelEditr = (function () {
        /**
         * @param {ILevelEditrSettings} settings
         */
        function LevelEditr(settings) {
            if (typeof settings === "undefined") {
                throw new Error("No settings object given to LevelEditr.");
            }
            if (typeof settings.prethings === "undefined") {
                throw new Error("No prethings given to LevelEditr.");
            }
            if (typeof settings.thingGroups === "undefined") {
                throw new Error("No thingGroups given to LevelEditr.");
            }
            if (typeof settings.things === "undefined") {
                throw new Error("No things given to LevelEditr.");
            }
            if (typeof settings.macros === "undefined") {
                throw new Error("No macros given to LevelEditr.");
            }
            if (typeof settings.beautifier === "undefined") {
                throw new Error("No beautifier given to LevelEditr.");
            }
            this.enabled = false;
            this.GameStarter = settings.GameStarter;
            this.prethings = settings.prethings;
            this.thingGroups = settings.thingGroups;
            this.things = settings.things;
            this.macros = settings.macros;
            this.beautifier = settings.beautifier;
            this.mapNameDefault = settings.mapNameDefault || "New Map";
            this.mapTimeDefault = settings.mapTimeDefault || Infinity;
            this.mapSettingDefault = settings.mapSettingDefault || "";
            this.mapEntrances = settings.mapEntrances || [];
            this.mapDefault = settings.mapDefault;
            this.blocksize = settings.blocksize || 1;
            this.keyUndefined = settings.keyUndefined || "-none-";
            this.currentPreThings = [];
            this.currentMode = "Build";
            this.currentClickMode = "Thing";
            this.canClick = true;
        }
        /* Simple gets
        */
        LevelEditr.prototype.getEnabled = function () {
            return this.enabled;
        };
        /**
         *
         */
        LevelEditr.prototype.getGameStarter = function () {
            return this.GameStarter;
        };
        /**
         *
         */
        LevelEditr.prototype.getOldInformation = function () {
            return this.oldInformation;
        };
        /**
         *
         */
        LevelEditr.prototype.getPreThings = function () {
            return this.prethings;
        };
        /**
         *
         */
        LevelEditr.prototype.getThingGroups = function () {
            return this.thingGroups;
        };
        /**
         *
         */
        LevelEditr.prototype.getThings = function () {
            return this.things;
        };
        /**
         *
         */
        LevelEditr.prototype.getMacros = function () {
            return this.macros;
        };
        /**
         *
         */
        LevelEditr.prototype.getMapNameDefault = function () {
            return this.mapNameDefault;
        };
        /**
         *
         */
        LevelEditr.prototype.getMapTimeDefault = function () {
            return this.mapTimeDefault;
        };
        /**
         *
         */
        LevelEditr.prototype.getMapDefault = function () {
            return this.mapDefault;
        };
        /**
         *
         */
        LevelEditr.prototype.getDisplay = function () {
            return this.display;
        };
        /**
         *
         */
        LevelEditr.prototype.getCurrentMode = function () {
            return this.currentMode;
        };
        /**
         *
         */
        LevelEditr.prototype.getBlockSize = function () {
            return this.blocksize;
        };
        /**
         *
         */
        LevelEditr.prototype.getBeautifier = function () {
            return this.beautifier;
        };
        /**
         *
         */
        LevelEditr.prototype.getCurrentPreThings = function () {
            return this.currentPreThings;
        };
        /**
         *
         */
        LevelEditr.prototype.getCurrentTitle = function () {
            return this.currentTitle;
        };
        /**
         *
         */
        LevelEditr.prototype.getCurrentArgs = function () {
            return this.currentArgs;
        };
        /**
         *
         */
        LevelEditr.prototype.getPageStylesAdded = function () {
            return this.pageStylesAdded;
        };
        /**
         *
         */
        LevelEditr.prototype.getKeyUndefined = function () {
            return this.keyUndefined;
        };
        /**
         *
         */
        LevelEditr.prototype.getCanClick = function () {
            return this.canClick;
        };
        /* State resets
        */
        /**
         *
         */
        LevelEditr.prototype.enable = function () {
            if (this.enabled) {
                return;
            }
            this.enabled = true;
            this.oldInformation = {
                "map": this.GameStarter.AreaSpawner.getMapName()
            };
            this.clearAllThings();
            this.resetDisplay();
            this.setCurrentMode("Build");
            this.GameStarter.MapScreener.nokeys = true;
            this.setTextareaValue(this.stringifySmart(this.mapDefault), true);
            this.resetDisplayMap();
            this.disableAllThings();
            this.GameStarter.ItemsHolder.setItem("lives", Infinity);
            if (!this.pageStylesAdded) {
                this.GameStarter.addPageStyles(this.createPageStyles());
                this.pageStylesAdded = true;
            }
            this.GameStarter.container.insertBefore(this.display.container, this.GameStarter.container.children[0]);
        };
        /**
         *
         */
        LevelEditr.prototype.disable = function () {
            if (!this.display || !this.enabled) {
                return;
            }
            this.GameStarter.container.removeChild(this.display.container);
            this.display = undefined;
            this.GameStarter.setMap(this.oldInformation.map);
            this.GameStarter.ItemsHolder.setItem("lives", this.GameStarter.settings.statistics.values.lives.valueDefault);
            this.enabled = false;
        };
        /**
         *
         */
        LevelEditr.prototype.minimize = function () {
            this.display.minimizer.innerText = "+";
            this.display.minimizer.onclick = this.maximize.bind(this);
            this.display.container.className += " minimized";
            this.display.scrollers.container.style.opacity = "0";
        };
        /**
         *
         */
        LevelEditr.prototype.maximize = function () {
            this.display.minimizer.innerText = "-";
            this.display.minimizer.onclick = this.minimize.bind(this);
            if (this.display.container.className.indexOf("minimized") !== -1) {
                this.display.container.className = this.display.container.className.replace(/ minimized/g, "");
            }
            if (this.currentClickMode === "Thing") {
                this.setSectionClickToPlaceThings();
            }
            else if (this.currentClickMode === "Macro") {
                this.setSectionClickToPlaceMacros();
            }
            this.display.scrollers.container.style.opacity = "1";
        };
        /**
         *
         */
        LevelEditr.prototype.startBuilding = function () {
            this.setCurrentMode("Build");
            this.beautifyTextareaValue();
            this.setDisplayMap(true);
            this.maximize();
        };
        /**
         *
         */
        LevelEditr.prototype.startPlaying = function () {
            this.setCurrentMode("Play");
            this.beautifyTextareaValue();
            this.setDisplayMap();
            this.minimize();
        };
        /**
         *
         */
        LevelEditr.prototype.downloadCurrentJSON = function () {
            var link = this.downloadFile(this.getMapName() + ".json", this.display.stringer.textarea.value || "");
            window.open(link.href);
        };
        /**
         *
         */
        LevelEditr.prototype.setCurrentJSON = function (json) {
            this.startBuilding();
            this.setTextareaValue(json, true);
            this.getMapObjectAndTry();
        };
        /**
         *
         */
        LevelEditr.prototype.loadCurrentJSON = function () {
            this.display.inputDummy.click();
        };
        /**
         *
         */
        LevelEditr.prototype.beautify = function (text) {
            return this.beautifier(text);
        };
        /* Interactivity
        */
        /**
         *
         */
        LevelEditr.prototype.handleUploadCompletion = function (event) {
            this.enable();
            this.setCurrentJSON(event.currentTarget.result);
            this.setSectionJSON();
        };
        /**
         *
         */
        LevelEditr.prototype.setCurrentMode = function (mode) {
            this.currentMode = mode;
        };
        /**
         *
         */
        LevelEditr.prototype.setCurrentClickMode = function (mode, event) {
            this.currentClickMode = mode;
            this.cancelEvent(event);
        };
        /**
         *
         */
        LevelEditr.prototype.setCurrentThing = function (title, x, y) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            var args = this.generateCurrentArgs(), description = this.things[title], reference = this.GameStarter.proliferate({
                "outerok": 2
            }, this.getNormalizedThingArguments(args)), thing = this.GameStarter.ObjectMaker.make(this.currentTitle, reference);
            this.clearCurrentThings();
            this.currentTitle = title;
            this.currentArgs = args;
            this.currentPreThings = [
                {
                    "xloc": 0,
                    "yloc": 0,
                    "top": -description.offsetTop || 0,
                    "right": (description.offsetLeft) + thing.width * this.GameStarter.unitsize,
                    "bottom": (-description.offsetTop || 0) + thing.height * this.GameStarter.unitsize,
                    "left": description.offsetLeft || 0,
                    "title": this.currentTitle,
                    "reference": reference,
                    "thing": thing,
                    "spawned": true
                }
            ];
            this.addThingAndDisableEvents(this.currentPreThings[0].thing, x, y);
        };
        /**
         *
         */
        LevelEditr.prototype.resetCurrentThings = function (event) {
            var currentThing, i;
            for (i = 0; i < this.currentPreThings.length; i += 1) {
                currentThing = this.currentPreThings[i];
                currentThing.thing.outerok = 2;
                this.GameStarter.addThing(currentThing.thing, currentThing.xloc || 0, currentThing.yloc || 0);
                this.disableThing(currentThing.thing);
            }
            this.onMouseMoveEditing(event);
            this.GameStarter.TimeHandler.cancelAllEvents();
        };
        /**
         *
         */
        LevelEditr.prototype.clearCurrentThings = function () {
            if (!this.currentPreThings) {
                return;
            }
            for (var i = 0; i < this.currentPreThings.length; i += 1) {
                this.GameStarter.killNormal(this.currentPreThings[i].thing);
            }
            this.currentPreThings = [];
        };
        /**
         *
         */
        LevelEditr.prototype.setCurrentArgs = function (event) {
            if (this.currentClickMode === "Thing") {
                this.setCurrentThing(this.currentTitle);
            }
            else if (this.currentClickMode === "Macro") {
                this.onMacroIconClick(this.currentTitle, undefined, this.generateCurrentArgs(), event);
            }
            if (event) {
                event.stopPropagation();
            }
        };
        /* Mouse events
        */
        /**
         *
         */
        LevelEditr.prototype.onMouseDownScrolling = function (direction, event) {
            var target = event.target, scope = this;
            target.setAttribute("scrolling", "1");
            this.GameStarter.TimeHandler.addEventInterval(function () {
                if (target.getAttribute("scrolling") !== "1") {
                    return true;
                }
                if (direction < 0 && scope.GameStarter.MapScreener.left <= 0) {
                    (scope.display.scrollers.left).style.opacity = ".14";
                    return;
                }
                for (var i = 0; i < scope.currentPreThings.length; i += 1) {
                    scope.GameStarter.shiftHoriz(scope.currentPreThings[i].thing, direction);
                }
                scope.GameStarter.scrollWindow(direction);
                scope.display.scrollers.left.style.opacity = "1";
            }, 1, Infinity);
        };
        /**
         *
         */
        LevelEditr.prototype.onMouseUpScrolling = function (event) {
            event.target.setAttribute("scrolling", "0");
        };
        /**
         *
         */
        LevelEditr.prototype.onMouseMoveEditing = function (event) {
            var x = event.x || event.clientX || 0, y = event.y || event.clientY || 0, prething, left, top, i;
            for (i = 0; i < this.currentPreThings.length; i += 1) {
                prething = this.currentPreThings[i];
                left = this.roundTo(x - this.GameStarter.container.offsetLeft, this.blocksize);
                top = this.roundTo(y - this.GameStarter.container.offsetTop, this.blocksize);
                if (prething.left) {
                    left += prething.left * this.GameStarter.unitsize;
                }
                if (prething.top) {
                    top -= prething.top * this.GameStarter.unitsize;
                }
                this.GameStarter.setLeft(prething.thing, left);
                this.GameStarter.setTop(prething.thing, top);
            }
        };
        /**
         * Temporarily disables this.canClick, so double clicking doesn't happen.
         */
        LevelEditr.prototype.afterClick = function () {
            this.canClick = false;
            setTimeout((function () {
                this.canClick = true;
            }).bind(this), 70);
        };
        /**
         *
         */
        LevelEditr.prototype.onClickEditingThing = function (event) {
            if (!this.canClick || this.currentMode !== "Build" || !this.currentPreThings.length) {
                return;
            }
            var coordinates = this.getNormalizedMouseEventCoordinates(event, true), x = coordinates[0], y = coordinates[1];
            if (!this.addMapCreationThing(x, y)) {
                return;
            }
            this.onClickEditingGenericAdd(x, y, this.currentTitle, this.currentArgs);
            this.afterClick();
        };
        /**
         *
         */
        LevelEditr.prototype.onClickEditingMacro = function (event) {
            if (!this.canClick || this.currentMode !== "Build" || !this.currentPreThings.length) {
                return;
            }
            var coordinates = this.getNormalizedMouseEventCoordinates(event), x = coordinates[0], y = coordinates[1], prething, i;
            if (!this.addMapCreationMacro(x, y)) {
                return;
            }
            for (i = 0; i < this.currentPreThings.length; i += 1) {
                prething = this.currentPreThings[i];
                this.onClickEditingGenericAdd(x + (prething.left || 0) * this.GameStarter.unitsize, y - (prething.top || 0) * this.GameStarter.unitsize, prething.thing.title || prething.title, prething.reference);
            }
            this.afterClick();
        };
        /**
         *
         */
        LevelEditr.prototype.onClickEditingGenericAdd = function (x, y, title, args) {
            var thing = this.GameStarter.ObjectMaker.make(title, this.GameStarter.proliferate({
                "onThingMake": undefined,
                "onThingAdd": undefined,
                "onThingAdded": undefined,
                "movement": undefined
            }, this.getNormalizedThingArguments(args))), left = x - this.GameStarter.container.offsetLeft, top = y - this.GameStarter.container.offsetTop;
            if (this.currentMode === "Build") {
                this.disableThing(thing);
            }
            this.addThingAndDisableEvents(thing, left, top);
        };
        /**
         *
         */
        LevelEditr.prototype.onThingIconClick = function (title, event) {
            var x = event.x || event.clientX || 0, y = event.y || event.clientY || 0, target = event.target.nodeName === "DIV"
                ? event.target
                : event.target.parentNode;
            this.cancelEvent(event);
            this.killCurrentPreThings();
            this.setVisualOptions(target.getAttribute("name"), undefined, target.options);
            this.generateCurrentArgs();
            this.setCurrentThing(title, x, y);
        };
        /**
         *
         */
        LevelEditr.prototype.onMacroIconClick = function (title, description, options, event) {
            if (description) {
                this.setVisualOptions(title, description, options);
            }
            var map = this.getMapObject();
            if (!map) {
                return;
            }
            this.clearCurrentThings();
            this.GameStarter.MapsCreator.analyzePreMacro(this.GameStarter.proliferate({
                "macro": title,
                "x": 0,
                "y": 0
            }, this.generateCurrentArgs()), this.createPrethingsHolder(this.currentPreThings), this.getCurrentAreaObject(map), map);
            this.currentTitle = title;
            this.resetCurrentThings(event);
        };
        /**
         *
         */
        LevelEditr.prototype.createPrethingsHolder = function (prethings) {
            var output = {};
            this.thingGroups.forEach(function (group) {
                output[group] = prethings;
            });
            return output;
        };
        /**
         *
         */
        LevelEditr.prototype.generateCurrentArgs = function () {
            var args = {}, container = this.display.sections.ClickToPlace.VisualOptions, children = container.getElementsByClassName("VisualOptionsList"), child, labeler, valuer, value, i;
            this.currentArgs = args;
            if (children.length === 0) {
                return args;
            }
            children = children[0].childNodes;
            for (i = 0; i < children.length; i += 1) {
                child = children[i];
                labeler = child.querySelector(".VisualOptionLabel");
                valuer = child.querySelector(".VisualOptionValue");
                switch ((valuer.getAttribute("data:type") || valuer.type).toLowerCase()) {
                    case "boolean":
                        value = valuer.value === "true";
                        break;
                    case "number":
                        value = (Number(valuer.value) || 0) * (Number(valuer.getAttribute("data:mod")) || 1);
                        break;
                    default:
                        if (valuer.getAttribute("typeReal") === "Number") {
                            value = Number(valuer.value);
                        }
                        else {
                            value = valuer.value;
                        }
                        break;
                }
                if (value !== this.keyUndefined) {
                    args[labeler.textContent] = value;
                }
            }
            return args;
        };
        /* Map manipulations
        */
        /**
         *
         */
        LevelEditr.prototype.setMapName = function () {
            var name = this.getMapName(), map = this.getMapObject();
            if (map && map.name !== name) {
                map.name = name;
                this.display.namer.value = name;
                this.setTextareaValue(this.stringifySmart(map), true);
                this.GameStarter.ItemsHolder.setItem("world", name);
            }
        };
        /**
         *
         *
         * @param {Boolean} fromGui   Whether this is from the MapSettings section
         *                            of the GUI (true), or from the Raw JSON
         *                            section (false).
         */
        LevelEditr.prototype.setMapTime = function (fromGui) {
            var map = this.getMapObject(), time;
            if (!map) {
                return;
            }
            if (fromGui) {
                time = Number(this.display.sections.MapSettings.Time.value);
                map.time = time;
            }
            else {
                time = map.time;
                this.display.sections.MapSettings.Time.value = time.toString();
            }
            this.setTextareaValue(this.stringifySmart(map), true);
            this.GameStarter.ItemsHolder.setItem("time", time);
            this.GameStarter.TimeHandler.cancelAllEvents();
        };
        /**
         *
         *
         * @param {Boolean} fromGui   Whether this is from the MapSettings section
         *                            of the GUI (true), or from the Raw JSON
         *                            section (false).
         */
        LevelEditr.prototype.setMapSetting = function (fromGui, event) {
            var map = this.getMapObject(), area, setting;
            if (!map) {
                return;
            }
            area = this.getCurrentAreaObject(map);
            if (fromGui) {
                setting = this.display.sections.MapSettings.Setting.Primary.value;
                if (this.display.sections.MapSettings.Setting.Secondary.value) {
                    setting += " " + this.display.sections.MapSettings.Setting.Secondary.value;
                }
                if (this.display.sections.MapSettings.Setting.Tertiary.value) {
                    setting += " " + this.display.sections.MapSettings.Setting.Tertiary.value;
                }
                area.setting = setting;
            }
            else {
                setting = area.setting.split(" ");
                this.display.sections.MapSettings.Setting.Primary.value = setting[0];
                this.display.sections.MapSettings.Setting.Secondary.value = setting[1];
                this.display.sections.MapSettings.Setting.Tertiary.value = setting[2];
            }
            this.setTextareaValue(this.stringifySmart(map), true);
            this.setDisplayMap(true);
            this.resetCurrentThings(event);
        };
        /**
         *
         */
        LevelEditr.prototype.setLocationArea = function () {
            var map = this.getMapObject(), location;
            if (!map) {
                return;
            }
            location = this.getCurrentLocationObject(map);
            location.area = this.getCurrentArea();
            this.setTextareaValue(this.stringifySmart(map), true);
            this.setDisplayMap(true);
        };
        /**
         *
         *
         * @param {Boolean} fromGui   Whether this is from the MapSettings section
         *                            of the GUI (true), or from the Raw JSON
         *                            section (false).
         */
        LevelEditr.prototype.setMapEntry = function (fromGui) {
            var map = this.getMapObject(), location, entry;
            if (!map) {
                return;
            }
            location = this.getCurrentLocationObject(map);
            if (fromGui) {
                entry = this.display.sections.MapSettings.Entry.value;
                location.entry = entry;
            }
            else {
                this.display.sections.MapSettings.Entry.value = entry;
            }
            this.setTextareaValue(this.stringifySmart(map), true);
            this.setDisplayMap(true);
        };
        /**
         *
         */
        LevelEditr.prototype.setCurrentLocation = function () {
            var map = this.getMapObject(), location;
            if (!map) {
                return;
            }
            location = this.getCurrentLocationObject(map);
            this.display.sections.MapSettings.Area.value = location.area
                ? location.area.toString() : "0";
            this.setTextareaValue(this.stringifySmart(map), true);
            this.setDisplayMap(true);
        };
        /**
         *
         */
        LevelEditr.prototype.addLocationToMap = function () {
            var name = this.display.sections.MapSettings.Location.options.length.toString(), map = this.getMapObject();
            if (!map) {
                return;
            }
            map.locations[name] = {
                "entry": this.mapEntrances[0]
            };
            this.resetAllVisualOptionSelects("VisualOptionLocation", Object.keys(map.locations));
            this.setTextareaValue(this.stringifySmart(map), true);
            this.setDisplayMap(true);
        };
        /**
         *
         */
        LevelEditr.prototype.addAreaToMap = function () {
            var name = this.display.sections.MapSettings.Area.options.length.toString(), map = this.getMapObject();
            if (!map) {
                return;
            }
            map.areas[name] = {
                "setting": this.mapSettingDefault,
                "creation": []
            };
            this.resetAllVisualOptionSelects("VisualOptionArea", Object.keys(map.areas));
            this.setTextareaValue(this.stringifySmart(map), true);
            this.setDisplayMap(true);
        };
        /**
         *
         */
        LevelEditr.prototype.resetAllVisualOptionSelects = function (className, options) {
            var map = this.getMapObject(), elements = this.display.container.getElementsByClassName(className), attributes = {
                "children": options.map(function (option) {
                    return new Option(option, option);
                })
            }, element, value, i;
            if (!map) {
                return;
            }
            for (i = 0; i < elements.length; i += 1) {
                element = elements[i];
                value = element.value;
                element.textContent = "";
                this.GameStarter.proliferateElement(element, attributes);
                element.value = value;
            }
        };
        LevelEditr.prototype.getMapObject = function () {
            var map;
            try {
                map = this.parseSmart(this.display.stringer.textarea.value);
                this.display.stringer.messenger.textContent = "";
                this.display.namer.value = map.name || this.mapNameDefault;
            }
            catch (error) {
                this.setSectionJSON();
                this.display.stringer.messenger.textContent = error.message;
            }
            return map;
        };
        LevelEditr.prototype.getMapObjectAndTry = function (event) {
            var mapName = this.getMapName() + "::Temporary", mapRaw = this.getMapObject();
            if (!mapRaw) {
                return;
            }
            try {
                this.GameStarter.MapsCreator.storeMap(mapName, mapRaw);
                this.GameStarter.MapsCreator.getMap(mapName);
                this.setDisplayMap(true);
            }
            catch (error) {
                this.display.stringer.messenger.textContent = error.message;
            }
            if (event) {
                event.stopPropagation();
            }
        };
        /**
         *
         */
        LevelEditr.prototype.getCurrentArea = function () {
            return this.display.sections.MapSettings.Area.value;
        };
        /**
         *
         */
        LevelEditr.prototype.getCurrentAreaObject = function (map) {
            if (map === void 0) { map = this.getMapObject(); }
            var area = map.locations[this.getCurrentLocation()].area;
            return map.areas[area ? area.toString() : "0"];
        };
        /**
         *
         */
        LevelEditr.prototype.getCurrentLocation = function () {
            return this.display.sections.MapSettings.Location.value;
        };
        /**
         *
         */
        LevelEditr.prototype.getCurrentLocationObject = function (map) {
            return map.locations[this.getCurrentLocation()];
        };
        /**
         *
         */
        LevelEditr.prototype.addMapCreationThing = function (x, y) {
            var mapObject = this.getMapObject(), thingRaw = this.GameStarter.proliferate({
                "thing": this.currentTitle,
                "x": this.getNormalizedX(x) + (this.GameStarter.MapScreener.left / this.GameStarter.unitsize),
                "y": this.getNormalizedY(y)
            }, this.currentArgs);
            if (!mapObject) {
                return false;
            }
            mapObject.areas[this.getCurrentArea()].creation.push(thingRaw);
            this.setTextareaValue(this.stringifySmart(mapObject), true);
            return true;
        };
        LevelEditr.prototype.addMapCreationMacro = function (x, y) {
            var mapObject = this.getMapObject(), macroRaw = this.GameStarter.proliferate({
                "macro": this.currentTitle,
                "x": this.getNormalizedX(x) + (this.GameStarter.MapScreener.left / this.GameStarter.unitsize),
                "y": this.getNormalizedY(y)
            }, this.generateCurrentArgs());
            if (!mapObject) {
                return false;
            }
            mapObject.areas[this.getCurrentArea()].creation.push(macroRaw);
            this.setTextareaValue(this.stringifySmart(mapObject), true);
            return true;
        };
        /* HTML manipulations
        */
        LevelEditr.prototype.resetDisplay = function () {
            this.display = {
                "container": this.GameStarter.createElement("div", {
                    "className": "LevelEditor",
                    "onclick": this.cancelEvent.bind(this),
                    "ondragenter": this.handleDragEnter.bind(this),
                    "ondragover": this.handleDragOver.bind(this),
                    "ondrop": this.handleDragDrop.bind(this)
                }),
                "scrollers": {},
                "stringer": {},
                "sections": {
                    "ClickToPlace": {},
                    "MapSettings": {
                        "Setting": {}
                    },
                    "buttons": {
                        "ClickToPlace": {}
                    }
                }
            };
            this.resetDisplayScrollers();
            this.resetDisplayGui();
            this.resetDisplayHead();
            this.resetDisplaySectionChoosers();
            this.resetDisplayOptionsList();
            this.resetDisplayMapSettings();
            setTimeout(this.resetDisplayThinCheck.bind(this));
        };
        LevelEditr.prototype.resetDisplayThinCheck = function () {
            var width = this.display.gui.clientWidth;
            if (width <= 385) {
                this.display.container.className += " thin";
            }
            else if (width >= 560) {
                this.display.container.className += " thick";
            }
        };
        LevelEditr.prototype.resetDisplayGui = function () {
            this.display.gui = this.GameStarter.createElement("div", {
                "className": "EditorGui"
            });
            this.display.container.appendChild(this.display.gui);
        };
        LevelEditr.prototype.resetDisplayScrollers = function () {
            this.display.scrollers = {
                "left": this.GameStarter.createElement("div", {
                    "className": "EditorScroller EditorScrollerLeft",
                    "onmousedown": this.onMouseDownScrolling.bind(this, -this.GameStarter.unitsize * 2),
                    "onmouseup": this.onMouseUpScrolling.bind(this),
                    "onmouseout": this.onMouseUpScrolling.bind(this),
                    "onclick": this.cancelEvent.bind(this),
                    "innerText": "<",
                    "style": {
                        "opacity": .14
                    }
                }),
                "right": this.GameStarter.createElement("div", {
                    "className": "EditorScroller EditorScrollerRight",
                    "onmousedown": this.onMouseDownScrolling.bind(this, this.GameStarter.unitsize * 2),
                    "onmouseup": this.onMouseUpScrolling.bind(this),
                    "onmouseout": this.onMouseUpScrolling.bind(this),
                    "onclick": this.cancelEvent.bind(this),
                    "innerText": ">"
                }),
                "container": this.GameStarter.createElement("div", {
                    "className": "EditorScrollers",
                    "onmousemove": this.onMouseMoveEditing.bind(this),
                    "onclick": this.onClickEditingThing.bind(this)
                })
            };
            this.display.scrollers.container.appendChild(this.display.scrollers.left);
            this.display.scrollers.container.appendChild(this.display.scrollers.right);
            this.display.container.appendChild(this.display.scrollers.container);
        };
        LevelEditr.prototype.resetDisplayHead = function () {
            this.display.minimizer = this.GameStarter.createElement("div", {
                "className": "EditorHeadButton EditorMinimizer",
                "onclick": this.minimize.bind(this),
                "textContent": "-"
            });
            this.display.head = this.GameStarter.createElement("div", {
                "className": "EditorHead",
                "children": [
                    this.GameStarter.createElement("div", {
                        "className": "EditorNameContainer",
                        "children": [
                            this.display.namer = this.GameStarter.createElement("input", {
                                "className": "EditorNameInput",
                                "type": "text",
                                "placeholder": this.mapNameDefault,
                                "value": this.mapNameDefault,
                                "onkeyup": this.setMapName.bind(this),
                                "onchange": this.setMapName.bind(this)
                            })
                        ]
                    }),
                    this.display.minimizer,
                    this.GameStarter.createElement("div", {
                        "className": "EditorHeadButton EditorCloser",
                        "textContent": "X",
                        "onclick": this.disable.bind(this)
                    })
                ]
            });
            this.display.gui.appendChild(this.display.head);
        };
        LevelEditr.prototype.resetDisplaySectionChoosers = function () {
            var sectionChoosers = this.GameStarter.createElement("div", {
                "className": "EditorSectionChoosers",
                "onclick": this.cancelEvent.bind(this),
                "children": [
                    this.display.sections.buttons.ClickToPlace.container = this.GameStarter.createElement("div", {
                        "className": "EditorMenuOption EditorSectionChooser EditorMenuOptionThird",
                        "style": {
                            "background": "white"
                        },
                        "textContent": "Visual",
                        "onclick": this.setSectionClickToPlace.bind(this)
                    }),
                    this.display.sections.buttons.MapSettings = this.GameStarter.createElement("div", {
                        "className": "EditorMenuOption EditorSectionChooser EditorMenuOptionThird",
                        "style": {
                            "background": "gray"
                        },
                        "textContent": "Map",
                        "onclick": this.setSectionMapSettings.bind(this)
                    }),
                    this.display.sections.buttons.JSON = this.GameStarter.createElement("div", {
                        "className": "EditorMenuOption EditorSectionChooser EditorMenuOptionThird",
                        "style": {
                            "background": "gray"
                        },
                        "textContent": "JSON",
                        "onclick": this.setSectionJSON.bind(this)
                    })
                ]
            });
            this.display.gui.appendChild(sectionChoosers);
        };
        LevelEditr.prototype.resetDisplayOptionsList = function () {
            this.display.sections.ClickToPlace.container = this.GameStarter.createElement("div", {
                "className": "EditorOptionsList EditorSectionMain",
                "onclick": this.cancelEvent.bind(this)
            });
            this.resetDisplayOptionsListSubOptionsMenu();
            this.resetDisplayOptionsListSubOptions();
            this.display.gui.appendChild(this.display.sections.ClickToPlace.container);
        };
        LevelEditr.prototype.resetDisplayOptionsListSubOptionsMenu = function () {
            var holder = this.GameStarter.createElement("div", {
                "className": "EditorSubOptionsListsMenu"
            });
            this.display.sections.buttons.ClickToPlace.Things = this.GameStarter.createElement("div", {
                "className": "EditorMenuOption EditorSubOptionsListChooser EditorMenuOptionHalf",
                "textContent": "Things",
                "onclick": this.setSectionClickToPlaceThings.bind(this),
                "style": {
                    "background": "#CCC"
                }
            });
            this.display.sections.buttons.ClickToPlace.Macros = this.GameStarter.createElement("div", {
                "className": "EditorMenuOption EditorSubOptionsListChooser EditorMenuOptionHalf",
                "textContent": "Macros",
                "onclick": this.setSectionClickToPlaceMacros.bind(this),
                "style": {
                    "background": "#777"
                }
            });
            holder.appendChild(this.display.sections.buttons.ClickToPlace.Things);
            holder.appendChild(this.display.sections.buttons.ClickToPlace.Macros);
            this.display.sections.ClickToPlace.container.appendChild(holder);
        };
        LevelEditr.prototype.resetDisplayMapSettings = function () {
            this.display.sections.MapSettings.container = this.GameStarter.createElement("div", {
                "className": "EditorMapSettings EditorSectionMain",
                "onclick": this.cancelEvent.bind(this),
                "style": {
                    "display": "none"
                },
                "children": [
                    this.GameStarter.createElement("div", {
                        "className": "EditorMenuOption",
                        "textContent": "+ Add Area",
                        "onclick": this.addAreaToMap.bind(this)
                    }),
                    this.GameStarter.createElement("div", {
                        "className": "EditorMenuOption",
                        "textContent": "+ Add Location",
                        "onclick": this.addLocationToMap.bind(this)
                    })
                ]
            });
            this.resetDisplayMapSettingsCurrent();
            this.resetDisplayMapSettingsMap();
            this.resetDisplayMapSettingsArea();
            this.resetDisplayMapSettingsLocation();
            this.resetDisplayJSON();
            this.resetDisplayVisualContainers();
            this.resetDisplayButtons();
            this.display.gui.appendChild(this.display.sections.MapSettings.container);
        };
        LevelEditr.prototype.resetDisplayMapSettingsCurrent = function () {
            this.display.sections.MapSettings.container.appendChild(this.GameStarter.createElement("div", {
                "className": "EditorMapSettingsSubGroup",
                "children": [
                    this.GameStarter.createElement("label", {
                        "textContent": "Current Location"
                    }),
                    this.display.sections.MapSettings.Location = this.createSelect(["0"], {
                        "className": "VisualOptionLocation",
                        "onchange": this.setCurrentLocation.bind(this)
                    })
                ]
            }));
        };
        LevelEditr.prototype.resetDisplayMapSettingsMap = function () {
            this.display.sections.MapSettings.container.appendChild(this.GameStarter.createElement("div", {
                "className": "EditorMapSettingsGroup",
                "children": [
                    this.GameStarter.createElement("h4", {
                        "textContent": "Map"
                    }),
                    this.GameStarter.createElement("div", {
                        "className": "EditorMapSettingsSubGroup",
                        "children": [
                            this.GameStarter.createElement("label", {
                                "className": "EditorMapSettingsLabel",
                                "textContent": "Time"
                            }),
                            this.display.sections.MapSettings.Time = this.createSelect([
                                "100", "200", "300", "400", "500", "1000", "Infinity"
                            ], {
                                "value": this.mapTimeDefault.toString(),
                                "onchange": this.setMapTime.bind(this, true)
                            })
                        ]
                    })
                ]
            }));
        };
        LevelEditr.prototype.resetDisplayMapSettingsArea = function () {
            this.display.sections.MapSettings.container.appendChild(this.GameStarter.createElement("div", {
                "className": "EditorMapSettingsGroup",
                "children": [
                    this.GameStarter.createElement("h4", {
                        "textContent": "Area"
                    }),
                    this.GameStarter.createElement("div", {
                        "className": "EditorMapSettingsSubGroup",
                        "children": [
                            this.GameStarter.createElement("label", {
                                "textContent": "Setting"
                            }),
                            this.display.sections.MapSettings.Setting.Primary = this.createSelect([
                                "Overworld", "Underworld", "Underwater", "Castle"
                            ], {
                                "onchange": this.setMapSetting.bind(this, true)
                            }),
                            this.display.sections.MapSettings.Setting.Secondary = this.createSelect([
                                "", "Night", "Underwater", "Alt"
                            ], {
                                "onchange": this.setMapSetting.bind(this, true)
                            }),
                            this.display.sections.MapSettings.Setting.Tertiary = this.createSelect([
                                "", "Night", "Underwater", "Alt"
                            ], {
                                "onchange": this.setMapSetting.bind(this, true)
                            })
                        ]
                    })
                ]
            }));
        };
        LevelEditr.prototype.resetDisplayMapSettingsLocation = function () {
            this.display.sections.MapSettings.container.appendChild(this.GameStarter.createElement("div", {
                "className": "EditorMapSettingsGroup",
                "children": [
                    this.GameStarter.createElement("h4", {
                        "textContent": "Location"
                    }),
                    this.GameStarter.createElement("div", {
                        "className": "EditorMapSettingsSubGroup",
                        "children": [
                            this.GameStarter.createElement("label", {
                                "textContent": "Area"
                            }),
                            this.display.sections.MapSettings.Area = this.createSelect(["0"], {
                                "className": "VisualOptionArea",
                                "onchange": this.setLocationArea.bind(this, true)
                            })
                        ]
                    }),
                    this.GameStarter.createElement("div", {
                        "className": "EditorMapSettingsSubGroup",
                        "children": [
                            this.GameStarter.createElement("label", {
                                "textContent": "Entrance"
                            }),
                            this.display.sections.MapSettings.Entry = this.createSelect(this.mapEntrances, {
                                "onchange": this.setMapEntry.bind(this, true)
                            })
                        ]
                    })
                ]
            }));
        };
        LevelEditr.prototype.resetDisplayJSON = function () {
            this.display.sections.JSON = this.GameStarter.createElement("div", {
                "className": "EditorJSON EditorSectionMain",
                "onclick": this.cancelEvent.bind(this),
                "style": {
                    "display": "none"
                },
                "children": [
                    this.display.stringer.textarea = this.GameStarter.createElement("textarea", {
                        "className": "EditorJSONInput",
                        "spellcheck": false,
                        "onkeyup": this.getMapObjectAndTry.bind(this),
                        "onchange": this.getMapObjectAndTry.bind(this),
                        "onkeydown": function (event) {
                            event.stopPropagation();
                        }
                    }),
                    this.display.stringer.messenger = this.GameStarter.createElement("div", {
                        "className": "EditorJSONInfo"
                    })
                ]
            });
            this.display.gui.appendChild(this.display.sections.JSON);
        };
        LevelEditr.prototype.resetDisplayVisualContainers = function () {
            this.display.sections.ClickToPlace.VisualOptions = this.GameStarter.createElement("div", {
                "textContent": "Click an icon to view options.",
                "className": "EditorVisualOptions",
                "onclick": this.cancelEvent.bind(this)
            });
            this.display.gui.appendChild(this.display.sections.ClickToPlace.VisualOptions);
        };
        LevelEditr.prototype.resetDisplayButtons = function () {
            var scope = this;
            this.display.gui.appendChild(this.GameStarter.createElement("div", {
                "className": "EditorMenu",
                "onclick": this.cancelEvent.bind(this),
                "children": (function (actions) {
                    return Object.keys(actions).map(function (key) {
                        return scope.GameStarter.createElement("div", {
                            "className": "EditorMenuOption EditorMenuOptionFifth EditorMenuOption-" + key,
                            "textContent": key,
                            "onclick": actions[key][0].bind(scope),
                            "children": actions[key][1]
                        });
                    });
                })({
                    "Build": [this.startBuilding.bind(this)],
                    "Play": [this.startPlaying.bind(this)],
                    "Save": [this.downloadCurrentJSON.bind(this)],
                    "Load": [
                        this.loadCurrentJSON.bind(this),
                        this.display.inputDummy = this.GameStarter.createElement("input", {
                            "type": "file",
                            "style": {
                                "display": "none"
                            },
                            "onchange": this.handleUploadStart.bind(this)
                        })
                    ],
                    "Reset": [this.resetDisplayMap.bind(this)]
                })
            }));
        };
        /**
         * Adds the Things and Macros menus to the EditorOptionsList container in
         * the main GUI.
         */
        LevelEditr.prototype.resetDisplayOptionsListSubOptions = function () {
            this.resetDisplayOptionsListSubOptionsThings();
            this.resetDisplayOptionsListSubOptionsMacros();
        };
        /**
         * Creates the menu of icons for Things, with a dropdown select to choose
         * the groupings being displayed. These icons, when clicked, trigger
         * this.onThingIconClick on the Thing's title.
         */
        LevelEditr.prototype.resetDisplayOptionsListSubOptionsThings = function () {
            var scope = this, 
            // Without these references, tslint complaints the private functions aren't used
            argumentGetter = this.getPrethingSizeArguments.bind(this), clicker = this.onThingIconClick;
            if (this.display.sections.ClickToPlace.Things) {
                this.display.sections.ClickToPlace.container.removeChild(this.display.sections.ClickToPlace.Things);
            }
            this.display.sections.ClickToPlace.Things = this.GameStarter.createElement("div", {
                "className": "EditorSectionSecondary EditorOptions EditorOptions-Things",
                "style": {
                    "display": "block"
                },
                "children": (function () {
                    var selectedIndex = 0, containers = Object.keys(scope.prethings).map(function (key) {
                        var prethings = scope.prethings[key], children = Object.keys(prethings).map(function (title) {
                            var prething = prethings[title], thing = scope.GameStarter.ObjectMaker.make(title, argumentGetter(prething)), container = scope.GameStarter.createElement("div", {
                                "className": "EditorListOption",
                                "options": scope.prethings[key][title].options,
                                "children": [thing.canvas],
                                "onclick": clicker.bind(scope, title)
                            }), sizeMax = 70, widthThing = thing.width * scope.GameStarter.unitsize, heightThing = thing.height * scope.GameStarter.unitsize, widthDiff = (sizeMax - widthThing) / 2, heightDiff = (sizeMax - heightThing) / 2;
                            container.setAttribute("name", title);
                            thing.canvas.style.top = heightDiff + "px";
                            thing.canvas.style.right = widthDiff + "px";
                            thing.canvas.style.bottom = heightDiff + "px";
                            thing.canvas.style.left = widthDiff + "px";
                            scope.GameStarter.PixelDrawer.setThingSprite(thing);
                            return container;
                        });
                        return scope.GameStarter.createElement("div", {
                            "className": "EditorOptionContainer",
                            "style": {
                                "display": "none"
                            },
                            "children": children
                        });
                    }), switcher = scope.createSelect(Object.keys(scope.prethings), {
                        "className": "EditorOptionContainerSwitchers",
                        "onchange": function () {
                            containers[selectedIndex + 1].style.display = "none";
                            containers[switcher.selectedIndex + 1].style.display = "block";
                            selectedIndex = switcher.selectedIndex;
                        }
                    });
                    containers[0].style.display = "block";
                    containers.unshift(switcher);
                    return containers;
                })()
            });
            this.display.sections.ClickToPlace.container.appendChild(this.display.sections.ClickToPlace.Things);
        };
        /**
         * Creates the menu of (text) icons for Macros. When clicked, these trigger
         * this.onMacroIconClick on the macro's title, description, and options.
         */
        LevelEditr.prototype.resetDisplayOptionsListSubOptionsMacros = function () {
            var scope = this;
            if (this.display.sections.ClickToPlace.Macros) {
                this.display.sections.ClickToPlace.container.removeChild(this.display.sections.ClickToPlace.Macros);
            }
            scope.display.sections.ClickToPlace.Macros = scope.GameStarter.createElement("div", {
                "className": "EditorSectionSecondary EditorOptions EditorOptions-Macros",
                "style": {
                    "display": "none"
                },
                "children": Object.keys(scope.macros).map(function (key) {
                    var macro = scope.macros[key];
                    return scope.GameStarter.createElement("div", {
                        "className": "EditorOptionContainer",
                        "children": [
                            scope.GameStarter.createElement("div", {
                                "className": "EditorOptionTitle EditorMenuOption",
                                "textContent": key,
                                "onclick": scope.onMacroIconClick.bind(scope, key, macro.description, macro.options)
                            })
                        ]
                    });
                })
            });
            this.display.sections.ClickToPlace.container.appendChild(this.display.sections.ClickToPlace.Macros);
        };
        /**
         *
         */
        LevelEditr.prototype.setSectionClickToPlace = function () {
            this.display.sections.ClickToPlace.VisualOptions.style.display = "block";
            this.display.sections.ClickToPlace.container.style.display = "block";
            this.display.sections.MapSettings.container.style.display = "none";
            this.display.sections.JSON.style.display = "none";
            this.display.sections.buttons.ClickToPlace.container.style.backgroundColor = "white";
            this.display.sections.buttons.MapSettings.style.background = "gray";
            this.display.sections.buttons.JSON.style.background = "gray";
            if (this.currentClickMode !== "Thing" && this.currentClickMode !== "Macro") {
                this.display.sections.buttons.ClickToPlace.Things.click();
            }
        };
        /**
         *
         */
        LevelEditr.prototype.setSectionMapSettings = function (event) {
            this.setCurrentClickMode("Map", event);
            this.display.sections.ClickToPlace.VisualOptions.style.display = "none";
            this.display.sections.ClickToPlace.container.style.display = "none";
            this.display.sections.MapSettings.container.style.display = "block";
            this.display.sections.JSON.style.display = "none";
            this.display.sections.buttons.ClickToPlace.container.style.background = "gray";
            this.display.sections.buttons.MapSettings.style.background = "white";
            this.display.sections.buttons.JSON.style.background = "gray";
        };
        /**
         *
         */
        LevelEditr.prototype.setSectionJSON = function (event) {
            this.setCurrentClickMode("JSON", event);
            this.display.sections.ClickToPlace.VisualOptions.style.display = "none";
            this.display.sections.ClickToPlace.container.style.display = "none";
            this.display.sections.MapSettings.container.style.display = "none";
            this.display.sections.JSON.style.display = "block";
            this.display.sections.buttons.ClickToPlace.container.style.background = "gray";
            this.display.sections.buttons.MapSettings.style.background = "gray";
            this.display.sections.buttons.JSON.style.background = "white";
        };
        /**
         *
         */
        LevelEditr.prototype.setSectionClickToPlaceThings = function (event) {
            this.setCurrentClickMode("Thing", event);
            this.display.container.onclick = this.onClickEditingThing.bind(this);
            this.display.scrollers.container.onclick = this.onClickEditingThing.bind(this);
            this.display.sections.ClickToPlace.VisualOptions.style.display = "block";
            this.display.sections.ClickToPlace.Things.style.display = "block";
            this.display.sections.ClickToPlace.Macros.style.display = "none";
            this.display.sections.buttons.ClickToPlace.Things.style.background = "#CCC";
            this.display.sections.buttons.ClickToPlace.Macros.style.background = "#777";
        };
        /**
         *
         */
        LevelEditr.prototype.setSectionClickToPlaceMacros = function (event) {
            this.setCurrentClickMode("Macro", event);
            this.display.container.onclick = this.onClickEditingMacro.bind(this);
            this.display.scrollers.container.onclick = this.onClickEditingMacro.bind(this);
            this.display.sections.ClickToPlace.VisualOptions.style.display = "block";
            this.display.sections.ClickToPlace.Things.style.display = "none";
            this.display.sections.ClickToPlace.Macros.style.display = "block";
            this.display.sections.buttons.ClickToPlace.Things.style.background = "#777";
            this.display.sections.buttons.ClickToPlace.Macros.style.background = "#CCC";
        };
        /**
         *
         */
        LevelEditr.prototype.setTextareaValue = function (value, doBeautify) {
            if (doBeautify === void 0) { doBeautify = false; }
            if (doBeautify) {
                this.display.stringer.textarea.value = this.beautifier(value);
            }
            else {
                this.display.stringer.textarea.value = value;
            }
        };
        /**
         *
         */
        LevelEditr.prototype.beautifyTextareaValue = function () {
            this.display.stringer.textarea.value = this.beautifier(this.display.stringer.textarea.value);
        };
        /**
         *
         */
        LevelEditr.prototype.setVisualOptions = function (name, description, options) {
            var visual = this.display.sections.ClickToPlace.VisualOptions, 
            // Without clicker, tslint complains createVisualOption isn't being used...
            clicker = this.createVisualOption.bind(this), scope = this;
            visual.textContent = "";
            visual.appendChild(this.GameStarter.createElement("h3", {
                "className": "VisualOptionName",
                "textContent": name.replace(/([A-Z][a-z])/g, " $1")
            }));
            if (description) {
                visual.appendChild(this.GameStarter.createElement("div", {
                    "className": "VisualOptionDescription",
                    "textContent": description
                }));
            }
            if (options) {
                visual.appendChild(scope.GameStarter.createElement("div", {
                    "className": "VisualOptionsList",
                    "children": Object.keys(options).map(function (key) {
                        return scope.GameStarter.createElement("div", {
                            "className": "VisualOption",
                            "children": [
                                scope.GameStarter.createElement("div", {
                                    "className": "VisualOptionLabel",
                                    "textContent": key
                                }),
                                clicker(options[key])
                            ]
                        });
                    })
                }));
            }
        };
        /**
         *
         */
        LevelEditr.prototype.createVisualOption = function (optionRaw) {
            var option = this.createVisualOptionObject(optionRaw);
            switch (option.type) {
                case "Boolean":
                    return this.createVisualOptionBoolean();
                case "Number":
                    return this.createVisualOptionNumber(option);
                case "Select":
                    return this.createVisualOptionSelect(option);
                case "String":
                    return this.createVisualOptionString(option);
                case "Location":
                    return this.createVisualOptionLocation(option);
                case "Area":
                    return this.createVisualOptionArea(option);
                case "Everything":
                    return this.createVisualOptionEverything(option);
                default:
                    throw new Error("Unknown type requested: '" + option.type + "'.");
            }
        };
        /**
         *
         */
        LevelEditr.prototype.createVisualOptionObject = function (optionRaw) {
            var option;
            // If the option isn't already an Object, make it one
            switch (optionRaw.constructor) {
                case Number:
                    option = {
                        "type": "Number",
                        "mod": optionRaw
                    };
                    break;
                case String:
                    option = {
                        "type": optionRaw
                    };
                    break;
                case Array:
                    option = {
                        "type": "Select",
                        "options": optionRaw
                    };
                    break;
                default:
                    option = optionRaw;
            }
            return option;
        };
        /**
         *
         */
        LevelEditr.prototype.createVisualOptionBoolean = function () {
            var select = this.createSelect([
                "false", "true"
            ], {
                "className": "VisualOptionValue",
                "onkeyup": this.setCurrentArgs.bind(this),
                "onchange": this.setCurrentArgs.bind(this)
            });
            select.setAttribute("data:type", "Boolean");
            return select;
        };
        /**
         *
         */
        LevelEditr.prototype.createVisualOptionNumber = function (option) {
            var scope = this;
            return this.GameStarter.createElement("div", {
                "className": "VisualOptionHolder",
                "children": (function () {
                    var modReal = option.mod || 1, input = scope.GameStarter.createElement("input", {
                        "type": "Number",
                        "data:type": "Number",
                        "value": (option.value === undefined) ? 1 : option.value,
                        "className": "VisualOptionValue modReal" + modReal,
                        "onkeyup": scope.setCurrentArgs.bind(scope),
                        "onchange": scope.setCurrentArgs.bind(scope)
                    }), recommendation = modReal > 1
                        && scope.GameStarter.createElement("div", {
                            "className": "VisualOptionRecommendation",
                            "textContent": "x" + option.mod
                        }), children = [input];
                    input.setAttribute("data:mod", modReal.toString());
                    input.setAttribute("data:type", "Number");
                    input.setAttribute("typeReal", "Number");
                    if (option.Infinite) {
                        var valueOld = undefined, infinite = scope.createSelect([
                            "Number", "Infinite"
                        ], {
                            "className": "VisualOptionInfiniter",
                            "onchange": function (event) {
                                if (infinite.value === "Number") {
                                    input.type = "Number";
                                    input.disabled = false;
                                    input.style.display = "";
                                    if (recommendation) {
                                        recommendation.style.display = "";
                                    }
                                    input.value = valueOld;
                                    input.onchange(event);
                                }
                                else {
                                    input.type = "Text";
                                    input.disabled = true;
                                    input.style.display = "none";
                                    if (recommendation) {
                                        recommendation.style.display = "none";
                                    }
                                    valueOld = input.value;
                                    input.value = "Infinity";
                                    input.onchange(event);
                                }
                            }
                        });
                        if (option.value === Infinity) {
                            infinite.value = "Infinite";
                            infinite.onchange(undefined);
                        }
                        children.push(infinite);
                    }
                    if (recommendation) {
                        children.push(recommendation);
                    }
                    return children;
                })()
            });
        };
        /**
         *
         */
        LevelEditr.prototype.createVisualOptionSelect = function (option) {
            var select = this.createSelect(option.options, {
                "className": "VisualOptionValue",
                "data:type": "Select",
                "onkeyup": this.setCurrentArgs.bind(this),
                "onchange": this.setCurrentArgs.bind(this)
            });
            select.setAttribute("data:type", "Select");
            return select;
        };
        /**
         *
         */
        LevelEditr.prototype.createVisualOptionString = function (option) {
            var select = this.createSelect(option.options, {
                "className": "VisualOptionValue",
                "data:type": "String",
                "onkeyup": this.setCurrentArgs.bind(this),
                "onchange": this.setCurrentArgs.bind(this)
            });
            select.setAttribute("data:type", "String");
            return select;
        };
        /**
         *
         */
        LevelEditr.prototype.createVisualOptionLocation = function (option) {
            var map = this.getMapObject(), locations, select;
            if (!map) {
                return this.GameStarter.createElement("div", {
                    "className": "VisualOptionValue VisualOptionLocation EditorComplaint",
                    "text": "Fix map compilation to get locations!"
                });
            }
            locations = Object.keys(map.locations);
            locations.unshift(this.keyUndefined);
            select = this.createSelect(locations, {
                "className": "VisualOptionValue VisualOptionLocation",
                "data-type": "String",
                "onkeyup": this.setCurrentArgs.bind(this),
                "onchange": this.setCurrentArgs.bind(this)
            });
            select.setAttribute("data-type", "String");
            return select;
        };
        /**
         *
         */
        LevelEditr.prototype.createVisualOptionArea = function (option) {
            var map = this.getMapObject(), areas, select;
            if (!map) {
                return this.GameStarter.createElement("div", {
                    "className": "VisualOptionValue VisualOptionArea EditorComplaint",
                    "text": "Fix map compilation to get areas!"
                });
            }
            areas = Object.keys(map.areas);
            areas.unshift(this.keyUndefined);
            select = this.createSelect(areas, {
                "className": "VisualOptionValue VisualOptionArea",
                "data-type": "String",
                "onkeyup": this.setCurrentArgs.bind(this),
                "onchange": this.setCurrentArgs.bind(this)
            });
            select.setAttribute("data-type", "String");
            return select;
        };
        /**
         *
         */
        LevelEditr.prototype.createVisualOptionEverything = function (option) {
            var select = this.createSelect(Object.keys(this.things), {
                "className": "VisualOptionValue VisualOptionEverything",
                "data-type": "String",
                "onkeyup": this.setCurrentArgs.bind(this),
                "onchange": this.setCurrentArgs.bind(this)
            });
            select.setAttribute("data-type", "String");
            return select;
        };
        /**
         *
         */
        LevelEditr.prototype.resetDisplayMap = function () {
            this.setTextareaValue(this.stringifySmart(this.mapDefault), true);
            this.setDisplayMap(true);
        };
        /**
         *
         */
        LevelEditr.prototype.setDisplayMap = function (doDisableThings) {
            var value = this.display.stringer.textarea.value, mapName = this.getMapName(), testObject, map;
            try {
                testObject = this.parseSmart(value);
                this.setTextareaValue(this.display.stringer.textarea.value);
            }
            catch (error) {
                this.setSectionJSON();
                this.display.stringer.messenger.textContent = error.message;
                return;
            }
            try {
                this.GameStarter.MapsCreator.storeMap(mapName, testObject);
                map = this.GameStarter.MapsCreator.getMap(mapName);
            }
            catch (error) {
                this.setSectionJSON();
                this.display.stringer.messenger.textContent = error.message;
                return;
            }
            this.display.stringer.messenger.textContent = "";
            this.setTextareaValue(this.display.stringer.textarea.value);
            this.GameStarter.setMap(mapName, this.getCurrentLocation());
            this.resetDisplayOptionsListSubOptionsThings();
            if (doDisableThings) {
                this.disableAllThings();
            }
        };
        /**
         *
         */
        LevelEditr.prototype.getMapName = function () {
            return this.display.namer.value || this.mapNameDefault;
        };
        /* Utility functions
        */
        /**
         *
         */
        LevelEditr.prototype.roundTo = function (num, rounding) {
            return Math.round(num / rounding) * rounding;
        };
        /**
         *
         */
        LevelEditr.prototype.stringifySmart = function (object) {
            if (object === void 0) { object = {}; }
            return JSON.stringify(object, this.jsonReplacerSmart);
        };
        /**
         *
         *
         * @remarks Settings .editor=true informs the area that the player
         *          should respawn upon death without resetting gameplay.
         */
        LevelEditr.prototype.parseSmart = function (text) {
            var map = JSON.parse(text, this.jsonReplacerSmart), areas = map.areas, i;
            for (i in areas) {
                if (areas.hasOwnProperty(i)) {
                    areas[i].editor = true;
                }
            }
            return map;
        };
        /**
         *
         */
        LevelEditr.prototype.jsonReplacerSmart = function (key, value) {
            if (value !== value) {
                return "NaN";
            }
            else if (value === Infinity) {
                return "Infinity";
            }
            else if (value === -Infinity) {
                return "-Infinity";
            }
            else {
                return value;
            }
        };
        /**
         *
         */
        LevelEditr.prototype.disableThing = function (thing, opacity) {
            if (opacity === void 0) { opacity = 1; }
            thing.movement = undefined;
            thing.nofall = true;
            thing.nocollide = true;
            thing.outerok = 2;
            thing.xvel = 0;
            thing.yvel = 0;
            thing.opacity = opacity;
        };
        /**
         *
         */
        LevelEditr.prototype.disableAllThings = function () {
            var scope = this, groups = this.GameStarter.GroupHolder.getGroups(), i;
            for (i in groups) {
                if (groups.hasOwnProperty(i)) {
                    groups[i].forEach(function (thing) {
                        scope.disableThing(thing);
                    });
                }
            }
            this.GameStarter.TimeHandler.cancelAllEvents();
        };
        /**
         *
         */
        LevelEditr.prototype.addThingAndDisableEvents = function (thing, x, y) {
            var left = this.roundTo(x, this.GameStarter.scale), top = this.roundTo(y, this.GameStarter.scale);
            this.GameStarter.addThing(thing, left, top);
            this.disableThing(thing);
            this.GameStarter.TimeHandler.cancelAllEvents();
            if ((thing.hasOwnProperty("hidden") && thing.hidden) || thing.opacity === 0) {
                thing.hidden = false;
                thing.opacity = .35;
            }
        };
        /**
         *
         */
        LevelEditr.prototype.clearAllThings = function () {
            var scope = this, groups = this.GameStarter.GroupHolder.getGroups(), i;
            for (i in groups) {
                if (groups.hasOwnProperty(i)) {
                    groups[i].forEach(function (thing) {
                        scope.GameStarter.killNormal(thing);
                    });
                }
            }
        };
        /**
         *
         */
        LevelEditr.prototype.getNormalizedX = function (raw) {
            return raw / this.GameStarter.unitsize;
        };
        /**
         *
         */
        LevelEditr.prototype.getNormalizedY = function (raw) {
            return this.GameStarter.MapScreener.floor
                - (raw / this.GameStarter.unitsize)
                + this.GameStarter.unitsize * 3; // Why +3?
        };
        /**
         *
         */
        LevelEditr.prototype.getNormalizedThingArguments = function (args) {
            var argsNormal = this.GameStarter.proliferate({}, args);
            if (argsNormal.height === Infinity) {
                argsNormal.height = this.GameStarter.MapScreener.height;
            }
            if (argsNormal.width === Infinity) {
                argsNormal.width = this.GameStarter.MapScreener.width;
            }
            return argsNormal;
        };
        /**
         *
         */
        LevelEditr.prototype.getNormalizedMouseEventCoordinates = function (event, referenceThing) {
            var x = this.roundTo(event.x || event.clientX || 0, this.blocksize), y = this.roundTo(event.y || event.clientY || 0, this.blocksize), prething;
            if (referenceThing) {
                prething = this.things[this.currentTitle];
                if (prething.offsetLeft) {
                    x += prething.offsetLeft * this.GameStarter.unitsize;
                }
                if (prething.offsetTop) {
                    y += prething.offsetTop * this.GameStarter.unitsize;
                }
            }
            return [x, y];
        };
        /**
         *
         */
        LevelEditr.prototype.getPrethingSizeArguments = function (descriptor) {
            var output = {}, width = this.getPrethingSizeArgument(descriptor.width), height = this.getPrethingSizeArgument(descriptor.height);
            if (width) {
                output.width = width;
            }
            if (height) {
                output.height = height;
            }
            return output;
        };
        /**
         *
         */
        LevelEditr.prototype.getPrethingSizeArgument = function (descriptor) {
            if (!descriptor) {
                return undefined;
            }
            if (descriptor.real) {
                return descriptor.real;
            }
            var value = descriptor.value || 1, mod = descriptor.mod || 1;
            if (!isFinite(value)) {
                return mod || 8;
            }
            return value * mod;
        };
        /**
         *
         */
        LevelEditr.prototype.createSelect = function (options, attributes) {
            var select = this.GameStarter.createElement("select", attributes), i;
            for (i = 0; i < options.length; i += 1) {
                select.appendChild(this.GameStarter.createElement("option", {
                    "value": options[i],
                    "textContent": options[i]
                }));
            }
            if (typeof attributes.value !== "undefined") {
                select.value = attributes.value;
            }
            this.applyElementAttributes(select, attributes);
            return select;
        };
        /**
         *
         */
        LevelEditr.prototype.applyElementAttributes = function (element, attributes) {
            var i;
            for (i in attributes) {
                if (attributes.hasOwnProperty(i) && i.indexOf("data:") === 0) {
                    element.setAttribute(i, attributes[i]);
                }
            }
        };
        /**
         *
         */
        LevelEditr.prototype.downloadFile = function (name, content) {
            var link = this.GameStarter.createElement("a", {
                "download": name,
                "href": "data:text/json;charset=utf-8," + encodeURIComponent(content)
            });
            this.display.container.appendChild(link);
            link.click();
            this.display.container.removeChild(link);
            return link;
        };
        /**
         *
         */
        LevelEditr.prototype.killCurrentPreThings = function () {
            for (var i = 0; i < this.currentPreThings.length - 1; i += 1) {
                this.GameStarter.killNormal(this.currentPreThings[i].thing);
            }
        };
        /* File uploading
        */
        /**
         *
         */
        LevelEditr.prototype.handleUploadStart = function (event) {
            var file, reader;
            this.cancelEvent(event);
            if (event && event.dataTransfer) {
                file = event.dataTransfer.files[0];
            }
            else {
                file = this.display.inputDummy.files[0];
                reader = new FileReader();
            }
            if (!file) {
                return;
            }
            reader = new FileReader();
            reader.onloadend = this.handleUploadCompletion.bind(this);
            reader.readAsText(file);
        };
        /**
         *
         */
        LevelEditr.prototype.handleDragEnter = function (event) {
            this.setSectionJSON();
        };
        /**
         *
         */
        LevelEditr.prototype.handleDragOver = function (event) {
            this.cancelEvent(event);
        };
        /**
         *
         */
        LevelEditr.prototype.handleDragDrop = function (event) {
            this.handleUploadStart(event);
        };
        /**
         *
         */
        LevelEditr.prototype.cancelEvent = function (event) {
            if (!event) {
                return;
            }
            if (typeof event.preventDefault === "function") {
                event.preventDefault();
            }
            if (typeof event.stopPropagation === "function") {
                event.stopPropagation();
            }
            event.cancelBubble = true;
        };
        /* Styles
         */
        /*
         *
         */
        LevelEditr.prototype.createPageStyles = function () {
            return {
                ".LevelEditor": {
                    "position": "absolute",
                    "top": "0",
                    "right": "0",
                    "bottom": "0",
                    "left": "0"
                },
                ".LevelEditor h4": {
                    "margin": "14px 0 7px 0"
                },
                ".LevelEditor select, .LevelEditor input": {
                    "margin": "7px",
                    "padding": "3px 7px",
                    "font-size": "1.17em"
                },
                // EditorGUI & EditorScrollers
                ".LevelEditor .EditorGui": {
                    "position": "absolute",
                    "top": "0",
                    "right": "0",
                    "bottom": "0",
                    "width": "50%",
                    "background": "rgba(0, 7, 14, .84)",
                    "overflow": "hidden",
                    "user-select": "none",
                    "box-sizing": "border-box",
                    "z-index": "70",
                    "transition": "117ms all"
                },
                // EditorMenuContainer & EditorScrollers
                ".LevelEditor .EditorMenuContainer": {
                    "position": "absolute",
                    "top": "0",
                    "right": "0",
                    "bottom": "0",
                    "width": "50%",
                    "background": "rgba(0, 7, 14, .84)",
                    "overflow": "hidden",
                    "user-select": "none",
                    "box-sizing": "border-box",
                    "z-index": "70",
                    "transition": "117ms all"
                },
                ".LevelEditor .EditorScrollers": {
                    "position": "absolute",
                    "top": "0",
                    "right": "50%",
                    "bottom": "0",
                    "left": "0",
                    "transition": "117ms all"
                },
                ".EditorScroller": {
                    "position": "absolute",
                    "top": "50%",
                    "margin-top": "-35px",
                    "width": "70px",
                    "cursor": "pointer",
                    "box-sizing": "border-box",
                    "font-size": "70px",
                    "text-align": "center",
                    "transition": "280ms all"
                },
                ".EditorScrollerRight": {
                    "right": "0",
                    "padding-left": ".084em"
                },
                ".EditorScrollerLeft": {
                    "left": "0"
                },
                ".LevelEditor.minimized .EditorGui": {
                    "width": "117px"
                },
                ".LevelEditor.minimized .EditorMenuContainer": {
                    "width": "117px"
                },
                ".LevelEditor.minimized .EditorScrollers": {
                    "right": "117px",
                    "padding-right": "117px"
                },
                // EditorHead
                ".LevelEditor .EditorHead": {
                    "position": "relative",
                    "height": "35px"
                },
                ".LevelEditor .EditorHead .EditorNameContainer": {
                    "position": "absolute",
                    "top": "1px",
                    "right": "73px",
                    "left": "2px",
                    "height": "35px"
                },
                ".LevelEditor .EditorHead .EditorNameInput": {
                    "display": "block",
                    "margin": "0",
                    "padding": "3px 7px",
                    "width": "100%",
                    "background": "white",
                    "border": "1px solid black",
                    "font-size": "1.4em",
                    "box-sizing": "border-box"
                },
                ".LevelEditor .EditorHead .EditorHeadButton": {
                    "position": "absolute",
                    "top": "2px",
                    "width": "32px",
                    "height": "32px",
                    "background": "rgb(35,35,35)",
                    "border": "1px solid silver",
                    "box-sizing": "border-box",
                    "text-align": "center",
                    "padding-top": "7px",
                    "cursor": "pointer"
                },
                ".LevelEditor .EditorHead .EditorMinimizer": {
                    "right": "38px"
                },
                ".LevelEditor .EditorHead .EditorCloser": {
                    "right": "3px"
                },
                // EditorSectionChoosers
                ".LevelEditor .EditorSectionChooser": {
                    "width": "50%",
                    "box-sizing": "border-box",
                    "height": "35px",
                    "background": "white",
                    "border": "3px solid black",
                    "color": "black",
                    "cursor": "pointer"
                },
                ".LevelEditor .EditorSectionChooser.Inactive": {
                    "background": "gray"
                },
                ".LevelEditor.minimized .EditorSectionChoosers": {
                    "opacity": "0"
                },
                // EditorSectionMain
                ".LevelEditor .EditorSectionMain": {
                    "position": "absolute",
                    "top": "70px",
                    "right": "0",
                    "bottom": "35px",
                    "left": "0",
                    "overflow-y": "auto"
                },
                ".LevelEditor.minimized .EditorSectionMain": {
                    "display": "none"
                },
                ".LevelEditor .EditorSectionSecondary": {
                    "position": "absolute",
                    "top": "35px",
                    "right": "203px",
                    "bottom": "0px",
                    "left": "0",
                    "min-width": "182px",
                    "overflow-y": "auto",
                    "overflow-x": "hidden"
                },
                // EditorJSON
                ".LevelEditor .EditorJSON": {
                    "font-family": "Courier"
                },
                ".LevelEditor .EditorJSONInput": {
                    "display": "block",
                    "width": "100%",
                    "height": "84%",
                    "background": "rgba(0, 3, 7, .91)",
                    "color": "rgba(255, 245, 245, .91)",
                    "box-sizing": "border-box",
                    "overflow-y": "auto",
                    "resize": "none"
                },
                ".LevelEditor .EditorJSONInfo": {
                    "height": "1.75em",
                    "padding": "3px 7px"
                },
                ".LevelEditor.minimized .EditorJSON": {
                    "opacity": "0"
                },
                // EditorOptions
                ".LevelEditor .EditorOptions, .LevelEditor .EditorOptionContainer": {
                    "padding-left": "3px",
                    "clear": "both"
                },
                ".LevelEditor.minimized .EditorOptionsList": {
                    "opacity": "0"
                },
                ".LevelEditor .EditorListOption": {
                    "position": "relative",
                    "float": "left",
                    "margin": "0 7px 7px 0",
                    "width": "70px",
                    "height": "70px",
                    "background": "rgba(77, 77, 77, .7)",
                    "border": "2px solid black",
                    "overflow": "hidden",
                    "cursor": "pointer"
                },
                ".LevelEditor .EditorListOption canvas": {
                    "position": "absolute"
                },
                // EditorVisualOptions
                ".LevelEditor .EditorVisualOptions": {
                    "position": "absolute",
                    "top": "105px",
                    "right": "0",
                    "bottom": "35px",
                    "padding": "7px 11px",
                    "width": "203px",
                    "border-left": "1px solid silver",
                    "background": "rgba(0, 7, 14, .84)",
                    "overflow-x": "visible",
                    "overflow-y": "auto",
                    "line-height": "140%",
                    "opacity": "1",
                    "box-sizing": "border-box",
                    "transition": "117ms opacity, 70ms left"
                },
                ".LevelEditor.thin .EditorVisualOptions": {
                    "left": "185px"
                },
                ".LevelEditor.thin .EditorVisualOptions:hover": {
                    "left": "70px",
                    "right": "0",
                    "width": "auto",
                    "overflow-x": "hidden"
                },
                ".LevelEditor.thick .EditorVisualOptions": {
                    "width": "350px"
                },
                ".LevelEditor.thick .EditorSectionSecondary": {
                    "right": "350px"
                },
                ".LevelEditor.minimized .EditorVisualOptions": {
                    "left": "100%"
                },
                ".LevelEditor .EditorVisualOptions .VisualOption": {
                    "padding": "14px 0"
                },
                ".LevelEditor .EditorVisualOptions .VisualOptionName": {
                    "margin": "3px 0 7px 0"
                },
                ".LevelEditor .EditorVisualOptions .VisualOptionDescription": {
                    "padding-bottom": "14px"
                },
                ".LevelEditor .EditorVisualOptions .VisualOptionValue": {
                    "max-width": "117px"
                },
                ".LevelEditor .EditorVisualOptions select.VisualOptionValue": {
                    "max-width": "156px"
                },
                ".LevelEditor .EditorVisualOptions .VisualOptionInfiniter, .LevelEditor .EditorVisualOptions .VisualOptionRecommendation": {
                    "display": "inline"
                },
                // EditorMenu
                ".LevelEditor .EditorMenu": {
                    "position": "absolute",
                    "right": "0",
                    "bottom": "0",
                    "left": "0"
                },
                ".LevelEditor .EditorMenuOption": {
                    "display": "inline-block",
                    "padding": "7px 14px",
                    "background": "white",
                    "border": "3px solid black",
                    "box-sizing": "border-box",
                    "color": "black",
                    "text-align": "center",
                    "overflow": "hidden",
                    "cursor": "pointer"
                },
                ".LevelEditor.minimized .EditorMenuOption:not(:first-of-type)": {
                    "display": "none"
                },
                ".LevelEditor.minimized .EditorMenuOption:first-of-type": {
                    "width": "auto"
                },
                ".LevelEditor .EditorMenuOption:hover": {
                    "opacity": ".91"
                },
                ".LevelEditor .EditorMenuOption.EditorMenuOptionHalf": {
                    "width": "50%"
                },
                ".LevelEditor .EditorMenuOption.EditorMenuOptionThird": {
                    "width": "33%"
                },
                ".LevelEditor .EditorMenuOption.EditorMenuOptionFifth": {
                    "width": "20%"
                },
                // EditorMapSettings
                ".LevelEditor .EditorMapSettingsGroup": {
                    "padding-left": "7px"
                },
                ".LevelEditor .EditorMapSettingsSubGroup": {
                    "padding-left": "14px"
                },
                ".LevelEditor.minimized .EditorMapSettings": {
                    "opacity": "0"
                }
            };
        };
        return LevelEditr;
    })();
    LevelEditr_1.LevelEditr = LevelEditr;
})(LevelEditr || (LevelEditr = {}));
/// <reference path="ItemsHoldr-0.2.1.ts" />
var ModAttachr;
(function (ModAttachr_1) {
    "use strict";
    /**
     * An addon for for extensible modding functionality. "Mods" register triggers
     * such as "onModEnable" or "onReset" that can be triggered during gameplay.
     */
    var ModAttachr = (function () {
        /**
         * Initializes a new instance of the ModAttachr class.
         *
         * @param [settings]   Settings to be used for initialization.
         */
        function ModAttachr(settings) {
            this.mods = {};
            this.events = {};
            if (!settings) {
                return;
            }
            this.scopeDefault = settings.scopeDefault;
            // If a ItemsHoldr is provided, use it
            if (settings.ItemsHoldr) {
                this.ItemsHolder = settings.ItemsHoldr;
            }
            else if (settings.storeLocally) {
                // If one isn't provided by storeLocally is still true, make one
                this.ItemsHolder = new ItemsHoldr.ItemsHoldr();
            }
            if (settings.mods) {
                this.addMods.apply(this, settings.mods);
            }
        }
        /* Simple gets
        */
        /**
         * @returns An Object keying each mod by their name.
         */
        ModAttachr.prototype.getMods = function () {
            return this.mods;
        };
        /**
         * @param name   The name of the mod to return.
         * @returns The mod keyed by the name.
         */
        ModAttachr.prototype.getMod = function (name) {
            return this.mods[name];
        };
        /**
         * @returns An Object keying each event by their name.
         */
        ModAttachr.prototype.getEvents = function () {
            return this.events;
        };
        /**
         * @returns The mods associated with a particular event.
         */
        ModAttachr.prototype.getEvent = function (name) {
            return this.events[name];
        };
        /**
         * @returns The ItemsHoldr if storeLocally is true (by default, undefined).
         */
        ModAttachr.prototype.getItemsHolder = function () {
            return this.ItemsHolder;
        };
        /**
         * @returns The default scope used to apply mods from, if not this ModAttachr.
         */
        ModAttachr.prototype.getScopeDefault = function () {
            return this.scopeDefault;
        };
        /* Alterations
        */
        /**
         * Adds a mod to the pool of mods, listing it under all the relevant events.
         * If the event is enabled, the "onModEnable" event for it is triggered.
         *
         * @param mod   A summary Object for a mod, containing at the very
         *              least a name and listing of events.
         */
        ModAttachr.prototype.addMod = function (mod) {
            var modEvents = mod.events, name;
            for (name in modEvents) {
                if (!modEvents.hasOwnProperty(name)) {
                    continue;
                }
                if (!this.events.hasOwnProperty(name)) {
                    this.events[name] = [mod];
                }
                else {
                    this.events[name].push(mod);
                }
            }
            // Mod scope defaults to the ModAttacher's scopeDefault.
            mod.scope = mod.scope || this.scopeDefault;
            // Record the mod in the ModAttachr's mods listing.
            this.mods[mod.name] = mod;
            // If the mod is enabled, trigger its "onModEnable" event
            if (mod.enabled && mod.events.hasOwnProperty("onModEnable")) {
                this.fireModEvent("onModEnable", mod.name, arguments);
            }
            // If there's a ItemsHoldr, record the mod in it
            if (this.ItemsHolder) {
                this.ItemsHolder.addItem(mod.name, {
                    "valueDefault": 0,
                    "storeLocally": true
                });
                // If there was already a (true) value, immediately enable the mod
                if (this.ItemsHolder.getItem(mod.name)) {
                    return this.enableMod(mod.name);
                }
            }
        };
        /**
         * Adds multiple mods via this.addMod.
         *
         * @param mods   The mods to add.
         * @returns The return values of the mods' onModEnable events, in order.
         */
        ModAttachr.prototype.addMods = function () {
            var mods = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                mods[_i - 0] = arguments[_i];
            }
            var results = [], i;
            for (i = 0; i < mods.length; i += 1) {
                results.push(this.addMod(mods[i]));
            }
            return results;
        };
        /**
         * Enables a mod of the given name, if it exists. The onModEnable event is
         * called for the mod.
         *
         * @param name   The name of the mod to enable.
         * @param args   Any additional arguments to pass. This will have `mod`
         *               and `name` unshifted in front, in that order.
         * @returns   The return value of the mod's onModEnable event.
         */
        ModAttachr.prototype.enableMod = function (name) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var mod = this.mods[name];
            if (!mod) {
                throw new Error("No mod of name: '" + name + "'");
            }
            // The args are manually sliced to prevent external state changes
            args = [].slice.call(args);
            args.unshift(mod, name);
            mod.enabled = true;
            if (this.ItemsHolder) {
                this.ItemsHolder.setItem(name, true);
            }
            if (mod.events.hasOwnProperty("onModEnable")) {
                return this.fireModEvent("onModEnable", mod.name, arguments);
            }
        };
        /**
         * Enables any number of mods.
         *
         * @param names   Names of the mods to enable.
         * @returns The return values of the mods' onModEnable events, in order.
         */
        ModAttachr.prototype.enableMods = function () {
            var names = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                names[_i - 0] = arguments[_i];
            }
            var results = [], i;
            for (i = 0; i < names.length; i += 1) {
                results.push(this.enableMod(names[i]));
            }
            return results;
        };
        /**
         * Disables a mod of the given name, if it exists. The onModDisable event is
         * called for the mod.
         *
         * @param name   The name of the mod to disable.
         * @returns The return value of the mod's onModDisable event.
         */
        ModAttachr.prototype.disableMod = function (name) {
            var mod = this.mods[name], args;
            if (!this.mods[name]) {
                throw new Error("No mod of name: '" + name + "'");
            }
            this.mods[name].enabled = false;
            args = Array.prototype.slice.call(arguments);
            args[0] = mod;
            if (this.ItemsHolder) {
                this.ItemsHolder.setItem(name, false);
            }
            if (mod.events.hasOwnProperty("onModDisable")) {
                return this.fireModEvent("onModDisable", mod.name, args);
            }
        };
        /**
         * Disables any number of mods.
         *
         * @param names   Names of the mods to disable.
         * @returns The return values of the mods' onModEnable events, in order.
         */
        ModAttachr.prototype.disableMods = function () {
            var names = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                names[_i - 0] = arguments[_i];
            }
            var results = [], i;
            for (i = 0; i < names.length; i += 1) {
                results.push(this.disableMod(names[i]));
            }
            return results;
        };
        /**
         * Toggles a mod via enableMod/disableMod of the given name, if it exists.
         *
         * @param name   The name of the mod to toggle.
         * @returns The result of the mod's onModEnable or onModDisable event.
         */
        ModAttachr.prototype.toggleMod = function (name) {
            var mod = this.mods[name];
            if (!mod) {
                throw new Error("No mod found under " + name);
            }
            if (mod.enabled) {
                return this.disableMod(name);
            }
            else {
                return this.enableMod(name);
            }
        };
        /**
         * Toggles any number of mods.
         *
         * @param names   Names of the mods to toggle.
         * @returns The result of the mods' onModEnable or onModDisable events, in order.
         */
        ModAttachr.prototype.toggleMods = function () {
            var names = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                names[_i - 0] = arguments[_i];
            }
            var result = [], i;
            for (var i = 0; i < names.length; i += 1) {
                result.push(this.toggleMod(names[i]));
            }
            return result;
        };
        /* Actions
        */
        /**
         * Fires an event, which calls all mods listed for that event.
         *
         * @param event   The name of the event to fire.
         * @param args   Any additional arguments to pass. This will have `mod`
         *               and `event` unshifted in front, in that order.
         */
        ModAttachr.prototype.fireEvent = function (event) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var mods = this.events[event], mod, i;
            // If no triggers were defined for this event, that's ok: just stop.
            if (!mods) {
                return;
            }
            // The args are manually sliced to prevent external state changes
            args = [].slice.call(args);
            args.unshift(undefined, event);
            for (i = 0; i < mods.length; i += 1) {
                mod = mods[i];
                if (mod.enabled) {
                    args[0] = mod;
                    mod.events[event].apply(mod.scope, args);
                }
            }
        };
        /**
         * Fires an event specifically for one mod, rather than all mods containing
         * that event.
         *
         * @param event   The name of the event to fire.
         * @param modName   The name of the mod to fire the event.
         * @param args   Any additional arguments to pass. This will have `mod`
         *               and `event` unshifted in front, in that order.
         * @returns The result of the fired mod event.
         */
        ModAttachr.prototype.fireModEvent = function (event, modName) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            var mod = this.mods[modName], fires;
            if (!mod) {
                throw new Error("Unknown mod requested: '" + modName + "'");
            }
            // The args are manually sliced to prevent external state changes
            args = [].slice.call(args);
            args.unshift(mod, event);
            fires = mod.events[event];
            if (!fires) {
                throw new Error("Mod does not contain event: '" + event + "'");
            }
            return fires.apply(mod.scope, args);
        };
        return ModAttachr;
    })();
    ModAttachr_1.ModAttachr = ModAttachr;
})(ModAttachr || (ModAttachr = {}));
/**
 * An updated version of the traditional MersenneTwister JavaScript class by
 * Sean McCullough (2010), based on code by Takuji Nishimura and Makoto
 * Matsumoto (1997 - 2002).
 *
 * For the 2010 code, see https://gist.github.com/banksean/300494.
 */
/*
    I've wrapped Makoto Matsumoto and Takuji Nishimura's code in a namespace
    so it's better encapsulated. Now you can have multiple random number generators
    and they won't stomp all over each other's state.
      
    If you want to use this as a substitute for Math.random(), use the random()
    method like so:
      
    var statePeriod = new MersenneTwister();
    var randomNumber = statePeriod.random();
      
    You can also call the other genrand_{foo}() methods on the instance.
    
    If you want to use a specific seed in order to get a repeatable random
    sequence, pass an integer into the constructor:
    
    var statePeriod = new MersenneTwister(123);
    
    and that will always produce the same random sequence.
    
    Sean McCullough (banksean@gmail.com)
*/
/*
    A C-program for MT19937, with initialization improved 2002/1/26.
    Coded by Takuji Nishimura and Makoto Matsumoto.
     
    Before using, initialize the state by using init_genrand(seed)
    or init_by_array(keyInitial, keyLength).
     
    Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
    All rights reserved.
     
    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:
     
        1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     
        2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     
        3. The names of its contributors may not be used to endorse or promote
        products derived from this software without specific prior written
        permission.
     
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER
    OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     
    Any feedback is very welcome.
    http://www.math.sci.hiroshima-u.ac.jp/~statePeriod-mat/stateVector/emt.html
    email: statePeriod-mat @ math.sci.hiroshima-u.ac.jp (remove space)
*/
var NumberMakr;
(function (NumberMakr_1) {
    "use strict";
    /**
     * A typed MersenneTwister, which is a state-based random number generator.
     * Options exist for changing or randomizing state and producing random
     * booleans, integers, and real numbers.
     */
    var NumberMakr = (function () {
        /**
         * Initializes a new instance of the NumberMakr class.
         *
         * @param settings   Settings to be used for initialization.
         */
        function NumberMakr(settings) {
            if (settings === void 0) { settings = {}; }
            this.stateLength = settings.stateLength || 624;
            this.statePeriod = settings.statePeriod || 397;
            this.matrixA = settings.matrixA || 0x9908b0df;
            this.maskUpper = settings.maskUpper || 0x80000000;
            this.maskLower = settings.maskLower || 0x7fffffff;
            this.stateVector = new Array(this.stateLength);
            this.stateIndex = this.stateLength + 1;
            this.matrixAMagic = new Array(0x0, this.matrixA);
            this.resetFromSeed(settings.seed || new Date().getTime());
        }
        /* Simple gets
        */
        /**
         * @returns The starting seed used to initialize.
         */
        NumberMakr.prototype.getSeed = function () {
            return this.seed;
        };
        /**
         * @returns The length of the state vector.
         */
        NumberMakr.prototype.getStateLength = function () {
            return this.stateLength;
        };
        /**
         * @returns The length of the state vector.
         */
        NumberMakr.prototype.getStatePeriod = function () {
            return this.statePeriod;
        };
        /**
         * @returns The length of the state vector.
         */
        NumberMakr.prototype.getMatrixA = function () {
            return this.matrixA;
        };
        /**
         * @returns The length of the state vector.
         */
        NumberMakr.prototype.getMaskUpper = function () {
            return this.maskUpper;
        };
        /**
         * @returns The length of the state vector.
         */
        NumberMakr.prototype.getMaskLower = function () {
            return this.maskLower;
        };
        /* Resets
        */
        /**
         * Initializes state from a new seed.
         *
         * @param seedNew   A new seed to reset from.
         */
        NumberMakr.prototype.resetFromSeed = function (seedNew) {
            var s;
            this.stateVector[0] = seedNew >>> 0;
            for (this.stateIndex = 1; this.stateIndex < this.stateLength; this.stateIndex += 1) {
                s = this.stateVector[this.stateIndex - 1] ^ (this.stateVector[this.stateIndex - 1] >>> 30);
                this.stateVector[this.stateIndex] = ((((((s & 0xffff0000) >>> 16) * 1812433253) << 16)
                    + (s & 0x0000ffff) * 1812433253) + this.stateIndex) >>> 0;
            }
            this.seed = seedNew;
        };
        /**
         * Initializes state from an Array.
         *
         * @param keyInitial   An initial state to reset from.
         * @param [keyLength]   The length of keyInitial (by default, keyInitial.length).
         * @remarks   There was a slight change for C++, 2004/2/26.
         */
        NumberMakr.prototype.resetFromArray = function (keyInitial, keyLength) {
            if (keyLength === void 0) { keyLength = keyInitial.length; }
            var i = 1, j = 0, k, s;
            this.resetFromSeed(19650218);
            if (typeof (keyLength) === "undefined") {
                keyLength = keyInitial.length;
            }
            k = this.stateLength > keyLength ? this.stateLength : keyLength;
            while (k > 0) {
                s = this.stateVector[i - 1] ^ (this.stateVector[i - 1] >>> 30);
                this.stateVector[i] = (this.stateVector[i] ^ (((((s & 0xffff0000) >>> 16) * 1664525) << 16)
                    + ((s & 0x0000ffff) * 1664525)) + keyInitial[j] + j) >>> 0;
                i += 1;
                j += 1;
                if (i >= this.stateLength) {
                    this.stateVector[0] = this.stateVector[this.stateLength - 1];
                    i = 1;
                }
                if (j >= keyLength) {
                    j = 0;
                }
            }
            for (k = this.stateLength - 1; k; k -= 1) {
                s = this.stateVector[i - 1] ^ (this.stateVector[i - 1] >>> 30);
                this.stateVector[i] = ((this.stateVector[i] ^ (((((s & 0xffff0000) >>> 16) * 1566083941) << 16)
                    + (s & 0x0000ffff) * 1566083941)) - i) >>> 0;
                i += 1;
                if (i >= this.stateLength) {
                    this.stateVector[0] = this.stateVector[this.stateLength - 1];
                    i = 1;
                }
            }
            this.stateVector[0] = 0x80000000;
            this.seed = keyInitial;
        };
        /* Random number generation
        */
        /**
         * @returns A random Number in [0,0xffffffff].
         */
        NumberMakr.prototype.randomInt32 = function () {
            var y, kk;
            if (this.stateIndex >= this.stateLength) {
                if (this.stateIndex === this.stateLength + 1) {
                    this.resetFromSeed(5489);
                }
                for (kk = 0; kk < this.stateLength - this.statePeriod; kk += 1) {
                    y = (this.stateVector[kk] & this.maskUpper)
                        | (this.stateVector[kk + 1] & this.maskLower);
                    this.stateVector[kk] = this.stateVector[kk + this.statePeriod]
                        ^ (y >>> 1)
                        ^ this.matrixAMagic[y & 0x1];
                }
                for (; kk < this.stateLength - 1; kk += 1) {
                    y = (this.stateVector[kk] & this.maskUpper)
                        | (this.stateVector[kk + 1] & this.maskLower);
                    this.stateVector[kk] = this.stateVector[kk + (this.statePeriod - this.stateLength)]
                        ^ (y >>> 1)
                        ^ this.matrixAMagic[y & 0x1];
                }
                y = (this.stateVector[this.stateLength - 1] & this.maskUpper)
                    | (this.stateVector[0] & this.maskLower);
                this.stateVector[this.stateLength - 1] = this.stateVector[this.statePeriod - 1]
                    ^ (y >>> 1) ^ this.matrixAMagic[y & 0x1];
                this.stateIndex = 0;
            }
            y = this.stateVector[this.stateIndex];
            this.stateIndex += 1;
            y ^= (y >>> 11);
            y ^= (y << 7) & 0x9d2c5680;
            y ^= (y << 15) & 0xefc60000;
            y ^= (y >>> 18);
            return y >>> 0;
        };
        /**
         * @returns A random number in [0,1).
         * @remarks Divided by 2^32.
         */
        NumberMakr.prototype.random = function () {
            return this.randomInt32() * (1.0 / 4294967296.0);
        };
        /**
         * @returns A random number in [0,0x7fffffff].
         */
        NumberMakr.prototype.randomInt31 = function () {
            return this.randomInt32() >>> 1;
        };
        /* Real number generators (due to Isaku Wada, 2002/01/09)
        */
        /**
         * @returns A random real Number in [0,1].
         * @remarks Divided by 2 ^ 32 - 1.
         */
        NumberMakr.prototype.randomReal1 = function () {
            return this.randomInt32() * (1.0 / 4294967295.0);
        };
        /**
         * @returns A random real Number in (0,1).
         * @remarks Divided by 2 ^ 32.
         */
        NumberMakr.prototype.randomReal3 = function () {
            return (this.randomInt32() + 0.5) * (1.0 / 4294967296.0);
        };
        /**
         * @returns A random real Number in [0,1) with 53-bit resolution.
         */
        NumberMakr.prototype.randomReal53Bit = function () {
            var a = this.randomInt32() >>> 5, b = this.randomInt32() >>> 6;
            return (a * 67108864.0 + b) * (1.0 / 9007199254740992.0);
        };
        /* Ranged Number generators
        */
        /**
         * @param max   A maximum value to return under.
         * @returns A random number in [0,max).
         */
        NumberMakr.prototype.randomUnder = function (max) {
            return this.random() * max;
        };
        /**
         * @param min   A minimum value to return.
         * @param max   A maximum value  to return under.
         * @returns A random number in [min,max).
         */
        NumberMakr.prototype.randomWithin = function (min, max) {
            return this.randomUnder(max - min) + min;
        };
        /* Ranged integer generators
        */
        /**
         * @param max   A maximum value to return under.
         * @returns a random integer in [0,max).
         */
        NumberMakr.prototype.randomInt = function (max) {
            return this.randomUnder(max) | 0;
        };
        /**
         * @param min   A minimum value to return.
         * @param max   A maximum value to return under.
         * @returns a random integer in [min,max).
         */
        NumberMakr.prototype.randomIntWithin = function (min, max) {
            return (this.randomUnder(max - min) + min) | 0;
        };
        /**
         * @returns Either true or false, with 50% probability each.
         */
        NumberMakr.prototype.randomBoolean = function () {
            return this.randomInt(2) === 1;
        };
        /**
         * @param probability   How likely the returned Boolean will be
         *                      true, in [0, 1]. If >= 1, always true.
         * @returns Either true or false, with the probability of true
         *          equal to the given probability.
         */
        NumberMakr.prototype.randomBooleanProbability = function (probability) {
            return this.random() < probability;
        };
        /**
         * @param numerator   The numerator of a fraction.
         * @param denominator   The denominator of a fraction.
         * @returns   Either true or false, with a probability equal to the
         *            given fraction.
         */
        NumberMakr.prototype.randomBooleanFraction = function (numerator, denominator) {
            return this.random() <= (numerator / denominator);
        };
        /**
         * @param array   Any Array of values.
         * @returns A random index, from 0 to the given Array's length.
         */
        NumberMakr.prototype.randomArrayIndex = function (array) {
            return this.randomIntWithin(0, array.length);
        };
        /**
         * @param array   Any Array of values.
         * @returns A random element from within the given Array.
         */
        NumberMakr.prototype.randomArrayMember = function (array) {
            return array[this.randomArrayIndex(array)];
        };
        return NumberMakr;
    })();
    NumberMakr_1.NumberMakr = NumberMakr;
})(NumberMakr || (NumberMakr = {}));
var ScenePlayr;
(function (ScenePlayr_1) {
    "use strict";
    /**
     * A cutscene runner for jumping between scenes and their routines.
     */
    var ScenePlayr = (function () {
        /**
         * Initializes a new instance of the ScenePlayr class.
         *
         * @param [settings]   Settings to be used for initialization.
         */
        function ScenePlayr(settings) {
            if (settings === void 0) { settings = {}; }
            this.cutscenes = settings.cutscenes || {};
            this.cutsceneArguments = settings.cutsceneArguments || [];
        }
        /* Simple gets
        */
        /**
         * @returns The complete listing of cutscenes that may be played.
         */
        ScenePlayr.prototype.getCutscenes = function () {
            return this.cutscenes;
        };
        /**
         * @returns The currently playing cutscene.
         */
        ScenePlayr.prototype.getCutscene = function () {
            return this.cutscene;
        };
        /**
         * @returns The cutscene referred to by the given name.
         */
        ScenePlayr.prototype.getOtherCutscene = function (name) {
            return this.cutscenes[name];
        };
        /**
         * @returns The currently playing routine.
         */
        ScenePlayr.prototype.getRoutine = function () {
            return this.routine;
        };
        /**
         * @param name   The name of a routine to return.
         * @returns The routine within the current cutscene referred to
         *          by the given name.
         */
        ScenePlayr.prototype.getOtherRoutine = function (name) {
            return this.cutscene.routines[name];
        };
        /**
         * @returns The name of the currently playing cutscene.
         */
        ScenePlayr.prototype.getCutsceneName = function () {
            return this.cutsceneName;
        };
        /**
         * @returns The settings used by the current cutscene.
         */
        ScenePlayr.prototype.getCutsceneSettings = function () {
            return this.cutsceneSettings;
        };
        /**
         * Adds a setting to the internal cutscene settings.
         *
         * @param key   The key for the new setting.
         * @param value   The value for the new setting.
         */
        ScenePlayr.prototype.addCutsceneSetting = function (key, value) {
            this.cutsceneSettings[key] = value;
        };
        /* Playback
        */
        /**
         * Starts the cutscene of the given name, keeping the settings Object (if
         * given one). The cutsceneArguments unshift the settings, and if the
         * cutscene specifies a firstRoutine, it's started.
         *
         * @param name   The name of the cutscene to play.
         * @param [settings]   Additional settings to be kept persistently
         *                     throughout the cutscene.
         */
        ScenePlayr.prototype.startCutscene = function (name, settings, args) {
            if (settings === void 0) { settings = {}; }
            if (!name) {
                throw new Error("No name given to ScenePlayr.playScene.");
            }
            if (this.cutsceneName) {
                this.stopCutscene();
            }
            this.cutscene = this.cutscenes[name];
            this.cutsceneName = name;
            this.cutsceneSettings = settings || {};
            this.cutsceneSettings.cutscene = this.cutscene;
            this.cutsceneSettings.cutsceneName = name;
            this.cutsceneArguments.push(this.cutsceneSettings);
            if (this.cutscene.firstRoutine) {
                this.playRoutine.apply(this, [this.cutscene.firstRoutine].concat(args));
            }
        };
        /**
         * Returns this.startCutscene bound to the given name and settings.
         *
         * @param name   The name of the cutscene to play.
         * @param settings   Additional settings to be kept as a persistent Object
         *                   throughout the cutscene.
         * @param args   Arguments for the firstRoutine, if it exists.
         */
        ScenePlayr.prototype.bindCutscene = function (name, settings, args) {
            if (settings === void 0) { settings = {}; }
            return this.startCutscene.bind(this, name, args);
        };
        /**
         * Stops the currently playing cutscene and clears the internal data.
         */
        ScenePlayr.prototype.stopCutscene = function () {
            this.routine = undefined;
            this.cutscene = undefined;
            this.cutsceneName = undefined;
            this.cutsceneSettings = undefined;
            this.cutsceneArguments.pop();
        };
        /**
         * Plays a particular routine within the current cutscene, passing
         * the given args as cutsceneSettings.routineArguments.
         *
         * @param name   The name of the routine to play.
         * @param args   Any additional arguments to pass to the routine.
         */
        ScenePlayr.prototype.playRoutine = function (name) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (!this.cutscene) {
                throw new Error("No cutscene is currently playing.");
            }
            if (!this.cutscene.routines[name]) {
                throw new Error("The " + this.cutsceneName + " cutscene does not contain a " + name + " routine.");
            }
            // Copy the given ...args to a new Array from this.cutsceneArguments
            // This is better than args.unshift to not modify args, if they're given directly
            var routineArgs = this.cutsceneArguments.slice();
            routineArgs.push.apply(routineArgs, args);
            this.routine = this.cutscene.routines[name];
            this.cutsceneSettings.routine = this.routine;
            this.cutsceneSettings.routineName = name;
            this.cutsceneSettings.routineArguments = args;
            this.routine.apply(this, routineArgs);
        };
        /**
         * Returns this.startCutscene bound to the given name and arguments.
         *
         * @param name   The name of the cutscene to play.
         * @param args   Any additional arguments to pass to the routine.
         */
        ScenePlayr.prototype.bindRoutine = function (name) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            return (_a = this.playRoutine).bind.apply(_a, [this, name].concat(args));
            var _a;
        };
        return ScenePlayr;
    })();
    ScenePlayr_1.ScenePlayr = ScenePlayr;
})(ScenePlayr || (ScenePlayr = {}));
/// <reference path="QuadsKeepr-0.2.1.ts" />
var ThingHittr;
(function (ThingHittr_1) {
    "use strict";
    /**
     * A Thing collision detection automator that unifies GroupHoldr and QuadsKeepr.
     * Functions for checking whether a Thing may collide, checking whether it collides
     * with another Thing, and reacting to a collision are generated and cached for
     * each Thing type, based on the overarching Thing groups.
     */
    var ThingHittr = (function () {
        /**
         * Initializes a new instance of the ThingHittr class.
         *
         * @param settings   Settings to be used for initialization.
         */
        function ThingHittr(settings) {
            if (typeof settings === "undefined") {
                throw new Error("No settings object given to ThingHittr.");
            }
            if (typeof settings.globalCheckGenerators === "undefined") {
                throw new Error("No globalCheckGenerators given to ThingHittr.");
            }
            if (typeof settings.hitCheckGenerators === "undefined") {
                throw new Error("No hitCheckGenerators given to ThingHittr.");
            }
            if (typeof settings.hitCallbackGenerators === "undefined") {
                throw new Error("No hitCallbackGenerators given to ThingHittr.");
            }
            this.keyNumQuads = settings.keyNumQuads || "numquads";
            this.keyQuadrants = settings.keyQuadrants || "quadrants";
            this.keyGroupName = settings.keyGroupName || "group";
            this.keyTypeName = settings.keyTypeName || "type";
            this.globalCheckGenerators = settings.globalCheckGenerators;
            this.hitCheckGenerators = settings.hitCheckGenerators;
            this.hitCallbackGenerators = settings.hitCallbackGenerators;
            this.generatedHitChecks = {};
            this.generatedHitCallbacks = {};
            this.generatedGlobalChecks = {};
            this.generatedHitsChecks = {};
            this.groupHitLists = this.generateGroupHitLists(this.hitCheckGenerators);
        }
        /**
         * Caches global and hits checks for the given type if they do not yet exist
         * and have their generators defined
         *
         * @param typeName   The type to cache hits for.
         * @param groupName   The general group the type fall sunder.
         */
        ThingHittr.prototype.cacheChecksForType = function (typeName, groupName) {
            if (!this.generatedGlobalChecks.hasOwnProperty(typeName) && this.globalCheckGenerators.hasOwnProperty(groupName)) {
                this.generatedGlobalChecks[typeName] = this.globalCheckGenerators[groupName]();
                this.generatedHitsChecks[typeName] = this.generateHitsCheck(typeName);
            }
        };
        /**
         * Checks all hits for a Thing using its generated hits check.
         *
         * @param thing   The Thing to have hits checked.
         */
        ThingHittr.prototype.checkHitsForThing = function (thing) {
            this.generatedHitsChecks[thing[this.keyTypeName]](thing);
        };
        /**
         * Checks whether two Things are hitting.
         *
         * @param thing   The primary Thing that may be hitting other.
         * @param other   The secondary Thing that may be being hit by thing.
         * @returns Whether the two Things are hitting.
         */
        ThingHittr.prototype.checkHitForThings = function (thing, other) {
            return this.runThingsFunctionSafely(this.generatedHitChecks, thing, other, this.hitCheckGenerators);
        };
        /**
         * Reacts to two Things hitting.
         *
         * @param thing   The primary Thing that is hitting other.
         * @param other   The secondary Thing that is being hit by thing.
         */
        ThingHittr.prototype.runHitCallbackForThings = function (thing, other) {
            this.runThingsFunctionSafely(this.generatedHitCallbacks, thing, other, this.hitCallbackGenerators);
        };
        /**
         * Function generator for a hits check for a specific Thing type.
         *
         * @param typeName   The type of the Things to generate for.
         * @returns A Function that can check all hits for a Thing of the given type.
         */
        ThingHittr.prototype.generateHitsCheck = function (typeName) {
            var _this = this;
            /**
             * Collision detection Function for a Thing. For each Quadrant the Thing
             * is in, for all groups within that Function that the Thing's group is
             * allowed to collide with, it is checked for collision with the Things
             * in that group. For each Thing it does collide with, the appropriate
             * hit Function is called.
             *
             * @param thing   A Thing to check collision detection for.
             */
            return function (thing) {
                // Don't do anything if the thing shouldn't be checking
                if (!_this.generatedGlobalChecks[typeName](thing)) {
                    return;
                }
                var groupNames = _this.groupHitLists[thing[_this.keyGroupName]], groupName, others, other, i, j, k;
                // For each quadrant thing is in, look at each of its groups that thing can check
                for (i = 0; i < thing[_this.keyNumQuads]; i += 1) {
                    for (j = 0; j < groupNames.length; j += 1) {
                        groupName = groupNames[j];
                        others = thing[_this.keyQuadrants][i].things[groupName];
                        // For each other Thing in this group that should be checked...
                        for (k = 0; k < others.length; k += 1) {
                            other = others[k];
                            // If they are the same, breaking prevents double hits
                            if (thing === other) {
                                break;
                            }
                            // Do nothing if other can't collide in the first place
                            if (!_this.generatedGlobalChecks[other[_this.keyTypeName]](other)) {
                                continue;
                            }
                            // If they do hit (hitCheck), call the corresponding hitCallback
                            if (_this.checkHitForThings(thing, other)) {
                                _this.runHitCallbackForThings(thing, other);
                            }
                        }
                    }
                }
            };
        };
        /**
         * Runs the Function in the group that maps to the two Things' types. If it doesn't
         * yet exist, it is created.
         *
         * @param group   The group of Functions to use.
         * @param thing   The primary Thing reacting to other.
         * @param other   The secondary Thing that thing is reacting to.
         * @returns The result of the ThingFunction from the group.
         */
        ThingHittr.prototype.runThingsFunctionSafely = function (group, thing, other, generators) {
            var typeThing = thing[this.keyTypeName], typeOther = other[this.keyTypeName], container = group[typeThing], check;
            if (!container) {
                container = group[typeThing] = {};
            }
            check = container[typeOther];
            if (!check) {
                check = container[typeOther] = generators[thing[this.keyGroupName]][other[this.keyGroupName]]();
            }
            return check(thing, other);
        };
        /**
         * Generates the list of group names each group is allowd to hit.
         *
         * @param group   A summary of group containers.
         */
        ThingHittr.prototype.generateGroupHitLists = function (group) {
            var output = {}, i;
            for (i in group) {
                if (group.hasOwnProperty(i)) {
                    output[i] = Object.keys(group[i]);
                }
            }
            return output;
        };
        return ThingHittr;
    })();
    ThingHittr_1.ThingHittr = ThingHittr;
})(ThingHittr || (ThingHittr = {}));
/// <reference path="InputWritr-0.2.0.ts" />
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var TouchPassr;
(function (TouchPassr) {
    /**
     * Abstract class for on-screen controls. Element creation for .element
     * and .elementInner within the constrained position is provided.
     */
    var Control = (function () {
        /**
         * Resets the control by setting member variables and calling resetElement.
         *
         * @param InputWriter   The parent TouchPassr's InputWritr.
         * @param schema   The governing schema for this control.
         * @param styles   Any styles to add to the element.
         */
        function Control(InputWriter, schema, styles) {
            this.InputWriter = InputWriter;
            this.schema = schema;
            this.resetElement(styles);
        }
        /**
         * @returns The outer container element.
         */
        Control.prototype.getElement = function () {
            return this.element;
        };
        /**
         * @returns The inner container element.
         */
        Control.prototype.getElementInner = function () {
            return this.elementInner;
        };
        /**
         * Creates and returns an HTMLElement of the specified type. Any additional
         * settings Objects may be given to be proliferated onto the Element via
         * proliferateElement.
         *
         * @param type   The tag of the Element to be created.
         * @param settings   Additional settings for the Element, such as className
         *                   or style.
         * @returns A newly created HTMLElement of the specified type.
         */
        Control.prototype.createElement = function (tag) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var element = document.createElement(tag || "div"), i;
            // For each provided object, add those settings to the element
            for (i = 0; i < args.length; i += 1) {
                this.proliferateElement(element, args[i]);
            }
            return element;
        };
        /**
         * Identical to proliferate, but tailored for HTML elements because many
         * element attributes don't play nicely with JavaScript Array standards.
         * Looking at you, HTMLCollection!
         *
         * @param recipient   An HTMLElement to receive properties from the donor.
         * @param donor   An object do donoate properties to the recipient.
         * @param noOverride   Whether pre-existing properties of the recipient should
         *                     be skipped (defaults to false).
         * @returns recipient
         */
        Control.prototype.proliferateElement = function (recipient, donor, noOverride) {
            if (noOverride === void 0) { noOverride = false; }
            var setting, i, j;
            // For each attribute of the donor:
            for (i in donor) {
                if (donor.hasOwnProperty(i)) {
                    // If noOverride, don't override already existing properties
                    if (noOverride && recipient.hasOwnProperty(i)) {
                        continue;
                    }
                    setting = donor[i];
                    // Special cases for HTML elements
                    switch (i) {
                        // Children and options: just append all of them directly
                        case "children":
                        case "children":
                            if (typeof (setting) !== "undefined") {
                                for (j = 0; j < setting.length; j += 1) {
                                    recipient.appendChild(setting[j]);
                                }
                            }
                            break;
                        // Style: proliferate (instead of making a new Object)
                        case "style":
                            this.proliferateElement(recipient[i], setting);
                            break;
                        // By default, use the normal proliferate logic
                        default:
                            // If it's null, don't do anything (like .textContent)
                            if (setting === null) {
                                recipient[i] = null;
                            }
                            else if (typeof setting === "object") {
                                // If it's an object, recurse on a new version of it
                                if (!recipient.hasOwnProperty(i)) {
                                    recipient[i] = new setting.constructor();
                                }
                                this.proliferateElement(recipient[i], setting, noOverride);
                            }
                            else {
                                // Regular primitives are easy to copy otherwise
                                recipient[i] = setting;
                            }
                            break;
                    }
                }
            }
            return recipient;
        };
        /**
         * Resets the container elements. In any inherited resetElement, this should
         * still be called, as it implements the schema's position.
         *
         * @param styles   Container styles for the contained elements.
         */
        Control.prototype.resetElement = function (styles, customType) {
            var _this = this;
            var position = this.schema.position, offset = position.offset;
            this.element = this.createElement("div", {
                "className": "control",
                "style": {
                    "position": "absolute",
                    "width": 0,
                    "height": 0,
                    "boxSizing": "border-box",
                    "opacity": ".84"
                }
            });
            this.elementInner = this.createElement("div", {
                "className": "control-inner",
                "textContent": this.schema.label || "",
                "style": {
                    "position": "absolute",
                    "boxSizing": "border-box",
                    "textAlign": "center"
                }
            });
            this.element.appendChild(this.elementInner);
            if (position.horizontal === "left") {
                this.element.style.left = "0";
            }
            else if (position.horizontal === "right") {
                this.element.style.right = "0";
            }
            else if (position.horizontal === "center") {
                this.element.style.left = "50%";
            }
            if (position.vertical === "top") {
                this.element.style.top = "0";
            }
            else if (position.vertical === "bottom") {
                this.element.style.bottom = "0";
            }
            else if (position.vertical === "center") {
                this.element.style.top = "50%";
            }
            this.passElementStyles(styles.global);
            this.passElementStyles(styles[customType]);
            this.passElementStyles(this.schema.styles);
            if (offset.left) {
                this.elementInner.style.marginLeft = this.createPixelMeasurement(offset.left);
            }
            if (offset.top) {
                this.elementInner.style.marginTop = this.createPixelMeasurement(offset.top);
            }
            // elementInner's center-based positioning must wait until its total width is done setting
            setTimeout(function () {
                if (position.horizontal === "center") {
                    _this.elementInner.style.left = _this.createHalfSizeMeasurement(_this.elementInner, "width", "offsetWidth");
                }
                if (position.vertical === "center") {
                    _this.elementInner.style.top = _this.createHalfSizeMeasurement(_this.elementInner, "height", "offsetHeight");
                }
            });
        };
        /**
         * Converts a String or Number into a CSS-ready String measurement.
         *
         * @param raw   A raw measurement, such as 7 or "7px" or "7em".
         * @returns The raw measurement as a CSS measurement.
         */
        Control.prototype.createPixelMeasurement = function (raw) {
            if (!raw) {
                return "0";
            }
            if (typeof raw === "number" || raw.constructor === Number) {
                return raw + "px";
            }
            return raw;
        };
        /**
         * Determines a "half"-measurement that would center an element based on the
         * specified units.
         *
         * @param element   The element whose half-size should be computed.
         * @param styleTag   The initial CSS measurement to check for, as "width" or
         *                   "height".
         * @param attributeBackup   A measurement to check for if the CSS size is falsy,
         *                          as "offsetWidth" or "offsetHeight".
         * @returns A measurement equal to half the sytleTag/attributeBackup, such as
         *          "3.5em" or "10px".
         */
        Control.prototype.createHalfSizeMeasurement = function (element, styleTag, attributeBackup) {
            var amountRaw, amount, units;
            amountRaw = element.style[styleTag] || (attributeBackup && element[attributeBackup]);
            if (!amountRaw) {
                return "0px";
            }
            amount = Number(amountRaw.replace(/[^\d]/g, "")) || 0;
            units = amountRaw.replace(/[\d]/g, "") || "px";
            return Math.round(amount / -2) + units;
        };
        /**
         * Passes a style schema to .element and .elementInner.
         *
         * @param styles   A container for styles to apply.
         */
        Control.prototype.passElementStyles = function (styles) {
            if (!styles) {
                return;
            }
            if (styles.element) {
                this.proliferateElement(this.element, styles.element);
            }
            if (styles.elementInner) {
                this.proliferateElement(this.elementInner, styles.elementInner);
            }
        };
        /**
         * Sets the rotation of an HTML element via CSS.
         *
         * @param element   An HTML element to rotate.
         * @param rotation   How many degrees to rotate the element.
         */
        Control.prototype.setRotation = function (element, rotation) {
            element.style.transform = "rotate(" + rotation + "deg)";
        };
        /**
         * Finds the position offset of an element relative to the page, factoring in
         * its parent elements' offsets recursively.
         *
         * @param element   An HTML element.
         * @returns The [left, top] offset of the element, in px.
         */
        Control.prototype.getOffsets = function (element) {
            var output;
            if (element.offsetParent && element !== element.offsetParent) {
                output = this.getOffsets(element.offsetParent);
                output[0] += element.offsetLeft;
                output[1] += element.offsetTop;
            }
            else {
                output = [element.offsetLeft, element.offsetTop];
            }
            return output;
        };
        return Control;
    })();
    TouchPassr.Control = Control;
})(TouchPassr || (TouchPassr = {}));
var TouchPassr;
(function (TouchPassr) {
    /**
     * Simple button control. It activates its triggers when the user presses
     * it or releases it, and contains a simple label.
     */
    var ButtonControl = (function (_super) {
        __extends(ButtonControl, _super);
        function ButtonControl() {
            _super.apply(this, arguments);
        }
        /**
         * Resets the elements by adding listeners for mouse and touch
         * activation and deactivation events.
         *
         * @param styles   Container styles for the contained elements.
         */
        ButtonControl.prototype.resetElement = function (styles) {
            var onActivated = this.onEvent.bind(this, "activated"), onDeactivated = this.onEvent.bind(this, "deactivated");
            _super.prototype.resetElement.call(this, styles, "Button");
            this.element.addEventListener("mousedown", onActivated);
            this.element.addEventListener("touchstart", onActivated);
            this.element.addEventListener("mouseup", onDeactivated);
            this.element.addEventListener("touchend", onDeactivated);
        };
        /**
         * Reaction callback for a triggered event.
         *
         * @param which   The pipe being activated, such as "activated"
         *                or "deactivated".
         * @param event   The triggered event.
         */
        ButtonControl.prototype.onEvent = function (which, event) {
            var events = this.schema.pipes[which], i, j;
            if (!events) {
                return;
            }
            for (i in events) {
                if (!events.hasOwnProperty(i)) {
                    continue;
                }
                for (j = 0; j < events[i].length; j += 1) {
                    this.InputWriter.callEvent(i, events[i][j], event);
                }
            }
        };
        return ButtonControl;
    })(TouchPassr.Control);
    TouchPassr.ButtonControl = ButtonControl;
})(TouchPassr || (TouchPassr = {}));
var TouchPassr;
(function (TouchPassr) {
    /**
     * Joystick control. An inner circle can be dragged to one of a number
     * of directions to trigger pipes on and off.
     */
    var JoystickControl = (function (_super) {
        __extends(JoystickControl, _super);
        function JoystickControl() {
            _super.apply(this, arguments);
        }
        /**
         * Resets the element by creating a tick for each direction, along with
         * the multiple circular elements with their triggers.
         *
         * @param styles   Container styles for the contained elements.
         */
        JoystickControl.prototype.resetElement = function (styles) {
            _super.prototype.resetElement.call(this, styles, "Joystick");
            var directions = this.schema.directions, element, degrees, sin, cos, dx, dy, i;
            this.proliferateElement(this.elementInner, {
                "style": {
                    "border-radius": "100%"
                }
            });
            // The visible circle is what is actually visible to the user
            this.elementCircle = this.createElement("div", {
                "className": "control-inner control-joystick-circle",
                "style": {
                    "position": "absolute",
                    "background": "red",
                    "borderRadius": "100%"
                }
            });
            this.proliferateElement(this.elementCircle, styles.Joystick.circle);
            // Each direction creates a "tick" element, like on a clock
            for (i = 0; i < directions.length; i += 1) {
                degrees = directions[i].degrees;
                // sin and cos are an amount / 1 the tick is offset from the center
                sin = Math.sin(degrees * Math.PI / 180);
                cos = Math.cos(degrees * Math.PI / 180);
                // dx and dy are measured as percent from the center, based on sin & cos
                dx = cos * 50 + 50;
                dy = sin * 50 + 50;
                element = this.createElement("div", {
                    "className": "control-joystick-tick",
                    "style": {
                        "position": "absolute",
                        "left": dx + "%",
                        "top": dy + "%",
                        "marginLeft": (-cos * 5 - 5) + "px",
                        "marginTop": (-sin * 2 - 1) + "px"
                    }
                });
                this.proliferateElement(element, styles.Joystick.tick);
                this.setRotation(element, degrees);
                this.elementCircle.appendChild(element);
            }
            // In addition to the ticks, a drag element shows current direction
            this.elementDragLine = this.createElement("div", {
                "className": "control-joystick-drag-line",
                "style": {
                    "position": "absolute",
                    "opacity": "0",
                    "top": ".77cm",
                    "left": ".77cm"
                }
            });
            this.proliferateElement(this.elementDragLine, styles.Joystick.dragLine);
            this.elementCircle.appendChild(this.elementDragLine);
            // A shadow-like circle supports the drag effect
            this.elementDragShadow = this.createElement("div", {
                "className": "control-joystick-drag-shadow",
                "style": {
                    "position": "absolute",
                    "opacity": "1",
                    "top": "14%",
                    "right": "14%",
                    "bottom": "14%",
                    "left": "14%",
                    "marginLeft": "0",
                    "marginTop": "0",
                    "borderRadius": "100%"
                }
            });
            this.proliferateElement(this.elementDragShadow, styles.Joystick.dragShadow);
            this.elementCircle.appendChild(this.elementDragShadow);
            this.elementInner.appendChild(this.elementCircle);
            this.elementInner.addEventListener("click", this.triggerDragger.bind(this));
            this.elementInner.addEventListener("touchmove", this.triggerDragger.bind(this));
            this.elementInner.addEventListener("mousemove", this.triggerDragger.bind(this));
            this.elementInner.addEventListener("mouseover", this.positionDraggerEnable.bind(this));
            this.elementInner.addEventListener("touchstart", this.positionDraggerEnable.bind(this));
            this.elementInner.addEventListener("mouseout", this.positionDraggerDisable.bind(this));
            this.elementInner.addEventListener("touchend", this.positionDraggerDisable.bind(this));
        };
        /**
         * Enables dragging, showing the elementDragLine.
         */
        JoystickControl.prototype.positionDraggerEnable = function () {
            this.dragEnabled = true;
            this.elementDragLine.style.opacity = "1";
        };
        /**
         * Disables dragging, hiding the drag line and re-centering the
         * inner circle shadow.
         */
        JoystickControl.prototype.positionDraggerDisable = function () {
            this.dragEnabled = false;
            this.elementDragLine.style.opacity = "0";
            this.elementDragShadow.style.top = "14%";
            this.elementDragShadow.style.right = "14%";
            this.elementDragShadow.style.bottom = "14%";
            this.elementDragShadow.style.left = "14%";
            if (this.currentDirection) {
                if (this.currentDirection.pipes && this.currentDirection.pipes.deactivated) {
                    this.onEvent(this.currentDirection.pipes.deactivated, event);
                }
                this.currentDirection = undefined;
            }
        };
        /**
         * Triggers a movement point for the joystick, and snaps the stick to
         * the nearest direction (based on the angle from the center to the point).
         *
         * @param event   A user-triggered event.
         */
        JoystickControl.prototype.triggerDragger = function (event) {
            event.preventDefault();
            if (!this.dragEnabled) {
                return;
            }
            var coordinates = this.getEventCoordinates(event), x = coordinates[0], y = coordinates[1], offsets = this.getOffsets(this.elementInner), midX = offsets[0] + this.elementInner.offsetWidth / 2, midY = offsets[1] + this.elementInner.offsetHeight / 2, dxRaw = (x - midX) | 0, dyRaw = (midY - y) | 0, thetaRaw = this.getThetaRaw(dxRaw, dyRaw), directionNumber = this.findClosestDirection(thetaRaw), direction = this.schema.directions[directionNumber], theta = direction.degrees, components = this.getThetaComponents(theta), dx = components[0], dy = -components[1];
            // Ensure theta is above 0, and offset it by 90 for visual rotation
            theta = (theta + 450) % 360;
            this.elementDragLine.style.marginLeft = ((dx * 77) | 0) + "%";
            this.elementDragLine.style.marginTop = ((dy * 77) | 0) + "%";
            this.elementDragShadow.style.top = ((14 + dy * 10) | 0) + "%";
            this.elementDragShadow.style.right = ((14 - dx * 10) | 0) + "%";
            this.elementDragShadow.style.bottom = ((14 - dy * 10) | 0) + "%";
            this.elementDragShadow.style.left = ((14 + dx * 10) | 0) + "%";
            this.setRotation(this.elementDragLine, theta);
            this.positionDraggerEnable();
            this.setCurrentDirection(direction, event);
        };
        /**
         * Finds the raw coordinates of an event, whether it's a drag (touch)
         * or mouse event.
         *
         * @returns The x- and y- coordinates of the event.
         */
        JoystickControl.prototype.getEventCoordinates = function (event) {
            if (event.type === "touchmove") {
                // TypeScript 1.5 doesn't seem to have TouchEvent yet.
                var touch = event.touches[0];
                return [touch.pageX, touch.pageY];
            }
            return [event.x, event.y];
        };
        /**
         * Finds the angle from a joystick center to an x and y. This assumes
         * straight up is 0, to the right is 90, down is 180, and left is 270.
         *
         * @returns The degrees to the given point.
         */
        JoystickControl.prototype.getThetaRaw = function (dxRaw, dyRaw) {
            // Based on the quadrant, theta changes...
            if (dxRaw > 0) {
                if (dyRaw > 0) {
                    // Quadrant I
                    return Math.atan(dxRaw / dyRaw) * 180 / Math.PI;
                }
                else {
                    // Quadrant II
                    return -Math.atan(dyRaw / dxRaw) * 180 / Math.PI + 90;
                }
            }
            else {
                if (dyRaw < 0) {
                    // Quadrant III
                    return Math.atan(dxRaw / dyRaw) * 180 / Math.PI + 180;
                }
                else {
                    // Quadrant IV
                    return -Math.atan(dyRaw / dxRaw) * 180 / Math.PI + 270;
                }
            }
        };
        /**
         * Converts an angle to its relative dx and dy coordinates.
         *
         * @param thetaRaw   The raw degrees of an anle.
         * @returns The x- and y- parts of an angle.
         */
        JoystickControl.prototype.getThetaComponents = function (thetaRaw) {
            var theta = thetaRaw * Math.PI / 180;
            return [Math.sin(theta), Math.cos(theta)];
        };
        /**
         * Finds the index of the closest direction to an angle.
         *
         * @param degrees   The degrees of an angle.
         * @returns The index of the closest known direction to the degrees.a
         */
        JoystickControl.prototype.findClosestDirection = function (degrees) {
            var directions = this.schema.directions, difference = Math.abs(directions[0].degrees - degrees), smallestDegrees = directions[0].degrees, smallestDegreesRecord = 0, record = 0, differenceTest, i;
            // Find the direction with the smallest difference in degrees
            for (i = 1; i < directions.length; i += 1) {
                differenceTest = Math.abs(directions[i].degrees - degrees);
                if (differenceTest < difference) {
                    difference = differenceTest;
                    record = i;
                }
                if (directions[i].degrees < smallestDegrees) {
                    smallestDegrees = directions[i].degrees;
                    smallestDegreesRecord = i;
                }
            }
            // 359 is closer to 360 than 0, so pretend the smallest is above 360
            differenceTest = Math.abs(smallestDegrees + 360 - degrees);
            if (differenceTest < difference) {
                difference = differenceTest;
                record = smallestDegreesRecord;
            }
            return record;
        };
        /**
         * Sets the current direction of the joystick, calling the relevant
         * InputWriter pipes if necessary.
         *
         * @param direction   A new direction to face.
         * @param event   A user-triggered event.
         */
        JoystickControl.prototype.setCurrentDirection = function (direction, event) {
            if (this.currentDirection === direction) {
                return;
            }
            if (this.currentDirection && this.currentDirection.pipes && this.currentDirection.pipes.deactivated) {
                this.onEvent(this.currentDirection.pipes.deactivated, event);
            }
            if (direction.pipes && direction.pipes.activated) {
                this.onEvent(direction.pipes.activated, event);
            }
            this.currentDirection = direction;
        };
        /**
         * Trigger for calling pipes when a new direction is set. All children
         * of the pipe has each of its keys triggered.
         *
         * @param pipes   Pipes to trigger.
         * @param event   A user-triggered event.
         */
        JoystickControl.prototype.onEvent = function (pipes, event) {
            var i, j;
            for (i in pipes) {
                if (!pipes.hasOwnProperty(i)) {
                    continue;
                }
                for (j = 0; j < pipes[i].length; j += 1) {
                    this.InputWriter.callEvent(i, pipes[i][j], event);
                }
            }
        };
        return JoystickControl;
    })(TouchPassr.Control);
    TouchPassr.JoystickControl = JoystickControl;
})(TouchPassr || (TouchPassr = {}));
var TouchPassr;
(function (TouchPassr_1) {
    "use strict";
    /**
     * A GUI touch layer layer on top of InputWritr that provides an extensible
     * API for adding touch-based control elements into an HTML element.
     */
    var TouchPassr = (function () {
        /**
         * Initializes a new instance of the TouchPassr class.
         *
         * @param settings   Settings to be used for initialization.
         */
        function TouchPassr(settings) {
            if (typeof settings === "undefined") {
                throw new Error("No settings object given to TouchPassr.");
            }
            if (typeof settings.InputWriter === "undefined") {
                throw new Error("No InputWriter given to TouchPassr.");
            }
            this.InputWriter = settings.InputWriter;
            this.styles = settings.styles || {};
            this.resetContainer(settings.container);
            this.controls = {};
            if (settings.controls) {
                this.addControls(settings.controls);
            }
            if (typeof settings.enabled === "undefined") {
                this.enabled = true;
            }
            else {
                this.enabled = settings.enabled;
            }
            this.enabled ? this.enable() : this.disable();
        }
        /* Simple gets
        */
        /**
         * @returns The InputWritr for controls to pipe event triggers to.
         */
        TouchPassr.prototype.getInputWriter = function () {
            return this.InputWriter;
        };
        /**
         * @returns Whether this is currently enabled and visually on the screen.
         */
        TouchPassr.prototype.getEnabled = function () {
            return this.enabled;
        };
        /**
         * @returns The root container for styles to be added to control elements.
         */
        TouchPassr.prototype.getStyles = function () {
            return this.styles;
        };
        /**
         * @returns The container for generated controls, keyed by their name.
         */
        TouchPassr.prototype.getControls = function () {
            return this.controls;
        };
        /**
         * @returns The HTMLElement all controls are placed within.
         */
        TouchPassr.prototype.getContainer = function () {
            return this.container;
        };
        /**
         * @returns The HTMLElement containing the controls container.
         */
        TouchPassr.prototype.getParentContainer = function () {
            return this.parentContainer;
        };
        /* Core functionality
        */
        /**
         * Enables the TouchPassr by showing the container.
         */
        TouchPassr.prototype.enable = function () {
            this.enabled = true;
            this.container.style.display = "block";
        };
        /**
         * Disables the TouchPassr by hiding the container.
         */
        TouchPassr.prototype.disable = function () {
            this.enabled = false;
            this.container.style.display = "none";
        };
        /**
         * Sets the parent container surrounding the controls container.
         *
         * @param parentElement   A new parent container.
         */
        TouchPassr.prototype.setParentContainer = function (parentElement) {
            this.parentContainer = parentElement;
            this.parentContainer.appendChild(this.container);
        };
        /**
         * Adds any number of controls to the internal listing and HTML container.
         *
         * @param schemas   Schemas for new controls to be made, keyed by name.
         */
        TouchPassr.prototype.addControls = function (schemas) {
            var i;
            for (i in schemas) {
                if (schemas.hasOwnProperty(i)) {
                    this.addControl(schemas[i]);
                }
            }
        };
        /**
         * Adds a control to the internal listing and HTML container.
         *
         * @param schema   The schema for the new control to be made.
         */
        TouchPassr.prototype.addControl = function (schema) {
            if (!TouchPassr.controlClasses.hasOwnProperty(schema.control)) {
                throw new Error("Unknown control schema: '" + schema.control + "'.");
            }
            var control = new TouchPassr.controlClasses[schema.control](this.InputWriter, schema, this.styles);
            this.controls[schema.name] = control;
            this.container.appendChild(control.getElement());
        };
        /* HTML manipulations
        */
        /**
         * Resets the base controls container. If a parent element is provided,
         * the container is added to it.
         *
         * @param parentContainer   A container element, such as from GameStartr.
         */
        TouchPassr.prototype.resetContainer = function (parentContainer) {
            this.container = TouchPassr_1.Control.prototype.createElement("div", {
                "className": "touch-passer-container",
                "style": {
                    "position": "absolute",
                    "top": 0,
                    "right": 0,
                    "bottom": 0,
                    "left": 0
                }
            });
            if (parentContainer) {
                this.setParentContainer(parentContainer);
            }
        };
        /**
         * Known, allowed control classes, keyed by name.
         */
        TouchPassr.controlClasses = {
            "Button": TouchPassr_1.ButtonControl,
            "Joystick": TouchPassr_1.JoystickControl
        };
        return TouchPassr;
    })();
    TouchPassr_1.TouchPassr = TouchPassr;
})(TouchPassr || (TouchPassr = {}));
var UsageHelpr;
(function (UsageHelpr_1) {
    "use strict";
    /**
     * A simple interactive text-based assistant to demonstrate common API uses.
     */
    var UsageHelpr = (function () {
        /**
         * Initializes a new instance of the UsageHelpr class.
         *
         * @param settings   Settings to be used for initialization.
         */
        function UsageHelpr(settings) {
            if (settings === void 0) { settings = {}; }
            this.openings = settings.openings || [];
            this.options = settings.options || {};
            this.optionHelp = settings.optionHelp || "";
            this.aliases = settings.aliases || [];
            this.logger = settings.logger || console.log.bind(console);
        }
        /**
         * Displays the root help menu dialog, which contains all the openings
         * for each help settings opening.
         */
        UsageHelpr.prototype.displayHelpMenu = function () {
            var _this = this;
            this.openings.forEach(function (opening) { return _this.logHelpText(opening); });
        };
        /**
         * Displays the texts of each help settings options, all surrounded by
         * instructions on how to focus on a group.
         */
        UsageHelpr.prototype.displayHelpOptions = function () {
            var _this = this;
            this.logHelpText([this.optionHelp, "code"]);
            Object.keys(this.options).forEach(function (key) { return _this.displayHelpGroupSummary(key); });
            this.logHelpText(["\r\n" + this.optionHelp, "code"]);
        };
        /**
         * Displays the summary for a help group of the given optionName.
         *
         * @param optionName   The help group to display the summary of.
         */
        UsageHelpr.prototype.displayHelpGroupSummary = function (optionName) {
            var actions = this.options[optionName], action, maxTitleLength = 0, i;
            this.logger("\r\n%c" + optionName, UsageHelpr.styles.head);
            for (i = 0; i < actions.length; i += 1) {
                maxTitleLength = Math.max(maxTitleLength, this.filterHelpText(actions[i].title).length);
            }
            for (i = 0; i < actions.length; i += 1) {
                action = actions[i];
                this.logger("%c" + this.padTextRight(this.filterHelpText(action.title), maxTitleLength) + "%c  // " + action.description, UsageHelpr.styles.code, UsageHelpr.styles.comment);
            }
        };
        /**
         * Displays the full information on a help group of the given optionName.
         *
         * @param optionName   The help group to display the information of.
         */
        UsageHelpr.prototype.displayHelpOption = function (optionName) {
            var actions = this.options[optionName], action, example, maxExampleLength, i, j;
            this.logHelpText([("\r\n\r\n%c" + optionName + "\r\n-------\r\n\r\n"), "head"]);
            for (i = 0; i < actions.length; i += 1) {
                action = actions[i];
                maxExampleLength = 0;
                this.logHelpText([
                    ("%c" + action.title + "%c  ---  " + action.description),
                    "head",
                    "italic"
                ]);
                if (action.usage) {
                    this.logHelpText([
                        ("%cUsage: %c" + action.usage),
                        "comment",
                        "code"
                    ]);
                }
                if (action.examples) {
                    for (j = 0; j < action.examples.length; j += 1) {
                        example = action.examples[j];
                        this.logger("\r\n");
                        this.logHelpText([("%c// " + example.comment), "comment"]);
                        this.logHelpText([
                            ("%c" + this.padTextRight(this.filterHelpText(example.code), maxExampleLength)),
                            "code"
                        ]);
                    }
                }
                this.logger("\r\n");
            }
        };
        /**
         * Logs a bit of help text, filtered by this.filterHelpText, with ordered styles
         * from `UserWrappr.styles` keyed by name.
         *
         * @param text   The text to be filtered and logged.
         * @remarks See https://getfirebug.com/wiki/index.php/Console.log for "%c" usage.
         */
        UsageHelpr.prototype.logHelpText = function (line) {
            if (typeof line === "string") {
                return this.logHelpText([line]);
            }
            var message = line[0], styles = line
                .slice(1)
                .filter(function (style) { return UsageHelpr.styles.hasOwnProperty(style); })
                .map(function (style) { return UsageHelpr.styles[style]; });
            // A last blank "" style allows the last "%c" in the message to reset text styles
            this.logger.apply(this, [this.filterHelpText(message)].concat(styles, [""]));
        };
        /**
         * Filters a span of help text to replace the game name with its alias. If "%c" isn't
         * in the text, it's added at the end.
         *
         * @param text The text to filter.
         * @returns The text, with aliases replaced.
         */
        UsageHelpr.prototype.filterHelpText = function (textRaw) {
            if (textRaw.constructor === Array) {
                return this.filterHelpText(textRaw[0]);
            }
            var text = textRaw, i;
            for (i = 0; i < this.aliases.length; i += 1) {
                text = text.replace(new RegExp(this.aliases[i][0], "g"), this.aliases[i][1]);
            }
            return text;
        };
        /**
         * Ensures a bit of text is of least a certain length.
         *
         * @param text   The text to pad.
         * @param length   How wide the text must be, at minimum.
         * @param spacer   What character to pad the text with, if not a space.
         * @returns The text with spaces padded to the right.
         */
        UsageHelpr.prototype.padTextRight = function (text, length, spacer) {
            if (spacer === void 0) { spacer = " "; }
            var diff = 1 + length - text.length;
            if (diff <= 0) {
                return text;
            }
            return text + Array.call(Array, diff).join(spacer);
        };
        /**
         * Styles for fancy text in logged help messages.
         */
        UsageHelpr.styles = {
            "code": "color: #000077; font-weight: bold; font-family: Consolas, Courier New, monospace;",
            "comment": "color: #497749; font-style: italic;",
            "head": "font-weight: bold; font-size: 117%;",
            "italic": "font-style: italic;",
            "none": ""
        };
        return UsageHelpr;
    })();
    UsageHelpr_1.UsageHelpr = UsageHelpr;
})(UsageHelpr || (UsageHelpr = {}));
/// <reference path="DeviceLayr-0.2.0.ts" />
/// <reference path="GamesRunnr-0.2.0.ts" />
/// <reference path="ItemsHoldr-0.2.1.ts" />
/// <reference path="InputWritr-0.2.0.ts" />
/// <reference path="LevelEditr-0.2.0.ts" />
var UserWrappr;
(function (UserWrappr) {
    var UISchemas;
    (function (UISchemas) {
        "use strict";
        /**
         * Base class for options generators. These all store a UserWrapper and
         * its GameStartr, along with a generate Function
         */
        var OptionsGenerator = (function () {
            /**
             * Initializes a new instance of the OptionsGenerator class.
             *
             * @param UserWrappr   The container UserWrappr using this generator.
             */
            function OptionsGenerator(UserWrapper) {
                this.UserWrapper = UserWrapper;
                this.GameStarter = this.UserWrapper.getGameStarter();
            }
            /**
             * Recursively searches for an element with the "control" class
             * that's a parent of the given element.
             *
             * @param element   An element to start searching on.
             * @returns The closest node with className "control" to the given element
             *          in its ancestry tree.
             */
            OptionsGenerator.prototype.getParentControlElement = function (element) {
                if (element.className === "control" || !element.parentNode) {
                    return element;
                }
                return this.getParentControlElement(element.parentElement);
            };
            return OptionsGenerator;
        })();
        UISchemas.OptionsGenerator = OptionsGenerator;
    })(UISchemas = UserWrappr.UISchemas || (UserWrappr.UISchemas = {}));
})(UserWrappr || (UserWrappr = {}));
var UserWrappr;
(function (UserWrappr) {
    var UISchemas;
    (function (UISchemas) {
        "use strict";
        /**
         * A buttons generator for an options section that contains any number
         * of general buttons.
         */
        var ButtonsGenerator = (function (_super) {
            __extends(ButtonsGenerator, _super);
            function ButtonsGenerator() {
                _super.apply(this, arguments);
            }
            /**
             * Generates a control element with buttons described in the schema.
             *
             * @param schema   A description of the element to create.
             * @returns An HTML element representing the schema.
             */
            ButtonsGenerator.prototype.generate = function (schema) {
                var output = document.createElement("div"), options = schema.options instanceof Function
                    ? schema.options.call(self, this.GameStarter)
                    : schema.options, classNameStart = "select-option options-button-option", scope = this, option, element, i;
                output.className = "select-options select-options-buttons";
                for (i = 0; i < options.length; i += 1) {
                    option = options[i];
                    element = document.createElement("div");
                    element.className = classNameStart;
                    element.textContent = option.title;
                    element.onclick = function (schema, element) {
                        if (scope.getParentControlElement(element).getAttribute("active") !== "on") {
                            return;
                        }
                        schema.callback.call(scope, scope.GameStarter, schema, element);
                        if (element.getAttribute("option-enabled") === "true") {
                            element.setAttribute("option-enabled", "false");
                            element.className = classNameStart + " option-disabled";
                        }
                        else {
                            element.setAttribute("option-enabled", "true");
                            element.className = classNameStart + " option-enabled";
                        }
                    }.bind(this, schema, element);
                    this.ensureLocalStorageButtonValue(element, option, schema);
                    if (option[schema.keyActive || "active"]) {
                        element.className += " option-enabled";
                        element.setAttribute("option-enabled", "true");
                    }
                    else if (schema.assumeInactive) {
                        element.className += " option-disabled";
                        element.setAttribute("option-enabled", "false");
                    }
                    else {
                        element.setAttribute("option-enabled", "true");
                    }
                    output.appendChild(element);
                }
                return output;
            };
            /**
             * Ensures a value exists in localStorage, and has the given settings. If
             * it doesn't have a value, the schema's callback is used to provide one.
             *
             * @param child   The value's representational HTML element.
             * @param details   Details
             * @param schema
             */
            ButtonsGenerator.prototype.ensureLocalStorageButtonValue = function (child, details, schema) {
                var key = schema.title + "::" + details.title, valueDefault = details.source.call(this, this.GameStarter).toString(), value;
                child.setAttribute("localStorageKey", key);
                this.GameStarter.ItemsHolder.addItem(key, {
                    "storeLocally": true,
                    "valueDefault": valueDefault
                });
                value = this.GameStarter.ItemsHolder.getItem(key);
                if (value.toString().toLowerCase() === "true") {
                    details[schema.keyActive || "active"] = true;
                    schema.callback.call(this, this.GameStarter, schema, child);
                }
            };
            return ButtonsGenerator;
        })(UISchemas.OptionsGenerator);
        UISchemas.ButtonsGenerator = ButtonsGenerator;
    })(UISchemas = UserWrappr.UISchemas || (UserWrappr.UISchemas = {}));
})(UserWrappr || (UserWrappr = {}));
var UserWrappr;
(function (UserWrappr) {
    var UISchemas;
    (function (UISchemas) {
        "use strict";
        /**
         * Options generator for a LevelEditr dialog.
         */
        var LevelEditorGenerator = (function (_super) {
            __extends(LevelEditorGenerator, _super);
            function LevelEditorGenerator() {
                _super.apply(this, arguments);
            }
            /**
             * Generates a control for a level editor based on the provided schema.
             *
             * @param schema   The overall description of the editor control.
             * @returns An HTML element representing the schema.
             */
            LevelEditorGenerator.prototype.generate = function (schema) {
                var output = document.createElement("div"), starter = document.createElement("div"), betweenOne = document.createElement("div"), betweenTwo = document.createElement("div"), uploader = this.createUploaderDiv(), mapper = this.createMapSelectorDiv(schema), scope = this;
                output.className = "select-options select-options-level-editor";
                starter.className = "select-option select-option-large options-button-option";
                starter.innerHTML = "Start the <br /> Level Editor!";
                starter.onclick = function () {
                    scope.GameStarter.LevelEditor.enable();
                };
                betweenOne.className = betweenTwo.className = "select-option-title";
                betweenOne.innerHTML = betweenTwo.innerHTML = "<em>- or -</em><br />";
                output.appendChild(starter);
                output.appendChild(betweenOne);
                output.appendChild(uploader);
                output.appendChild(betweenTwo);
                output.appendChild(mapper);
                return output;
            };
            /**
             * Creates an HTML element that can be clicked or dragged on to upload a JSON file
             * into the level editor.
             *
             * @returns An element containing the uploader div.
             */
            LevelEditorGenerator.prototype.createUploaderDiv = function () {
                var uploader = document.createElement("div"), input = document.createElement("input");
                uploader.className = "select-option select-option-large options-button-option";
                uploader.innerHTML = "Continue an<br />editor file!";
                uploader.setAttribute("textOld", uploader.textContent);
                input.type = "file";
                input.className = "select-upload-input";
                input.onchange = this.handleFileDrop.bind(this, input, uploader);
                uploader.ondragenter = this.handleFileDragEnter.bind(this, uploader);
                uploader.ondragover = this.handleFileDragOver.bind(this, uploader);
                uploader.ondragleave = input.ondragend = this.handleFileDragLeave.bind(this, uploader);
                uploader.ondrop = this.handleFileDrop.bind(this, input, uploader);
                uploader.onclick = input.click.bind(input);
                uploader.appendChild(input);
                return uploader;
            };
            /**
             * Creates an HTML element that allows a user to choose between maps to load into
             * the level editor.
             *
             * @param schema   The overall description of the container user control.
             * @returns An element containing the map selector.
             */
            LevelEditorGenerator.prototype.createMapSelectorDiv = function (schema) {
                var expanded = true, generatorName = "MapsGrid", container = this.GameStarter.createElement("div", {
                    "className": "select-options-group select-options-editor-maps-selector"
                }), toggler = this.GameStarter.createElement("div", {
                    "className": "select-option select-option-large options-button-option"
                }), mapsOut = this.GameStarter.createElement("div", {
                    "className": "select-options-holder select-options-editor-maps-holder"
                }), mapsIn = this.UserWrapper.getGenerators()[generatorName].generate(this.GameStarter.proliferate({
                    "callback": schema.callback
                }, schema.maps));
                toggler.onclick = function (event) {
                    expanded = !expanded;
                    if (expanded) {
                        toggler.textContent = "(cancel)";
                        mapsOut.style.position = "";
                        mapsIn.style.height = "";
                    }
                    else {
                        toggler.innerHTML = "Edit a <br />built-in map!";
                        mapsOut.style.position = "absolute";
                        mapsIn.style.height = "0";
                    }
                    if (!container.parentElement) {
                        return;
                    }
                    [].slice.call(container.parentElement.children)
                        .forEach(function (element) {
                        if (element !== container) {
                            element.style.display = (expanded ? "none" : "block");
                        }
                    });
                };
                toggler.onclick(null);
                mapsOut.appendChild(mapsIn);
                container.appendChild(toggler);
                container.appendChild(mapsOut);
                return container;
            };
            /**
             * Handles a dragged file entering a map selector. Visual styles are updated.
             *
             * @param uploader   The element being dragged onto.
             * @param event   The event caused by the dragging.
             */
            LevelEditorGenerator.prototype.handleFileDragEnter = function (uploader, event) {
                if (event.dataTransfer) {
                    event.dataTransfer.dropEffect = "copy";
                }
                uploader.className += " hovering";
            };
            /**
             * Handles a dragged file moving over a map selector.
             *
             * @param uploader   The element being dragged onto.
             * @param event   The event caused by the dragging.
             */
            LevelEditorGenerator.prototype.handleFileDragOver = function (uploader, event) {
                event.preventDefault();
                return false;
            };
            /**
             * Handles a dragged file leaving a map selector. Visual styles are updated.
             *
             * @param uploader   The element being dragged onto.
             * @param event   The event caused by the dragging.
             */
            LevelEditorGenerator.prototype.handleFileDragLeave = function (uploader, event) {
                if (event.dataTransfer) {
                    event.dataTransfer.dropEffect = "none";
                }
                uploader.className = uploader.className.replace(" hovering", "");
            };
            /**
             * Handles a dragged file being dropped onto a map selector. The file is read, and
             * events attached to its progress.
             *
             * @param input   The HTMLInputElement triggering the file event.
             * @param uploader   The element being dragged onto.
             * @param event   The event caused by the dragging.
             */
            LevelEditorGenerator.prototype.handleFileDrop = function (input, uploader, event) {
                var files = input.files || event.dataTransfer.files, file = files[0], reader = new FileReader();
                this.handleFileDragLeave(input, event);
                event.preventDefault();
                event.stopPropagation();
                reader.onprogress = this.handleFileUploadProgress.bind(this, file, uploader);
                reader.onloadend = this.handleFileUploadCompletion.bind(this, file, uploader);
                reader.readAsText(file);
            };
            /**
             * Handles a file upload reporting some amount of progress.
             *
             * @param file   The file being uploaded.
             * @param uploader   The element the file was being dragged onto.
             * @param event   The event caused by the progress.
             */
            LevelEditorGenerator.prototype.handleFileUploadProgress = function (file, uploader, event) {
                if (!event.lengthComputable) {
                    return;
                }
                var percent = Math.round((event.loaded / event.total) * 100);
                if (percent > 100) {
                    percent = 100;
                }
                uploader.innerText = "Uploading '" + file.name + "' (" + percent + "%)...";
            };
            /**
             * Handles a file upload completing. The file's contents are loaded into
             * the level editor.
             *
             * @param file   The file being uploaded.
             * @param uploader   The element the file was being dragged onto.
             * @param event   The event caused by the upload completing.
             */
            LevelEditorGenerator.prototype.handleFileUploadCompletion = function (file, uploader, event) {
                this.GameStarter.LevelEditor.handleUploadCompletion(event);
                uploader.innerText = uploader.getAttribute("textOld");
            };
            return LevelEditorGenerator;
        })(UISchemas.OptionsGenerator);
        UISchemas.LevelEditorGenerator = LevelEditorGenerator;
    })(UISchemas = UserWrappr.UISchemas || (UserWrappr.UISchemas = {}));
})(UserWrappr || (UserWrappr = {}));
var UserWrappr;
(function (UserWrappr) {
    var UISchemas;
    (function (UISchemas) {
        "use strict";
        /**
         * Options generator for a grid of maps.
         */
        var MapsGridGenerator = (function (_super) {
            __extends(MapsGridGenerator, _super);
            function MapsGridGenerator() {
                _super.apply(this, arguments);
            }
            /**
             * Generates the HTML element for the maps.
             *
             * @param schema   The overall description of the editor control.
             * @returns An HTML element representing the schema.
             */
            MapsGridGenerator.prototype.generate = function (schema) {
                var output = document.createElement("div");
                output.className = "select-options select-options-maps-grid";
                if (schema.rangeX && schema.rangeY) {
                    output.appendChild(this.generateRangedTable(schema));
                }
                if (schema.extras) {
                    this.appendExtras(output, schema);
                }
                return output;
            };
            /**
             * Generates a table of map selection buttons from x- and y- ranges.
             *
             * @param schema   The overall description of the editor control.
             * @returns An HTMLTableElement with a grid of map selection buttons.
             */
            MapsGridGenerator.prototype.generateRangedTable = function (schema) {
                var scope = this, table = document.createElement("table"), rangeX = schema.rangeX, rangeY = schema.rangeY, row, cell, i, j;
                for (i = rangeY[0]; i <= rangeY[1]; i += 1) {
                    row = document.createElement("tr");
                    row.className = "maps-grid-row";
                    for (j = rangeX[0]; j <= rangeX[1]; j += 1) {
                        cell = document.createElement("td");
                        cell.className = "select-option maps-grid-option maps-grid-option-range";
                        cell.textContent = i + "-" + j;
                        cell.onclick = (function (callback) {
                            if (scope.getParentControlElement(cell).getAttribute("active") === "on") {
                                callback();
                            }
                        }).bind(scope, schema.callback.bind(scope, scope.GameStarter, schema, cell));
                        row.appendChild(cell);
                    }
                    table.appendChild(row);
                }
                return table;
            };
            /**
             * Adds any specified extra elements to this control's element.
             *
             * @param output   The element created by this generator.
             * @param schema   The overall discription of the editor control.
             */
            MapsGridGenerator.prototype.appendExtras = function (output, schema) {
                var element, extra, i, j;
                for (i = 0; i < schema.extras.length; i += 1) {
                    extra = schema.extras[i];
                    element = document.createElement("div");
                    element.className = "select-option maps-grid-option maps-grid-option-extra";
                    element.textContent = extra.title;
                    element.setAttribute("value", extra.title);
                    element.onclick = extra.callback.bind(this, this.GameStarter, schema, element);
                    output.appendChild(element);
                    if (extra.extraElements) {
                        for (j = 0; j < extra.extraElements.length; j += 1) {
                            output.appendChild(this.GameStarter.createElement(extra.extraElements[j].tag, extra.extraElements[j].options));
                        }
                    }
                }
            };
            return MapsGridGenerator;
        })(UISchemas.OptionsGenerator);
        UISchemas.MapsGridGenerator = MapsGridGenerator;
    })(UISchemas = UserWrappr.UISchemas || (UserWrappr.UISchemas = {}));
})(UserWrappr || (UserWrappr = {}));
var UserWrappr;
(function (UserWrappr) {
    var UISchemas;
    (function (UISchemas) {
        "use strict";
        /**
         * An options generator for a table of options. Each table contains a (left) label cell
         * and a (right) value cell with some sort of input.
         */
        var TableGenerator = (function (_super) {
            __extends(TableGenerator, _super);
            function TableGenerator() {
                _super.apply(this, arguments);
            }
            /**
             * Generates a control element with tabular information based on the provided schema.
             *
             * @param schema   A description of the tabular data to represent.
             * @returns An HTML element representing the schema.
             */
            TableGenerator.prototype.generate = function (schema) {
                var output = document.createElement("div"), table = document.createElement("table"), option, action, row, label, input, child, i;
                output.className = "select-options select-options-table";
                if (schema.options) {
                    for (i = 0; i < schema.options.length; i += 1) {
                        row = document.createElement("tr");
                        label = document.createElement("td");
                        input = document.createElement("td");
                        option = schema.options[i];
                        label.className = "options-label-" + option.type;
                        label.textContent = option.title;
                        input.className = "options-cell-" + option.type;
                        row.appendChild(label);
                        row.appendChild(input);
                        child = TableGenerator.optionTypes[schema.options[i].type].call(this, input, option, schema);
                        if (option.storeLocally) {
                            this.ensureLocalStorageInputValue(child, option, schema);
                        }
                        table.appendChild(row);
                    }
                }
                output.appendChild(table);
                if (schema.actions) {
                    for (i = 0; i < schema.actions.length; i += 1) {
                        row = document.createElement("div");
                        action = schema.actions[i];
                        row.className = "select-option options-button-option";
                        row.textContent = action.title;
                        row.onclick = action.action.bind(this, this.GameStarter);
                        output.appendChild(row);
                    }
                }
                return output;
            };
            /**
             * Initializes an input for a boolean value.
             *
             * @param input   An input that will contain a boolean value.
             * @param details   Details for this individual value.
             * @param schema   Details for the overall table schema.
             * @returns An HTML element containing the input.
             */
            TableGenerator.prototype.setBooleanInput = function (input, details, schema) {
                var status = details.source.call(this, this.GameStarter), statusClass = status ? "enabled" : "disabled", scope = this;
                input.className = "select-option options-button-option option-" + statusClass;
                input.textContent = status ? "on" : "off";
                input.onclick = function () {
                    input.setValue(input.textContent === "off");
                };
                input.setValue = function (newStatus) {
                    if (newStatus.constructor === String) {
                        if (newStatus === "false" || newStatus === "off") {
                            newStatus = false;
                        }
                        else if (newStatus === "true" || newStatus === "on") {
                            newStatus = true;
                        }
                    }
                    if (newStatus) {
                        details.enable.call(scope, scope.GameStarter);
                        input.textContent = "on";
                        input.className = input.className.replace("disabled", "enabled");
                    }
                    else {
                        details.disable.call(scope, scope.GameStarter);
                        input.textContent = "off";
                        input.className = input.className.replace("enabled", "disabled");
                    }
                    if (details.storeLocally) {
                        scope.storeLocalStorageValue(input, newStatus.toString());
                    }
                };
                return input;
            };
            /**
             * Initializes an input for a keyboard key value.
             *
             * @param input   An input that will contain a keyboard key value.
             * @param details   Details for this individual value.
             * @param schema   Details for the overall table schema.
             * @returns An HTML element containing the input.
             */
            TableGenerator.prototype.setKeyInput = function (input, details, schema) {
                var values = details.source.call(this, this.GameStarter), possibleKeys = this.UserWrapper.getAllPossibleKeys(), children = [], child, scope = this, valueLower, i, j;
                for (i = 0; i < values.length; i += 1) {
                    valueLower = values[i].toLowerCase();
                    child = document.createElement("select");
                    child.className = "options-key-option";
                    child.value = child.valueOld = valueLower;
                    for (j = 0; j < possibleKeys.length; j += 1) {
                        child.appendChild(new Option(possibleKeys[j]));
                        // Setting child.value won't work in IE or Edge...
                        if (possibleKeys[j] === valueLower) {
                            child.selectedIndex = j;
                        }
                    }
                    child.onchange = (function (child) {
                        details.callback.call(scope, scope.GameStarter, child.valueOld, child.value);
                        if (details.storeLocally) {
                            scope.storeLocalStorageValue(child, child.value);
                        }
                    }).bind(undefined, child);
                    children.push(child);
                    input.appendChild(child);
                }
                return children;
            };
            /**
             * Initializes an input for a numeric value.
             *
             * @param input   An input that will contain a numeric value.
             * @param details   Details for this individual value.
             * @param schema   Details for the overall table schema.
             * @returns An HTML element containing the input.
             */
            TableGenerator.prototype.setNumberInput = function (input, details, schema) {
                var child = document.createElement("input"), scope = this;
                child.type = "number";
                child.value = Number(details.source.call(scope, scope.GameStarter)).toString();
                child.min = (details.minimum || 0).toString();
                child.max = (details.maximum || Math.max(details.minimum + 10, 10)).toString();
                child.onchange = child.oninput = function () {
                    if (child.checkValidity()) {
                        details.update.call(scope, scope.GameStarter, child.value);
                    }
                    if (details.storeLocally) {
                        scope.storeLocalStorageValue(child, child.value);
                    }
                };
                input.appendChild(child);
                return child;
            };
            /**
             * Initializes an input for a value with multiple preset options.
             *
             * @param input   An input that will contain a value with multiple present options.
             * @param details   Details for this individual value.
             * @param schema   Details for the overall table schema.
             * @returns An HTML element containing the input.
             */
            TableGenerator.prototype.setSelectInput = function (input, details, schema) {
                var child = document.createElement("select"), options = details.options(this.GameStarter), scope = this, i;
                for (i = 0; i < options.length; i += 1) {
                    child.appendChild(new Option(options[i]));
                }
                child.value = details.source.call(scope, scope.GameStarter);
                child.onchange = function () {
                    details.update.call(scope, scope.GameStarter, child.value);
                    child.blur();
                    if (details.storeLocally) {
                        scope.storeLocalStorageValue(child, child.value);
                    }
                };
                input.appendChild(child);
                return child;
            };
            /**
             * Initializes an input for setting the GameStartr's screen size.
             *
             * @param input   An input that will set a GameStartr's screen size.
             * @param details   Details for this individual value.
             * @param schema   Details for the overall table schema.
             * @returns An HTML element containing the input.
             */
            TableGenerator.prototype.setScreenSizeInput = function (input, details, schema) {
                var scope = this, child;
                details.options = function () {
                    return Object.keys(scope.UserWrapper.getSizes());
                };
                details.source = function () {
                    return scope.UserWrapper.getCurrentSize().name;
                };
                details.update = function (GameStarter, value) {
                    if (value === scope.UserWrapper.getCurrentSize()) {
                        return undefined;
                    }
                    scope.UserWrapper.setCurrentSize(value);
                };
                child = scope.setSelectInput(input, details, schema);
                return child;
            };
            /**
             * Ensures an input's required local storage value is being stored,
             * and adds it to the internal GameStarter.ItemsHolder if not. If it
             * is, and the child's value isn't equal to it, the value is set.
             *
             * @param childRaw   An input or select element, or an Array thereof.
             * @param details   Details containing the title of the item and the
             *                  source Function to get its value.
             * @param schema   The container schema this child is within.
             */
            TableGenerator.prototype.ensureLocalStorageInputValue = function (childRaw, details, schema) {
                if (childRaw.constructor === Array) {
                    this.ensureLocalStorageValues(childRaw, details, schema);
                    return;
                }
                var child = childRaw, key = schema.title + "::" + details.title, valueDefault = details.source.call(this, this.GameStarter).toString(), value;
                child.setAttribute("localStorageKey", key);
                this.GameStarter.ItemsHolder.addItem(key, {
                    "storeLocally": true,
                    "valueDefault": valueDefault
                });
                value = this.GameStarter.ItemsHolder.getItem(key);
                if (value !== "" && value !== child.value) {
                    child.value = value;
                    if (child.setValue) {
                        child.setValue(value);
                    }
                    else if (child.onchange) {
                        child.onchange(undefined);
                    }
                    else if (child.onclick) {
                        child.onclick(undefined);
                    }
                }
            };
            /**
             * Ensures a collection of items all exist in localStorage. If their values
             * don't exist, their schema's .callback is used to provide them.
             *
             * @param childRaw   An Array of input or select elements.
             * @param details   Details containing the title of the item and the source
             *                  Function to get its value.
             * @param schema   The container schema this child is within.
             */
            TableGenerator.prototype.ensureLocalStorageValues = function (children, details, schema) {
                var keyGeneral = schema.title + "::" + details.title, values = details.source.call(this, this.GameStarter), key, value, child, i;
                for (i = 0; i < children.length; i += 1) {
                    key = keyGeneral + "::" + i;
                    child = children[i];
                    child.setAttribute("localStorageKey", key);
                    this.GameStarter.ItemsHolder.addItem(key, {
                        "storeLocally": true,
                        "valueDefault": values[i]
                    });
                    value = this.GameStarter.ItemsHolder.getItem(key);
                    if (value !== "" && value !== child.value) {
                        child.value = value;
                        if (child.onchange) {
                            child.onchange(undefined);
                        }
                        else if (child.onclick) {
                            child.onclick(undefined);
                        }
                    }
                }
            };
            /**
             * Stores an element's value in the internal GameStarter.ItemsHolder,
             * if it has the "localStorageKey" attribute.
             *
             * @param {HTMLElement} child   An element with a value to store.
             * @param {Mixed} value   What value is to be stored under the key.
             */
            TableGenerator.prototype.storeLocalStorageValue = function (child, value) {
                var key = child.getAttribute("localStorageKey");
                if (key) {
                    this.GameStarter.ItemsHolder.setItem(key, value);
                    this.GameStarter.ItemsHolder.saveItem(key);
                }
            };
            /**
             * Generators for the value cells within table rows.
             */
            TableGenerator.optionTypes = {
                "Boolean": TableGenerator.prototype.setBooleanInput,
                "Keys": TableGenerator.prototype.setKeyInput,
                "Number": TableGenerator.prototype.setNumberInput,
                "Select": TableGenerator.prototype.setSelectInput,
                "ScreenSize": TableGenerator.prototype.setScreenSizeInput
            };
            return TableGenerator;
        })(UISchemas.OptionsGenerator);
        UISchemas.TableGenerator = TableGenerator;
    })(UISchemas = UserWrappr.UISchemas || (UserWrappr.UISchemas = {}));
})(UserWrappr || (UserWrappr = {}));
var UserWrappr;
(function (UserWrappr_1) {
    "use strict";
    /**
     * A user interface manager made to work on top of GameStartr implementations
     * and provide a configurable HTML display of options.
     */
    var UserWrappr = (function () {
        /**
         * Initializes a new instance of the UserWrappr class.
         *
         * @param settings   Settings to be used for initialization.
         */
        function UserWrappr(settings) {
            /**
             * The document element that will contain the game.
             */
            this.documentElement = document.documentElement;
            /**
             * A browser-dependent method for request to enter full screen mode.
             */
            this.requestFullScreen = (this.documentElement.requestFullScreen
                || this.documentElement.webkitRequestFullScreen
                || this.documentElement.mozRequestFullScreen
                || this.documentElement.msRequestFullscreen
                || function () {
                    alert("Not able to request full screen...");
                }).bind(this.documentElement);
            /**
             * A browser-dependent method for request to exit full screen mode.
             */
            this.cancelFullScreen = (this.documentElement.cancelFullScreen
                || this.documentElement.webkitCancelFullScreen
                || this.documentElement.mozCancelFullScreen
                || this.documentElement.msCancelFullScreen
                || function () {
                    alert("Not able to cancel full screen...");
                }).bind(document);
            if (typeof settings === "undefined") {
                throw new Error("No settings object given to UserWrappr.");
            }
            if (typeof settings.GameStartrConstructor === "undefined") {
                throw new Error("No GameStartrConstructor given to UserWrappr.");
            }
            if (typeof settings.globalName === "undefined") {
                throw new Error("No globalName given to UserWrappr.");
            }
            if (typeof settings.sizes === "undefined") {
                throw new Error("No sizes given to UserWrappr.");
            }
            if (typeof settings.sizeDefault === "undefined") {
                throw new Error("No sizeDefault given to UserWrappr.");
            }
            if (typeof settings.schemas === "undefined") {
                throw new Error("No schemas given to UserWrappr.");
            }
            this.settings = settings;
            this.GameStartrConstructor = settings.GameStartrConstructor;
            this.globalName = settings.globalName;
            this.sizes = this.importSizes(settings.sizes);
            this.customs = settings.customs || {};
            this.gameElementSelector = settings.gameElementSelector || "#game";
            this.gameControlsSelector = settings.gameControlsSelector || "#controls";
            this.logger = settings.logger || console.log.bind(console);
            this.isFullScreen = false;
            this.setCurrentSize(this.sizes[settings.sizeDefault]);
            this.allPossibleKeys = settings.allPossibleKeys || UserWrappr.allPossibleKeys;
            // Size information is also passed to modules via this.customs
            this.GameStartrConstructor.prototype.proliferate(this.customs, this.currentSize, true);
            this.resetGameStarter(settings, this.customs);
        }
        /**
         * Resets the internal GameStarter by storing it under window, adding
         * InputWritr pipes for input to the page, creating the HTML buttons,
         * and setting additional CSS styles and page visiblity.
         *
         * @param settings   Settings for the GameStartr constructor.
         * @param customs   Additional settings for sizing information.
         */
        UserWrappr.prototype.resetGameStarter = function (settings, customs) {
            if (customs === void 0) { customs = {}; }
            this.loadGameStarter(this.fixCustoms(customs));
            window[settings.globalName] = this.GameStarter;
            this.GameStarter.UserWrapper = this;
            this.loadGenerators();
            this.loadControls(settings.schemas);
            if (settings.styleSheet) {
                this.GameStarter.addPageStyles(settings.styleSheet);
            }
            this.resetPageVisibilityHandlers();
            this.GameStarter.gameStart();
            this.startCheckingDevices();
        };
        /* Simple gets
        */
        /**
         * @returns The GameStartr implementation this is wrapping around.
         */
        UserWrappr.prototype.getGameStartrConstructor = function () {
            return this.GameStartrConstructor;
        };
        /**
         * @returns The GameStartr instance created by GameStartrConstructor.
         */
        UserWrappr.prototype.getGameStarter = function () {
            return this.GameStarter;
        };
        /**
         * @returns The ItemsHoldr used to store UI settings.
         */
        UserWrappr.prototype.getItemsHolder = function () {
            return this.ItemsHolder;
        };
        /**
         * @returns The settings used to construct this UserWrappr.
         */
        UserWrappr.prototype.getSettings = function () {
            return this.settings;
        };
        /**
         * @returns The customs used to construct the IGameStartr.
         */
        UserWrappr.prototype.getCustoms = function () {
            return this.customs;
        };
        /**
         * @returns All the keys the user is allowed to pick from in UI controls.
         */
        UserWrappr.prototype.getAllPossibleKeys = function () {
            return this.allPossibleKeys;
        };
        /**
         * @returns The allowed sizes for the game.
         */
        UserWrappr.prototype.getSizes = function () {
            return this.sizes;
        };
        /**
         * @returns The currently selected size for the game.
         */
        UserWrappr.prototype.getCurrentSize = function () {
            return this.currentSize;
        };
        /**
         * @returns Whether the game is currently in full screen mode.
         */
        UserWrappr.prototype.getIsFullScreen = function () {
            return this.isFullScreen;
        };
        /**
         * @returns Whether the page is currently known to be hidden.
         */
        UserWrappr.prototype.getIsPageHidden = function () {
            return this.isPageHidden;
        };
        /**
         * @returns A utility Function to log messages, commonly console.log.
         */
        UserWrappr.prototype.getLogger = function () {
            return this.logger;
        };
        /**
         * @returns Generators used to generate HTML controls for the user.
         */
        UserWrappr.prototype.getGenerators = function () {
            return this.generators;
        };
        /**
         * @returns The document element that contains the game.
         */
        UserWrappr.prototype.getDocumentElement = function () {
            return this.documentElement;
        };
        /**
         * @returns The method to request to enter full screen mode.
         */
        UserWrappr.prototype.getRequestFullScreen = function () {
            return this.requestFullScreen;
        };
        /**
         * @returns The method to request to exit full screen mode.
         */
        UserWrappr.prototype.getCancelFullScreen = function () {
            return this.cancelFullScreen;
        };
        /**
         * @returns The identifier for the device input checking interval.
         */
        UserWrappr.prototype.getDeviceChecker = function () {
            return this.deviceChecker;
        };
        /* Externally allowed sets
        */
        /**
         * Sets the size of the GameStartr by resetting the game with the size
         * information as part of its customs object. Full screen status is
         * changed accordingly.
         *
         * @param size The size to set, as a String to retrieve the size from
         *             known info, or a container of settings.
         */
        UserWrappr.prototype.setCurrentSize = function (size) {
            if (typeof size === "string" || size.constructor === String) {
                if (!this.sizes.hasOwnProperty(size)) {
                    throw new Error("Size " + size + " does not exist on the UserWrappr.");
                }
                size = this.sizes[size];
            }
            this.customs = this.fixCustoms(this.customs);
            if (size.full) {
                this.requestFullScreen();
                this.isFullScreen = true;
            }
            else if (this.isFullScreen) {
                this.cancelFullScreen();
                this.isFullScreen = false;
            }
            this.currentSize = size;
            if (this.GameStarter) {
                this.GameStarter.container.parentNode.removeChild(this.GameStarter.container);
                this.resetGameStarter(this.settings, this.customs);
            }
        };
        /* Devices
        */
        /**
         * Starts the checkDevices loop to scan for gamepad status changes.
         */
        UserWrappr.prototype.startCheckingDevices = function () {
            this.checkDevices();
        };
        /**
         * Calls the DeviceLayer to check for gamepad triggers, after scheduling
         * another checkDevices call via setTimeout.
         */
        UserWrappr.prototype.checkDevices = function () {
            this.deviceChecker = setTimeout(this.checkDevices.bind(this), this.GameStarter.GamesRunner.getPaused()
                ? 117
                : this.GameStarter.GamesRunner.getInterval() / this.GameStarter.GamesRunner.getSpeed());
            this.GameStarter.DeviceLayer.checkNavigatorGamepads();
            this.GameStarter.DeviceLayer.activateAllGamepadTriggers();
        };
        /* Settings parsing
        */
        /**
         * Creates as a copy of the given sizes with names as members.
         *
         * @param sizesRaw   The listing of preset sizes to go by.
         * @returns A copy of sizes, with names as members.
         */
        UserWrappr.prototype.importSizes = function (sizesRaw) {
            var sizes = this.GameStartrConstructor.prototype.proliferate({}, sizesRaw), i;
            for (i in sizes) {
                if (sizes.hasOwnProperty(i)) {
                    sizes[i].name = sizes[i].name || i;
                }
            }
            return sizes;
        };
        /**
         * Creates a copy of the given customs and adjusts sizing information,
         * such as for infinite width or height.
         *
         * @param customsRaw   Raw, user-provided customs.
         */
        UserWrappr.prototype.fixCustoms = function (customsRaw) {
            var customs = this.GameStartrConstructor.prototype.proliferate({}, customsRaw);
            this.GameStartrConstructor.prototype.proliferate(customs, this.currentSize);
            if (!isFinite(customs.width)) {
                customs.width = document.body.clientWidth;
            }
            if (!isFinite(customs.height)) {
                if (customs.full) {
                    customs.height = screen.height;
                }
                else if (this.isFullScreen) {
                    // Guess for browser window...
                    // @todo Actually compute this!
                    customs.height = window.innerHeight - 140;
                }
                else {
                    customs.height = window.innerHeight;
                }
                // 49px from header, 77px from menus
                customs.height -= 126;
            }
            return customs;
        };
        /* Page visibility
        */
        /**
         * Adds a "visibilitychange" handler to the document bound to
         * this.handleVisibilityChange.
         */
        UserWrappr.prototype.resetPageVisibilityHandlers = function () {
            document.addEventListener("visibilitychange", this.handleVisibilityChange.bind(this));
        };
        /**
         * Handles a visibility change event by calling either this.onPageHidden
         * or this.onPageVisible.
         */
        UserWrappr.prototype.handleVisibilityChange = function () {
            switch (document.visibilityState) {
                case "hidden":
                    this.onPageHidden();
                    return;
                case "visible":
                    this.onPageVisible();
                    return;
                default:
                    return;
            }
        };
        /**
         * Reacts to the page becoming hidden by pausing the GameStartr.
         */
        UserWrappr.prototype.onPageHidden = function () {
            if (!this.GameStarter.GamesRunner.getPaused()) {
                this.isPageHidden = true;
                this.GameStarter.GamesRunner.pause();
            }
        };
        /**
         * Reacts to the page becoming visible by unpausing the GameStartr.
         */
        UserWrappr.prototype.onPageVisible = function () {
            if (this.isPageHidden) {
                this.isPageHidden = false;
                this.GameStarter.GamesRunner.play();
            }
        };
        /* Control section loaders
        */
        /**
         * Loads the internal GameStarter, resetting it with the given customs
         * and attaching handlers to document.body and the holder elements.
         *
         * @param customs   Custom arguments to pass to this.GameStarter.
         */
        UserWrappr.prototype.loadGameStarter = function (customs) {
            var section = document.querySelector(this.gameElementSelector);
            if (this.GameStarter) {
                this.GameStarter.GamesRunner.pause();
            }
            this.GameStarter = new this.GameStartrConstructor(customs);
            section.textContent = "";
            section.appendChild(this.GameStarter.container);
            this.GameStarter.proliferate(document.body, {
                "onkeydown": this.GameStarter.InputWriter.makePipe("onkeydown", "keyCode"),
                "onkeyup": this.GameStarter.InputWriter.makePipe("onkeyup", "keyCode")
            });
            this.GameStarter.proliferate(section, {
                "onmousedown": this.GameStarter.InputWriter.makePipe("onmousedown", "which"),
                "oncontextmenu": this.GameStarter.InputWriter.makePipe("oncontextmenu", null, true)
            });
        };
        /**
         * Loads the internal OptionsGenerator instances under this.generators.
         */
        UserWrappr.prototype.loadGenerators = function () {
            this.generators = {
                OptionsButtons: new UserWrappr_1.UISchemas.ButtonsGenerator(this),
                OptionsTable: new UserWrappr_1.UISchemas.TableGenerator(this),
                LevelEditor: new UserWrappr_1.UISchemas.LevelEditorGenerator(this),
                MapsGrid: new UserWrappr_1.UISchemas.MapsGridGenerator(this)
            };
        };
        /**
         * Loads the externally facing UI controls and the internal ItemsHolder,
         * appending the controls to the controls HTML element.
         *
         * @param schemas   The schemas for each UI control to be made.
         */
        UserWrappr.prototype.loadControls = function (schemas) {
            var section = document.querySelector(this.gameControlsSelector), length = schemas.length, i;
            this.ItemsHolder = new ItemsHoldr.ItemsHoldr({
                "prefix": this.globalName + "::UserWrapper::ItemsHolder"
            });
            section.textContent = "";
            section.className = "length-" + length;
            for (i = 0; i < length; i += 1) {
                section.appendChild(this.loadControlDiv(schemas[i]));
            }
        };
        /**
         * Creates an individual UI control element based on a UI schema.
         *
         * @param schemas   The schemas for a UI control to be made.
         * @returns An individual UI control element.
         */
        UserWrappr.prototype.loadControlDiv = function (schema) {
            var control = document.createElement("div"), heading = document.createElement("h4"), inner = document.createElement("div");
            control.className = "control";
            control.id = "control-" + schema.title;
            heading.textContent = schema.title;
            inner.className = "control-inner";
            inner.appendChild(this.generators[schema.generator].generate(schema));
            control.appendChild(heading);
            control.appendChild(inner);
            // Touch events often propogate to children before the control div has
            // been fully extended. Delaying the "active" attribute fixes that.
            control.onmouseover = function () {
                setTimeout(function () {
                    control.setAttribute("active", "on");
                }, 35);
            };
            control.onmouseout = function () {
                control.setAttribute("active", "off");
            };
            return control;
        };
        /**
         * The default list of all allowed keyboard keys.
         */
        UserWrappr.allPossibleKeys = [
            "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m",
            "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
            "up", "right", "down", "left", "space", "shift", "ctrl"
        ];
        return UserWrappr;
    })();
    UserWrappr_1.UserWrappr = UserWrappr;
})(UserWrappr || (UserWrappr = {}));
var WorldSeedr;
(function (WorldSeedr) {
    "use strict";
    /**
     * Utility to generate distances based on possibility schemas.
     */
    var SpacingCalculator = (function () {
        /**
         * Initializes a new instance of the SpacingCalculator class.
         *
         * @param randomBetween
         * @param chooseAmong
         */
        function SpacingCalculator(randomBetween, chooseAmong) {
            this.randomBetween = randomBetween;
            this.chooseAmong = chooseAmong;
        }
        /**
         * Computes a distance from any description of distance possibilities.
         *
         * @param spacing   Any sort of description for a unit of distance.
         * @returns A valid distance for the given spacing description.
         */
        SpacingCalculator.prototype.calculateFromSpacing = function (spacing) {
            if (!spacing) {
                return 0;
            }
            switch (spacing.constructor) {
                case Array:
                    // Case: [min, max]
                    if (spacing[0].constructor === Number) {
                        return this.randomBetween(spacing[0], spacing[1]);
                    }
                    // Case: IPossibilitySpacingOption[]
                    return this.calculateFromPossibilities(spacing);
                case Object:
                    // Case: IPossibilitySpacing
                    return this.calculateFromPossibility(spacing);
                case Number:
                    // Case: Number
                    return spacing;
                default:
                    throw new Error("Unknown spacing requested: '" + spacing + "'.");
            }
        };
        /**
         * Computes a distance from any description of distance possibilities.
         *
         * @param spacing   A description of a range of possibilities for spacing.
         * @returns A valid distance for the given spacing description.
         */
        SpacingCalculator.prototype.calculateFromPossibility = function (spacing) {
            var spacingObject = spacing, min = spacingObject.min, max = spacingObject.max, units = spacingObject.units || 1;
            return this.randomBetween(min / units, max / units) * units;
        };
        /**
         * Computes a distance from any description of distance possibilities.
         *
         * @param spacing   Descriptions of ranges of possibilities for spacing.
         * @returns A valid distance for the given spacing description.
         */
        SpacingCalculator.prototype.calculateFromPossibilities = function (spacing) {
            return this.calculateFromPossibility(this.chooseAmong(spacing).value);
        };
        return SpacingCalculator;
    })();
    WorldSeedr.SpacingCalculator = SpacingCalculator;
})(WorldSeedr || (WorldSeedr = {}));
var WorldSeedr;
(function (WorldSeedr_1) {
    "use strict";
    /**
     * A constant listing of direction opposites, like top-bottom.
     */
    var directionOpposites = {
        "top": "bottom",
        "right": "left",
        "bottom": "top",
        "left": "right"
    };
    /**
     * A constant listing of what direction the sides of areas correspond to.
     */
    var directionSizing = {
        "top": "height",
        "right": "width",
        "bottom": "height",
        "left": "width"
    };
    /**
     * A constant Array of direction names.
     */
    var directionNames = ["top", "right", "bottom", "left"];
    /**
     * A constant Array of the dimension descriptors.
     */
    var sizingNames = ["width", "height"];
    /**
     * A randomization utility to automate random, recursive generation of
     * possibilities based on position and probability schemas.
     */
    var WorldSeedr = (function () {
        /**
         * Initializes a new instance of the WorldSeedr class.
         *
         * @param settings   Settings to be used for initialization.
         */
        function WorldSeedr(settings) {
            if (typeof settings === "undefined") {
                throw new Error("No settings object given to WorldSeedr.");
            }
            if (typeof settings.possibilities === "undefined") {
                throw new Error("No possibilities given to WorldSeedr.");
            }
            this.possibilities = settings.possibilities;
            this.random = settings.random || Math.random.bind(Math);
            this.onPlacement = settings.onPlacement || console.log.bind(console, "Got:");
            this.spacingCalculator = new WorldSeedr_1.SpacingCalculator(this.randomBetween.bind(this), this.chooseAmong.bind(this));
            this.clearGeneratedCommands();
        }
        /* Simple gets & sets
        */
        /**
         * @returns The listing of possibilities that may be generated.
         */
        WorldSeedr.prototype.getPossibilities = function () {
            return this.possibilities;
        };
        /**
         * @param possibilitiesNew   A new Object to list possibilities
         *                           that may be generated.
         */
        WorldSeedr.prototype.setPossibilities = function (possibilities) {
            this.possibilities = possibilities;
        };
        /**
         * @returns Callback for runGeneratedCommands to place "known" children.
         */
        WorldSeedr.prototype.getOnPlacement = function () {
            return this.onPlacement;
        };
        /**
         * @param onPlacementNew   A new Function to be used as onPlacement.
         */
        WorldSeedr.prototype.setOnPlacement = function (onPlacement) {
            this.onPlacement = onPlacement;
        };
        /* Generated commands
        */
        /**
         * Resets the generatedCommands Array so runGeneratedCommands can start.
         */
        WorldSeedr.prototype.clearGeneratedCommands = function () {
            this.generatedCommands = [];
        };
        /**
         * Runs the onPlacement callback on the generatedCommands Array.
         */
        WorldSeedr.prototype.runGeneratedCommands = function () {
            this.onPlacement(this.generatedCommands);
        };
        /* Hardcore generation functions
        */
        /**
         * Generates a collection of randomly chosen possibilities based on the
         * given schema mapping. These does not recursively parse the output; do
         * do that, use generateFull.
         *
         * @param name   The name of the possibility schema to start from.
         * @param position   An Object that contains .left, .right, .top,
         *                   and .bottom.
         * @returns An Object containing a position within the given
         *          position and some number of children.
         */
        WorldSeedr.prototype.generate = function (name, command) {
            var schema = this.possibilities[name];
            if (!schema) {
                throw new Error("No possibility exists under '" + name + "'");
            }
            if (!schema.contents) {
                throw new Error("Possibility '" + name + "' has no possibile outcomes.");
            }
            return this.generateChildren(schema, this.objectCopy(command));
        };
        /**
         * Recursively generates a schema. The schema's title and itself are given
         * to this.generate; all outputs of type "Known" are added to the
         * generatedCommands Array, while everything else is recursed upon.
         *
         * @param schema   A simple Object with basic information on the
         *                 chosen possibility.
         * @returns An Object containing a position within the given
         *          position and some number of children.
         */
        WorldSeedr.prototype.generateFull = function (schema) {
            var generated = this.generate(schema.title, schema), child, i;
            if (!generated || !generated.children) {
                return;
            }
            for (i = 0; i < generated.children.length; i += 1) {
                child = generated.children[i];
                switch (child.type) {
                    case "Known":
                        this.generatedCommands.push(child);
                        break;
                    case "Random":
                        this.generateFull(child);
                        break;
                    default:
                        throw new Error("Unknown child type: " + child.type);
                }
            }
        };
        /**
         * Generates the children for a given schema, position, and direction. This
         * is the real hardcore function called by this.generate, which calls the
         * differnt subroutines based on whether the contents are in "Certain" or
         * "Random" mode.
         *
         * @param schema   A simple Object with basic information on the
         *                 chosen possibility.
         * @param position   The bounding box for where the children may
         *                   be generated.
         * @param [direction]   A String direction to check the position
         *                      by ("top", "right", "bottom", or "left")
         *                      as a default if contents.direction isn't
         *                      provided.
         * @returns An Object containing a position within the given
         *          position and some number of children.
         */
        WorldSeedr.prototype.generateChildren = function (schema, position, direction) {
            var contents = schema.contents, spacing = contents.spacing || 0, objectMerged = this.objectMerge(schema, position), children;
            direction = contents.direction || direction;
            switch (contents.mode) {
                case "Random":
                    children = this.generateRandom(contents, objectMerged, direction, spacing);
                    break;
                case "Certain":
                    children = this.generateCertain(contents, objectMerged, direction, spacing);
                    break;
                case "Repeat":
                    children = this.generateRepeat(contents, objectMerged, direction, spacing);
                    break;
                case "Multiple":
                    children = this.generateMultiple(contents, objectMerged, direction, spacing);
                    break;
                default:
                    throw new Error("Unknown contents mode: " + contents.mode);
            }
            return this.wrapChoicePositionExtremes(children);
        };
        /**
         * Generates a schema's children that are known to follow a set listing of
         * sub-schemas.
         *
         * @param contents   The known possibilities to choose between.
         * @param position   The bounding box for where the children may be
         *                   generated.
         * @param direction   A String direction to check the position by:
         *                    "top", "right", "bottom", or "left".
         * @param spacing   How much space there should be between each child.
         * @returns An Object containing a position within the given position
         *          and some number of children.
         */
        WorldSeedr.prototype.generateCertain = function (contents, position, direction, spacing) {
            var scope = this;
            return contents.children
                .map(function (choice) {
                if (choice.type === "Final") {
                    return scope.parseChoiceFinal(choice, position, direction);
                }
                var output = scope.parseChoice(choice, position, direction);
                if (output) {
                    if (output.type !== "Known") {
                        output.contents = scope.generate(output.title, position);
                    }
                    scope.shrinkPositionByChild(position, output, direction, spacing);
                }
                return output;
            })
                .filter(function (child) {
                return child !== undefined;
            });
        };
        /**
         * Generates a schema's children that are known to follow a set listing of
         * sub-schemas, repeated until there is no space left.
         *
         * @param contents   The known possibilities to choose between.
         * @param position   The bounding box for where the children may be
         *                   generated.
         * @param direction   A String direction to check the position by:
         *                    "top", "right", "bottom", or "left".
         * @param spacing   How much space there should be between each child.
         * @returns An Object containing a position within the given position
         *          and some number of children.
         */
        WorldSeedr.prototype.generateRepeat = function (contents, position, direction, spacing) {
            var choices = contents.children, children = [], choice, child, i = 0;
            // Continuously loops through the choices and adds them to the output
            // children, so long as there's still room for them
            while (this.positionIsNotEmpty(position, direction)) {
                choice = choices[i];
                if (choice.type === "Final") {
                    child = this.parseChoiceFinal(choice, position, direction);
                }
                else {
                    child = this.parseChoice(choice, position, direction);
                    if (child && child.type !== "Known") {
                        child.contents = this.generate(child.title, position);
                    }
                }
                if (child && this.choiceFitsPosition(child, position)) {
                    this.shrinkPositionByChild(position, child, direction, spacing);
                    children.push(child);
                }
                else {
                    break;
                }
                i += 1;
                if (i >= choices.length) {
                    i = 0;
                }
            }
            return children;
        };
        /**
         * Generates a schema's children that are known to be randomly chosen from a
         * list of possibilities until there is no more room.
         *
         * @param contents   The Array of known possibilities, with probability
         *                   percentages.
         * @param position   An Object that contains .left, .right, .top,
         *                   and .bottom.
         * @param direction   A String direction to check the position by:
         *                    "top", "right", "bottom", or "left".
         * @param spacing   How much space there should be between each child.
         * @returns An Object containing a position within the given position
         *          and some number of children.
         */
        WorldSeedr.prototype.generateRandom = function (contents, position, direction, spacing) {
            var children = [], child;
            // Continuously add random choices to the output children as long as 
            // there's room in the position's bounding box
            while (this.positionIsNotEmpty(position, direction)) {
                child = this.generateChild(contents, position, direction);
                if (!child) {
                    break;
                }
                this.shrinkPositionByChild(position, child, direction, spacing);
                children.push(child);
                if (contents.limit && children.length > contents.limit) {
                    return;
                }
            }
            return children;
        };
        /**
         * Generates a schema's children that are all to be placed within the same
         * position. If a direction is provided, each subsequent one is shifted in
         * that direction by spacing.
         *
         * @param contents   The Array of known possibilities, with probability
         *                   percentages.
         * @param position   An Object that contains .left, .right, .top,
         *                   and .bottom.
         * @param [direction]   A String direction to check the position by:
         *                      "top", "right", "bottom", or "left".
         * @param [spacing]   How much space there should be between each child.
         * @returns An Object containing a position within the given position
         *          and some number of children.
         */
        WorldSeedr.prototype.generateMultiple = function (contents, position, direction, spacing) {
            var scope = this;
            return contents.children.map(function (choice) {
                var output = scope.parseChoice(choice, scope.objectCopy(position), direction);
                if (direction) {
                    scope.movePositionBySpacing(position, direction, spacing);
                }
                return output;
            });
        };
        /* Choice parsing
        */
        /**
         * Shortcut function to choose a choice from an allowed set of choices, and
         * parse it for positioning and sub-choices.
         *
         * @param contents   Choice Objects, each of which must have a .percentage.
         * @param position   An Object that contains .left, .right, .top, and .bottom.
         * @param direction   A String direction to check the position by:
         *                    "top", "right", "bottom", or "left".
         * @returns An Object containing the bounding box position of a parsed child,
         *          with the basic schema (.title) info added as well as any optional
         *          .arguments.
         */
        WorldSeedr.prototype.generateChild = function (contents, position, direction) {
            var choice = this.chooseAmongPosition(contents.children, position);
            if (!choice) {
                return undefined;
            }
            return this.parseChoice(choice, position, direction);
        };
        /**
         * Creates a parsed version of a choice given the position and direction.
         * This is the function that parses and manipulates the positioning of the
         * new choice.
         *
         * @param choice   The simple definition of the Object chosen from a choices
         *                 Array. It should have at least .title,
         *                          and optionally .sizing or .arguments.
         * @param position   An Object that contains .left, .right, .top, and .bottom.
         * @param direction   A String direction to shrink the position by: "top",
         *                    "right", "bottom", or "left".
         * @returns An Object containing the bounding box position of a parsed child,
         *          with the basic schema (.title) info added as well as any optional
         *          .arguments.
         */
        WorldSeedr.prototype.parseChoice = function (choice, position, direction) {
            var title = choice.title, schema = this.possibilities[title], output = {
                "title": title,
                "type": choice.type,
                "arguments": choice.arguments instanceof Array
                    ? (this.chooseAmong(choice.arguments)).values
                    : choice.arguments,
                "width": undefined,
                "height": undefined,
                "top": undefined,
                "right": undefined,
                "bottom": undefined,
                "left": undefined
            };
            this.ensureSizingOnChoice(output, choice, schema);
            this.ensureDirectionBoundsOnChoice(output, position);
            output[direction] = output[directionOpposites[direction]] + output[directionSizing[direction]];
            switch (schema.contents.snap) {
                case "top":
                    output.bottom = output.top - output.height;
                    break;
                case "right":
                    output.left = output.right - output.width;
                    break;
                case "bottom":
                    output.top = output.bottom + output.height;
                    break;
                case "left":
                    output.right = output.left + output.width;
                    break;
                default:
                    break;
            }
            if (choice.stretch) {
                if (!output.arguments) {
                    output.arguments = {};
                }
                if (choice.stretch.width) {
                    output.left = position.left;
                    output.right = position.right;
                    output.width = output.right - output.left;
                    output.arguments.width = output.width;
                }
                if (choice.stretch.height) {
                    output.top = position.top;
                    output.bottom = position.bottom;
                    output.height = output.top - output.bottom;
                    output.arguments.height = output.height;
                }
            }
            return output;
        };
        /**
         * Parses a "Final" choice as a simple IChoice of type Known.
         *
         * @param choice   The simple definition of the Object chosen from a choices
         *                 Array. It should have at least .title,
         *                          and optionally .sizing or .arguments.
         * @param position   An Object that contains .left, .right, .top, and .bottom.
         * @param direction   A String direction to shrink the position by: "top",
         *                    "right", "bottom", or "left".
         * @returns A Known choice with title, arguments, and position information.
         * @todo Investigate whether this is necessary (#7).
         */
        WorldSeedr.prototype.parseChoiceFinal = function (choice, position, direction) {
            var schema = this.possibilities[choice.source], output = {
                "type": "Known",
                "title": choice.title,
                "arguments": choice.arguments,
                "width": schema.width,
                "height": schema.height,
                "top": position.top,
                "right": position.right,
                "bottom": position.bottom,
                "left": position.left
            };
            return output;
        };
        /* Randomization utilities
        */
        /**
         * From an Array of potential choice Objects, returns one chosen at random.
         *
         * @param choice   An Array of objects with .percent.
         * @returns One of the choice Objects, chosen at random.
         */
        WorldSeedr.prototype.chooseAmong = function (choices) {
            if (!choices.length) {
                return undefined;
            }
            if (choices.length === 1) {
                return choices[0];
            }
            var choice = this.randomPercentage(), sum = 0, i;
            for (i = 0; i < choices.length; i += 1) {
                sum += choices[i].percent;
                if (sum >= choice) {
                    return choices[i];
                }
            }
        };
        /**
         * From an Array of potential choice Objects, filtered to only include those
         * within a certain size, returns one chosen at random.
         *
         * @param choice   An Array of objects with .width and .height.
         * @param position   An Object that contains .left, .right, .top, and .bottom.
         * @returns A random choice Object that can fit within the position's size.
         * @remarks Functions that use this will have to react to nothing being
         *          chosen. For example, if only 50 percentage is accumulated
         *          among fitting ones but 75 is randomly chosen, something should
         *          still be returned.
         */
        WorldSeedr.prototype.chooseAmongPosition = function (choices, position) {
            var width = position.right - position.left, height = position.top - position.bottom, scope = this;
            return this.chooseAmong(choices.filter(function (choice) {
                return scope.choiceFitsSize(scope.possibilities[choice.title], width, height);
            }));
        };
        /**
         * Checks whether a choice can fit within a width and height.
         *
         * @param choice   An Object that contains .width and .height.
         * @param width   A maximum width for the choice.
         * @param height   A maximum height for the choice.
         * @returns Whether the choice fits within the dimensions.
         */
        WorldSeedr.prototype.choiceFitsSize = function (choice, width, height) {
            return choice.width <= width && choice.height <= height;
        };
        /**
         * Checks whether a choice can fit within a position.
         *
         * @param choice   An Object that contains .width and .height.
         * @param position   An Object that contains .left, .right, .top, and .bottom.
         * @returns Whether the choice fits within the position.
         * @remarks When calling multiple times on a position (such as in
         *          chooseAmongPosition), it's more efficient to store the width
         *          and height separately and just use doesChoiceFit.
         */
        WorldSeedr.prototype.choiceFitsPosition = function (choice, position) {
            return this.choiceFitsSize(choice, position.right - position.left, position.top - position.bottom);
        };
        /* Position manipulation utilities
        */
        /**
         * Checks and returns whether a position has open room in a particular
         * direction (horizontally for left/right and vertically for top/bottom).
         *
         * @param position   An Object that contains .left, .right, .top, and .bottom.
         * @param direction   A String direction to check the position in:
         *                    "top", "right", "bottom", or "left".
         */
        WorldSeedr.prototype.positionIsNotEmpty = function (position, direction) {
            if (direction === "right" || direction === "left") {
                return position.left < position.right;
            }
            else {
                return position.top > position.bottom;
            }
        };
        /**
         * Shrinks a position by the size of a child, in a particular direction.
         *
         * @param position   An Object that contains .left, .right, .top, and .bottom.
         * @param child   An Object that contains .left, .right, .top, and .bottom.
         * @param direction   A String direction to shrink the position by:
         *                    "top", "right", "bottom", or "left".
         * @param [spacing]   How much space there should be between each child
         *                    (by default, 0).
         */
        WorldSeedr.prototype.shrinkPositionByChild = function (position, child, direction, spacing) {
            if (spacing === void 0) { spacing = 0; }
            switch (direction) {
                case "top":
                    position.bottom = child.top + this.spacingCalculator.calculateFromSpacing(spacing);
                    break;
                case "right":
                    position.left = child.right + this.spacingCalculator.calculateFromSpacing(spacing);
                    break;
                case "bottom":
                    position.top = child.bottom - this.spacingCalculator.calculateFromSpacing(spacing);
                    break;
                case "left":
                    position.right = child.left - this.spacingCalculator.calculateFromSpacing(spacing);
                    break;
                default:
                    break;
            }
        };
        /**
         * Moves a position by its parsed spacing. This is only useful for content
         * of type "Multiple", which are allowed to move themselves via spacing
         * between placements.
         *
         * @param position   An Object that contains .left, .right, .top, and .bottom.
         * @param direction   A String direction to shrink the position by:
         *                    "top", "right", "bottom", or "left".
         * @param [spacing]   How much space there should be between each child
         *                    (by default, 0).
         */
        WorldSeedr.prototype.movePositionBySpacing = function (position, direction, spacing) {
            if (spacing === void 0) { spacing = 0; }
            var space = this.spacingCalculator.calculateFromSpacing(spacing);
            switch (direction) {
                case "top":
                    position.top += space;
                    position.bottom += space;
                    break;
                case "right":
                    position.left += space;
                    position.right += space;
                    break;
                case "bottom":
                    position.top -= space;
                    position.bottom -= space;
                    break;
                case "left":
                    position.left -= space;
                    position.right -= space;
                    break;
                default:
                    throw new Error("Unknown direction: " + direction);
            }
        };
        /**
         * Generates the bounding box position Object (think rectangle) for a set of
         * children. The top, right, etc. member variables become the most extreme
         * out of all the possibilities.
         *
         * @param children   An Array of Objects with .top, .right, .bottom, and .left.
         * @returns An Object with .top, .right, .bottom, and .left.
         */
        WorldSeedr.prototype.wrapChoicePositionExtremes = function (children) {
            var position, child, i;
            if (!children || !children.length) {
                return undefined;
            }
            child = children[0];
            position = {
                "title": undefined,
                "top": child.top,
                "right": child.right,
                "bottom": child.bottom,
                "left": child.left,
                "width": undefined,
                "height": undefined,
                "children": children
            };
            if (children.length === 1) {
                return position;
            }
            for (i = 1; i < children.length; i += 1) {
                child = children[i];
                if (!Object.keys(child).length) {
                    return position;
                }
                position.top = Math.max(position.top, child.top);
                position.right = Math.max(position.right, child.right);
                position.bottom = Math.min(position.bottom, child.bottom);
                position.left = Math.min(position.left, child.left);
            }
            position.width = position.right - position.left;
            position.height = position.top - position.bottom;
            return position;
        };
        /**
         * Ensures an output from parseChoice contains all the necessary size
         * measurements, as listed in this.sizingNames.
         *
         * @param output   The Object (likely a parsed possibility content)
         *                 having its arguments modified.
         * @param choice   The definition of the Object chosen from a choices Array.
         * @param schema   An Object with basic information on the chosen possibility.
         */
        WorldSeedr.prototype.ensureSizingOnChoice = function (output, choice, schema) {
            var name, i;
            for (i in sizingNames) {
                if (!sizingNames.hasOwnProperty(i)) {
                    continue;
                }
                name = sizingNames[i];
                output[name] = (choice.sizing && typeof choice.sizing[name] !== "undefined")
                    ? choice.sizing[name]
                    : schema[name];
            }
        };
        /**
         * Ensures an output from parseChoice contains all the necessary position
         * bounding box measurements, as listed in this.directionNames.
         *
         * @param output   The Object (likely a parsed possibility content)
         *                 having its arguments modified.
         *                          chosen possibility.
         * @param position   An Object that contains .left, .right, .top, and .bottom.
         */
        WorldSeedr.prototype.ensureDirectionBoundsOnChoice = function (output, position) {
            var i;
            for (i in directionNames) {
                if (directionNames.hasOwnProperty(i)) {
                    output[directionNames[i]] = position[directionNames[i]];
                }
            }
        };
        /* General utilities
        */
        /**
         * @returns A number in [1, 100] at random.
         */
        WorldSeedr.prototype.randomPercentage = function () {
            return Math.floor(this.random() * 100) + 1;
        };
        /**
         * @returns A number in [min, max] at random.
         */
        WorldSeedr.prototype.randomBetween = function (min, max) {
            return Math.floor(this.random() * (1 + max - min)) + min;
        };
        /**
         * Creates and returns a copy of an Object, as a shallow copy.
         *
         * @param original   An Object to copy.
         * @returns A shallow copy of the original.
         */
        WorldSeedr.prototype.objectCopy = function (original) {
            var output = {}, i;
            for (i in original) {
                if (original.hasOwnProperty(i)) {
                    output[i] = original[i];
                }
            }
            return output;
        };
        /**
         * Creates a new object with all required attributes taking from the
         * primary source or secondary source, in that order of precedence.
         *
         * @param primary   A primary source for the output.
         * @param secondary   A secondary source for the output.
         * @returns A new Object with properties from primary and secondary.
         */
        WorldSeedr.prototype.objectMerge = function (primary, secondary) {
            var output = this.objectCopy(primary), i;
            for (i in secondary) {
                if (secondary.hasOwnProperty(i) && !output.hasOwnProperty(i)) {
                    output[i] = secondary[i];
                }
            }
            return output;
        };
        return WorldSeedr;
    })();
    WorldSeedr_1.WorldSeedr = WorldSeedr;
})(WorldSeedr || (WorldSeedr = {}));
/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2013 Einar Lielmanis and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

 JS Beautifier
---------------


  Written by Einar Lielmanis, <einar@jsbeautifier.org>
      http://jsbeautifier.org/

  Originally converted to javascript by Vital, <vital76@gmail.com>
  "End braces on own line" added by Chris J. Shull, <chrisjshull@gmail.com>
  Parsing improvements for brace-less statements by Liam Newman <bitwiseman@gmail.com>


  Usage:
    js_beautify(js_source_text);
    js_beautify(js_source_text, options);

  The options are:
    indent_size (default 4)          - indentation size,
    indent_char (default space)      - character to indent with,
    preserve_newlines (default true) - whether existing line breaks should be preserved,
    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk,

    jslint_happy (default false) - if true, then jslint-stricter mode is enforced.

            jslint_happy       !jslint_happy
            ---------------------------------
            function ()        function ()

    brace_style (default "collapse") - "collapse" | "expand" | "end-expand"
            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line.

    space_before_conditional (default true) - should the space before conditional statement be added, "if (true)" vs "if (true)",

    unescape_strings (default false) - should printable characters in strings encoded in \xNN notation be unescaped, "example" vs "\x65\x78\x61\x6d\x70\x6c\x65"

    wrap_line_length (default unlimited) - lines should wrap at next opportunity after this number of characters.
          NOTE: This is not a hard limit. Lines will continue until a point where a newline would
                be preserved if it were present.

    e.g

    js_beautify(js_source_text, {
      'indent_size': 1,
      'indent_char': '\t'
    });

*/
(function () {
    var acorn = {};
    (function (exports) {
        // This section of code is taken from acorn.
        //
        // Acorn was written by Marijn Haverbeke and released under an MIT
        // license. The Unicode regexps (for identifiers and whitespace) were
        // taken from [Esprima](http://esprima.org) by Ariya Hidayat.
        //
        // Git repositories for Acorn are available at
        //
        //     http://marijnhaverbeke.nl/git/acorn
        //     https://github.com/marijnh/acorn.git
        // ## Character categories
        // Big ugly regular expressions that match characters in the
        // whitespace, identifier, and identifier-start categories. These
        // are only applied when a character is found to actually have a
        // code point above 128.
        var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
        var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
        var nonASCIIidentifierChars = "\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
        var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
        var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
        // Whether a single character denotes a newline.
        var newline = /[\n\r\u2028\u2029]/;
        // Matches a whole line break (where CRLF is considered a single
        // line break). Used to count lines.
        var lineBreak = /\r\n|[\n\r\u2028\u2029]/g;
        // Test whether a given character code starts an identifier.
        var isIdentifierStart = exports.isIdentifierStart = function (code) {
            if (code < 65)
                return code === 36;
            if (code < 91)
                return true;
            if (code < 97)
                return code === 95;
            if (code < 123)
                return true;
            return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
        };
        // Test whether a given character is part of an identifier.
        var isIdentifierChar = exports.isIdentifierChar = function (code) {
            if (code < 48)
                return code === 36;
            if (code < 58)
                return true;
            if (code < 65)
                return false;
            if (code < 91)
                return true;
            if (code < 97)
                return code === 95;
            if (code < 123)
                return true;
            return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
        };
    })(acorn);
    function js_beautify(js_source_text, options) {
        "use strict";
        var beautifier = new Beautifier(js_source_text, options);
        return beautifier.beautify();
    }
    function Beautifier(js_source_text, options) {
        "use strict";
        var input, output_lines;
        var token_text, token_type, last_type, last_last_text, indent_string;
        var flags, previous_flags, flag_store;
        var whitespace, wordchar, punct, parser_pos, line_starters, reserved_words, digits;
        var prefix;
        var input_wanted_newline;
        var output_space_before_token;
        var input_length, n_newlines, whitespace_before_token;
        var handlers, MODE, opt;
        var preindent_string = '';
        whitespace = "\n\r\t ".split('');
        wordchar = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_$'.split('');
        digits = '0123456789'.split('');
        punct = '+ - * / % & ++ -- = += -= *= /= %= == === != !== > < >= <= >> << >>> >>>= >>= <<= && &= | || ! ~ , : ? ^ ^= |= :: =>';
        punct += ' <%= <% %> <?= <? ?>'; // try to be a good boy and try not to break the markup language identifiers
        punct = punct.split(' ');
        // words which should always start on new line.
        line_starters = 'continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,yield'.split(',');
        reserved_words = line_starters.concat(['do', 'in', 'else', 'get', 'set', 'new', 'catch', 'finally', 'typeof']);
        MODE = {
            BlockStatement: 'BlockStatement',
            Statement: 'Statement',
            ObjectLiteral: 'ObjectLiteral',
            ArrayLiteral: 'ArrayLiteral',
            ForInitializer: 'ForInitializer',
            Conditional: 'Conditional',
            Expression: 'Expression' //'(EXPRESSION)'
        };
        handlers = {
            'TK_START_EXPR': handle_start_expr,
            'TK_END_EXPR': handle_end_expr,
            'TK_START_BLOCK': handle_start_block,
            'TK_END_BLOCK': handle_end_block,
            'TK_WORD': handle_word,
            'TK_RESERVED': handle_word,
            'TK_SEMICOLON': handle_semicolon,
            'TK_STRING': handle_string,
            'TK_EQUALS': handle_equals,
            'TK_OPERATOR': handle_operator,
            'TK_COMMA': handle_comma,
            'TK_BLOCK_COMMENT': handle_block_comment,
            'TKInLINE_COMMENT': handleInline_comment,
            'TK_COMMENT': handle_comment,
            'TK_DOT': handle_dot,
            'TK_UNKNOWN': handle_unknown
        };
        function create_flags(flags_base, mode) {
            var nextIndent_level = 0;
            if (flags_base) {
                nextIndent_level = flags_base.indentation_level;
                if (!justAdded_newline() &&
                    flags_base.lineIndent_level > nextIndent_level) {
                    nextIndent_level = flags_base.lineIndent_level;
                }
            }
            var next_flags = {
                mode: mode,
                parent: flags_base,
                last_text: flags_base ? flags_base.last_text : '',
                last_word: flags_base ? flags_base.last_word : '',
                declaration_statement: false,
                declaration_assignment: false,
                in_html_comment: false,
                multiline_frame: false,
                if_block: false,
                else_block: false,
                do_block: false,
                do_while: false,
                in_case_statement: false,
                in_case: false,
                case_body: false,
                indentation_level: nextIndent_level,
                lineIndent_level: flags_base ? flags_base.lineIndent_level : nextIndent_level,
                start_lineIndex: output_lines.length,
                had_comment: false,
                ternary_depth: 0
            };
            return next_flags;
        }
        // Using object instead of string to allow for later expansion of info about each line
        function createOutput_line() {
            return {
                text: []
            };
        }
        // Some interpreters have unexpected results with foo = baz || bar;
        options = options ? options : {};
        opt = {};
        // compatibility
        if (options.spaceAfter_anon_function !== undefined && options.jslint_happy === undefined) {
            options.jslint_happy = options.spaceAfter_anon_function;
        }
        if (options.braces_on_own_line !== undefined) {
            opt.brace_style = options.braces_on_own_line ? "expand" : "collapse";
        }
        opt.brace_style = options.brace_style ? options.brace_style : (opt.brace_style ? opt.brace_style : "collapse");
        // graceful handling of deprecated option
        if (opt.brace_style === "expand-strict") {
            opt.brace_style = "expand";
        }
        opt.indent_size = options.indent_size ? parseInt(options.indent_size, 10) : 4;
        opt.indent_char = options.indent_char ? options.indent_char : ' ';
        opt.preserve_newlines = (options.preserve_newlines === undefined) ? true : options.preserve_newlines;
        opt.break_chained_methods = (options.break_chained_methods === undefined) ? false : options.break_chained_methods;
        opt.max_preserve_newlines = (options.max_preserve_newlines === undefined) ? 0 : parseInt(options.max_preserve_newlines, 10);
        opt.spaceIn_paren = (options.spaceIn_paren === undefined) ? false : options.spaceIn_paren;
        opt.spaceIn_empty_paren = (options.spaceIn_empty_paren === undefined) ? false : options.spaceIn_empty_paren;
        opt.jslint_happy = (options.jslint_happy === undefined) ? false : options.jslint_happy;
        opt.keep_arrayIndentation = (options.keep_arrayIndentation === undefined) ? false : options.keep_arrayIndentation;
        opt.space_before_conditional = (options.space_before_conditional === undefined) ? true : options.space_before_conditional;
        opt.unescape_strings = (options.unescape_strings === undefined) ? false : options.unescape_strings;
        opt.wrap_line_length = (options.wrap_line_length === undefined) ? 0 : parseInt(options.wrap_line_length, 10);
        opt.e4x = (options.e4x === undefined) ? false : options.e4x;
        if (options.indent_with_tabs) {
            opt.indent_char = '\t';
            opt.indent_size = 1;
        }
        //----------------------------------
        indent_string = '';
        while (opt.indent_size > 0) {
            indent_string += opt.indent_char;
            opt.indent_size -= 1;
        }
        while (js_source_text && (js_source_text.charAt(0) === ' ' || js_source_text.charAt(0) === '\t')) {
            preindent_string += js_source_text.charAt(0);
            js_source_text = js_source_text.substring(1);
        }
        input = js_source_text;
        // cache the source's length.
        input_length = js_source_text.length;
        last_type = 'TK_START_BLOCK'; // last token type
        last_last_text = ''; // pre-last token text
        output_lines = [createOutput_line()];
        output_space_before_token = false;
        whitespace_before_token = [];
        // Stack of parsing/formatting states, including MODE.
        // We tokenize, parse, and output in an almost purely a forward-only stream of token input
        // and formatted output.  This makes the beautifier less accurate than full parsers
        // but also far more tolerant of syntax errors.
        //
        // For example, the default mode is MODE.BlockStatement. If we see a '{' we push a new frame of type
        // MODE.BlockStatement on the the stack, even though it could be object literal.  If we later
        // encounter a ":", we'll switch to to MODE.ObjectLiteral.  If we then see a ";",
        // most full parsers would die, but the beautifier gracefully falls back to
        // MODE.BlockStatement and continues on.
        flag_store = [];
        set_mode(MODE.BlockStatement);
        parser_pos = 0;
        this.beautify = function () {
            /*jshint onevar:true */
            var t, i, keep_whitespace, sweet_code;
            while (true) {
                t = get_next_token();
                token_text = t[0];
                token_type = t[1];
                if (token_type === 'TK_EOF') {
                    // Unwind any open statements
                    while (flags.mode === MODE.Statement) {
                        restore_mode();
                    }
                    break;
                }
                keep_whitespace = opt.keep_arrayIndentation && is_array(flags.mode);
                input_wanted_newline = n_newlines > 0;
                if (keep_whitespace) {
                    for (i = 0; i < n_newlines; i += 1) {
                        print_newline(i > 0);
                    }
                }
                else {
                    if (opt.max_preserve_newlines && n_newlines > opt.max_preserve_newlines) {
                        n_newlines = opt.max_preserve_newlines;
                    }
                    if (opt.preserve_newlines) {
                        if (n_newlines > 1) {
                            print_newline();
                            for (i = 1; i < n_newlines; i += 1) {
                                print_newline(true);
                            }
                        }
                    }
                }
                handlers[token_type]();
                // The cleanest handling of inline comments is to treat them as though they aren't there.
                // Just continue formatting and the behavior should be logical.
                // Also ignore unknown tokens.  Again, this should result in better behavior.
                if (token_type !== 'TKInLINE_COMMENT' && token_type !== 'TK_COMMENT' &&
                    token_type !== 'TK_BLOCK_COMMENT' && token_type !== 'TK_UNKNOWN') {
                    last_last_text = flags.last_text;
                    last_type = token_type;
                    flags.last_text = token_text;
                }
                flags.had_comment = (token_type === 'TKInLINE_COMMENT' || token_type === 'TK_COMMENT'
                    || token_type === 'TK_BLOCK_COMMENT');
            }
            sweet_code = output_lines[0].text.join('');
            for (var lineIndex = 1; lineIndex < output_lines.length; lineIndex++) {
                sweet_code += '\n' + output_lines[lineIndex].text.join('');
            }
            sweet_code = sweet_code.replace(/[\r\n ]+$/, '');
            return sweet_code;
        };
        function trimOutput(eat_newlines) {
            eat_newlines = (eat_newlines === undefined) ? false : eat_newlines;
            if (output_lines.length) {
                trimOutput_line(output_lines[output_lines.length - 1]);
                while (eat_newlines && output_lines.length > 1 &&
                    output_lines[output_lines.length - 1].text.length === 0) {
                    output_lines.pop();
                    trimOutput_line(output_lines[output_lines.length - 1]);
                }
            }
        }
        function trimOutput_line(line) {
            while (line.text.length &&
                (line.text[line.text.length - 1] === ' ' ||
                    line.text[line.text.length - 1] === indent_string ||
                    line.text[line.text.length - 1] === preindent_string)) {
                line.text.pop();
            }
        }
        function trim(s) {
            return s.replace(/^\s+|\s+$/g, '');
        }
        // we could use just string.split, but
        // IE doesn't like returning empty strings
        function split_newlines(s) {
            //return s.split(/\x0d\x0a|\x0a/);
            s = s.replace(/\x0d/g, '');
            var out = [], idx = s.indexOf("\n");
            while (idx !== -1) {
                out.push(s.substring(0, idx));
                s = s.substring(idx + 1);
                idx = s.indexOf("\n");
            }
            if (s.length) {
                out.push(s);
            }
            return out;
        }
        function justAdded_newline() {
            var line = output_lines[output_lines.length - 1];
            return line.text.length === 0;
        }
        function justAdded_blankline() {
            if (justAdded_newline()) {
                if (output_lines.length === 1) {
                    return true; // start of the file and newline = blank
                }
                var line = output_lines[output_lines.length - 2];
                return line.text.length === 0;
            }
            return false;
        }
        function allow_wrap_or_preserved_newline(force_linewrap) {
            force_linewrap = (force_linewrap === undefined) ? false : force_linewrap;
            if (opt.wrap_line_length && !force_linewrap) {
                var line = output_lines[output_lines.length - 1];
                var proposed_line_length = 0;
                // never wrap the first token of a line.
                if (line.text.length > 0) {
                    proposed_line_length = line.text.join('').length + token_text.length +
                        (output_space_before_token ? 1 : 0);
                    if (proposed_line_length >= opt.wrap_line_length) {
                        force_linewrap = true;
                    }
                }
            }
            if (((opt.preserve_newlines && input_wanted_newline) || force_linewrap) && !justAdded_newline()) {
                print_newline(false, true);
            }
        }
        function print_newline(force_newline, preserve_statement_flags) {
            output_space_before_token = false;
            if (!preserve_statement_flags) {
                if (flags.last_text !== ';' && flags.last_text !== ',' && flags.last_text !== '=' && last_type !== 'TK_OPERATOR') {
                    while (flags.mode === MODE.Statement && !flags.if_block && !flags.do_block) {
                        restore_mode();
                    }
                }
            }
            if (output_lines.length === 1 && justAdded_newline()) {
                return; // no newline on start of file
            }
            if (force_newline || !justAdded_newline()) {
                flags.multiline_frame = true;
                output_lines.push(createOutput_line());
            }
        }
        function print_token_lineIndentation() {
            if (justAdded_newline()) {
                var line = output_lines[output_lines.length - 1];
                if (opt.keep_arrayIndentation && is_array(flags.mode) && input_wanted_newline) {
                    // prevent removing of this whitespace as redundant
                    line.text.push('');
                    for (var i = 0; i < whitespace_before_token.length; i += 1) {
                        line.text.push(whitespace_before_token[i]);
                    }
                }
                else {
                    if (preindent_string) {
                        line.text.push(preindent_string);
                    }
                    printIndent_string(flags.indentation_level);
                }
            }
        }
        function printIndent_string(level) {
            // Never indent your first output indent at the start of the file
            if (output_lines.length > 1) {
                var line = output_lines[output_lines.length - 1];
                flags.lineIndent_level = level;
                for (var i = 0; i < level; i += 1) {
                    line.text.push(indent_string);
                }
            }
        }
        function print_token_space_before() {
            var line = output_lines[output_lines.length - 1];
            if (output_space_before_token && line.text.length) {
                var lastOutput = line.text[line.text.length - 1];
                if (lastOutput !== ' ' && lastOutput !== indent_string) {
                    line.text.push(' ');
                }
            }
        }
        function print_token(printable_token) {
            printable_token = printable_token || token_text;
            print_token_lineIndentation();
            print_token_space_before();
            output_space_before_token = false;
            output_lines[output_lines.length - 1].text.push(printable_token);
        }
        function indent() {
            flags.indentation_level += 1;
        }
        function deindent() {
            if (flags.indentation_level > 0 &&
                ((!flags.parent) || flags.indentation_level > flags.parent.indentation_level))
                flags.indentation_level -= 1;
        }
        function remove_redundantIndentation(frame) {
            // This implementation is effective but has some issues:
            //     - less than great performance due to array splicing
            //     - can cause line wrap to happen too soon due to indent removal
            //           after wrap points are calculated
            // These issues are minor compared to ugly indentation.
            if (frame.multiline_frame)
                return;
            // remove one indent from each line inside this section
            var index = frame.start_lineIndex;
            var spliceIndex = 0;
            var line;
            while (index < output_lines.length) {
                line = output_lines[index];
                index++;
                // skip empty lines
                if (line.text.length === 0) {
                    continue;
                }
                // skip the preindent string if present
                if (preindent_string && line.text[0] === preindent_string) {
                    spliceIndex = 1;
                }
                else {
                    spliceIndex = 0;
                }
                // remove one indent, if present
                if (line.text[spliceIndex] === indent_string) {
                    line.text.splice(spliceIndex, 1);
                }
            }
        }
        function set_mode(mode) {
            if (flags) {
                flag_store.push(flags);
                previous_flags = flags;
            }
            else {
                previous_flags = create_flags(null, mode);
            }
            flags = create_flags(previous_flags, mode);
        }
        function is_array(mode) {
            return mode === MODE.ArrayLiteral;
        }
        function is_expression(mode) {
            return in_array(mode, [MODE.Expression, MODE.ForInitializer, MODE.Conditional]);
        }
        function restore_mode() {
            if (flag_store.length > 0) {
                previous_flags = flags;
                flags = flag_store.pop();
                if (previous_flags.mode === MODE.Statement) {
                    remove_redundantIndentation(previous_flags);
                }
            }
        }
        function start_of_object_property() {
            return flags.parent.mode === MODE.ObjectLiteral && flags.mode === MODE.Statement && flags.last_text === ':' &&
                flags.ternary_depth === 0;
        }
        function start_of_statement() {
            if ((last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const']) && token_type === 'TK_WORD') ||
                (last_type === 'TK_RESERVED' && flags.last_text === 'do') ||
                (last_type === 'TK_RESERVED' && flags.last_text === 'return' && !input_wanted_newline) ||
                (last_type === 'TK_RESERVED' && flags.last_text === 'else' && !(token_type === 'TK_RESERVED' && token_text === 'if')) ||
                (last_type === 'TK_END_EXPR' && (previous_flags.mode === MODE.ForInitializer || previous_flags.mode === MODE.Conditional)) ||
                (last_type === 'TK_WORD' && flags.mode === MODE.BlockStatement
                    && !flags.in_case
                    && !(token_text === '--' || token_text === '++')
                    && token_type !== 'TK_WORD' && token_type !== 'TK_RESERVED') ||
                (flags.mode === MODE.ObjectLiteral && flags.last_text === ':' && flags.ternary_depth === 0)) {
                set_mode(MODE.Statement);
                indent();
                if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const']) && token_type === 'TK_WORD') {
                    flags.declaration_statement = true;
                }
                // Issue #276:
                // If starting a new statement with [if, for, while, do], push to a new line.
                // if (a) if (b) if (c) d(); else e(); else f();
                if (!start_of_object_property()) {
                    allow_wrap_or_preserved_newline(token_type === 'TK_RESERVED' && in_array(token_text, ['do', 'for', 'if', 'while']));
                }
                return true;
            }
            return false;
        }
        function all_lines_start_with(lines, c) {
            for (var i = 0; i < lines.length; i++) {
                var line = trim(lines[i]);
                if (line.charAt(0) !== c) {
                    return false;
                }
            }
            return true;
        }
        function each_line_matchesIndent(lines, indent) {
            var i = 0, len = lines.length, line;
            for (; i < len; i++) {
                line = lines[i];
                // allow empty lines to pass through
                if (line && line.indexOf(indent) !== 0) {
                    return false;
                }
            }
            return true;
        }
        function is_special_word(word) {
            return in_array(word, ['case', 'return', 'do', 'if', 'throw', 'else']);
        }
        function in_array(what, arr) {
            for (var i = 0; i < arr.length; i += 1) {
                if (arr[i] === what) {
                    return true;
                }
            }
            return false;
        }
        function unescape_string(s) {
            var esc = false, out = '', pos = 0, s_hex = '', escaped = 0, c;
            while (esc || pos < s.length) {
                c = s.charAt(pos);
                pos++;
                if (esc) {
                    esc = false;
                    if (c === 'x') {
                        // simple hex-escape \x24
                        s_hex = s.substr(pos, 2);
                        pos += 2;
                    }
                    else if (c === 'u') {
                        // unicode-escape, \u2134
                        s_hex = s.substr(pos, 4);
                        pos += 4;
                    }
                    else {
                        // some common escape, e.g \n
                        out += '\\' + c;
                        continue;
                    }
                    if (!s_hex.match(/^[0123456789abcdefABCDEF]+$/)) {
                        // some weird escaping, bail out,
                        // leaving whole string intact
                        return s;
                    }
                    escaped = parseInt(s_hex, 16);
                    if (escaped >= 0x00 && escaped < 0x20) {
                        // leave 0x00...0x1f escaped
                        if (c === 'x') {
                            out += '\\x' + s_hex;
                        }
                        else {
                            out += '\\u' + s_hex;
                        }
                        continue;
                    }
                    else if (escaped === 0x22 || escaped === 0x27 || escaped === 0x5c) {
                        // single-quote, apostrophe, backslash - escape these
                        out += '\\' + String.fromCharCode(escaped);
                    }
                    else if (c === 'x' && escaped > 0x7e && escaped <= 0xff) {
                        // we bail out on \x7f..\xff,
                        // leaving whole string escaped,
                        // as it's probably completely binary
                        return s;
                    }
                    else {
                        out += String.fromCharCode(escaped);
                    }
                }
                else if (c === '\\') {
                    esc = true;
                }
                else {
                    out += c;
                }
            }
            return out;
        }
        function is_next(find) {
            var local_pos = parser_pos;
            var c = input.charAt(local_pos);
            while (in_array(c, whitespace) && c !== find) {
                local_pos++;
                if (local_pos >= input_length) {
                    return false;
                }
                c = input.charAt(local_pos);
            }
            return c === find;
        }
        function get_next_token() {
            var i, resulting_string;
            n_newlines = 0;
            if (parser_pos >= input_length) {
                return ['', 'TK_EOF'];
            }
            input_wanted_newline = false;
            whitespace_before_token = [];
            var c = input.charAt(parser_pos);
            parser_pos += 1;
            while (in_array(c, whitespace)) {
                if (c === '\n') {
                    n_newlines += 1;
                    whitespace_before_token = [];
                }
                else if (n_newlines) {
                    if (c === indent_string) {
                        whitespace_before_token.push(indent_string);
                    }
                    else if (c !== '\r') {
                        whitespace_before_token.push(' ');
                    }
                }
                if (parser_pos >= input_length) {
                    return ['', 'TK_EOF'];
                }
                c = input.charAt(parser_pos);
                parser_pos += 1;
            }
            // NOTE: because beautifier doesn't fully parse, it doesn't use acorn.isIdentifierStart.
            // It just treats all identifiers and numbers and such the same.
            if (acorn.isIdentifierChar(input.charCodeAt(parser_pos - 1))) {
                if (parser_pos < input_length) {
                    while (acorn.isIdentifierChar(input.charCodeAt(parser_pos))) {
                        c += input.charAt(parser_pos);
                        parser_pos += 1;
                        if (parser_pos === input_length) {
                            break;
                        }
                    }
                }
                // small and surprisingly unugly hack for 1E-10 representation
                if (parser_pos !== input_length && c.match(/^[0-9]+[Ee]$/) && (input.charAt(parser_pos) === '-' || input.charAt(parser_pos) === '+')) {
                    var sign = input.charAt(parser_pos);
                    parser_pos += 1;
                    var t = get_next_token();
                    c += sign + t[0];
                    return [c, 'TK_WORD'];
                }
                if (!(last_type === 'TK_DOT' ||
                    (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['set', 'get'])))
                    && in_array(c, reserved_words)) {
                    if (c === 'in') {
                        return [c, 'TK_OPERATOR'];
                    }
                    return [c, 'TK_RESERVED'];
                }
                return [c, 'TK_WORD'];
            }
            if (c === '(' || c === '[') {
                return [c, 'TK_START_EXPR'];
            }
            if (c === ')' || c === ']') {
                return [c, 'TK_END_EXPR'];
            }
            if (c === '{') {
                return [c, 'TK_START_BLOCK'];
            }
            if (c === '}') {
                return [c, 'TK_END_BLOCK'];
            }
            if (c === ';') {
                return [c, 'TK_SEMICOLON'];
            }
            if (c === '/') {
                var comment = '';
                // peek for comment /* ... */
                var inline_comment = true;
                if (input.charAt(parser_pos) === '*') {
                    parser_pos += 1;
                    if (parser_pos < input_length) {
                        while (parser_pos < input_length && !(input.charAt(parser_pos) === '*' && input.charAt(parser_pos + 1) && input.charAt(parser_pos + 1) === '/')) {
                            c = input.charAt(parser_pos);
                            comment += c;
                            if (c === "\n" || c === "\r") {
                                inline_comment = false;
                            }
                            parser_pos += 1;
                            if (parser_pos >= input_length) {
                                break;
                            }
                        }
                    }
                    parser_pos += 2;
                    if (inline_comment && n_newlines === 0) {
                        return ['/*' + comment + '*/', 'TKInLINE_COMMENT'];
                    }
                    else {
                        return ['/*' + comment + '*/', 'TK_BLOCK_COMMENT'];
                    }
                }
                // peek for comment // ...
                if (input.charAt(parser_pos) === '/') {
                    comment = c;
                    while (input.charAt(parser_pos) !== '\r' && input.charAt(parser_pos) !== '\n') {
                        comment += input.charAt(parser_pos);
                        parser_pos += 1;
                        if (parser_pos >= input_length) {
                            break;
                        }
                    }
                    return [comment, 'TK_COMMENT'];
                }
            }
            if (c === '`' || c === "'" || c === '"' ||
                ((c === '/') ||
                    (opt.e4x && c === "<" && input.slice(parser_pos - 1).match(/^<([-a-zA-Z:0-9_.]+|{[^{}]*}|!\[CDATA\[[\s\S]*?\]\])\s*([-a-zA-Z:0-9_.]+=('[^']*'|"[^"]*"|{[^{}]*})\s*)*\/?\s*>/)) // xml
                ) && ((last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) ||
                    (last_type === 'TK_END_EXPR' && in_array(previous_flags.mode, [MODE.Conditional, MODE.ForInitializer])) ||
                    (in_array(last_type, ['TK_COMMENT', 'TK_START_EXPR', 'TK_START_BLOCK',
                        'TK_END_BLOCK', 'TK_OPERATOR', 'TK_EQUALS', 'TK_EOF', 'TK_SEMICOLON', 'TK_COMMA'
                    ])))) {
                var sep = c, esc = false, has_char_escapes = false;
                resulting_string = c;
                if (parser_pos < input_length) {
                    if (sep === '/') {
                        //
                        // handle regexp
                        //
                        var in_char_class = false;
                        while (esc || in_char_class || input.charAt(parser_pos) !== sep) {
                            resulting_string += input.charAt(parser_pos);
                            if (!esc) {
                                esc = input.charAt(parser_pos) === '\\';
                                if (input.charAt(parser_pos) === '[') {
                                    in_char_class = true;
                                }
                                else if (input.charAt(parser_pos) === ']') {
                                    in_char_class = false;
                                }
                            }
                            else {
                                esc = false;
                            }
                            parser_pos += 1;
                            if (parser_pos >= input_length) {
                                // incomplete string/rexp when end-of-file reached.
                                // bail out with what had been received so far.
                                return [resulting_string, 'TK_STRING'];
                            }
                        }
                    }
                    else if (opt.e4x && sep === '<') {
                        //
                        // handle e4x xml literals
                        //
                        var xmlRegExp = /<(\/?)([-a-zA-Z:0-9_.]+|{[^{}]*}|!\[CDATA\[[\s\S]*?\]\])\s*([-a-zA-Z:0-9_.]+=('[^']*'|"[^"]*"|{[^{}]*})\s*)*(\/?)\s*>/g;
                        var xmlStr = input.slice(parser_pos - 1);
                        var match = xmlRegExp.exec(xmlStr);
                        if (match && match.index === 0) {
                            var rootTag = match[2];
                            var depth = 0;
                            while (match) {
                                var isEndTag = !!match[1];
                                var tagName = match[2];
                                var isSingletonTag = (!!match[match.length - 1]) || (tagName.slice(0, 8) === "![CDATA[");
                                if (tagName === rootTag && !isSingletonTag) {
                                    if (isEndTag) {
                                        --depth;
                                    }
                                    else {
                                        ++depth;
                                    }
                                }
                                if (depth <= 0) {
                                    break;
                                }
                                match = xmlRegExp.exec(xmlStr);
                            }
                            var xmlLength = match ? match.index + match[0].length : xmlStr.length;
                            parser_pos += xmlLength - 1;
                            return [xmlStr.slice(0, xmlLength), "TK_STRING"];
                        }
                    }
                    else {
                        //
                        // handle string
                        //
                        while (esc || input.charAt(parser_pos) !== sep) {
                            resulting_string += input.charAt(parser_pos);
                            if (esc) {
                                if (input.charAt(parser_pos) === 'x' || input.charAt(parser_pos) === 'u') {
                                    has_char_escapes = true;
                                }
                                esc = false;
                            }
                            else {
                                esc = input.charAt(parser_pos) === '\\';
                            }
                            parser_pos += 1;
                            if (parser_pos >= input_length) {
                                // incomplete string/rexp when end-of-file reached.
                                // bail out with what had been received so far.
                                return [resulting_string, 'TK_STRING'];
                            }
                        }
                    }
                }
                parser_pos += 1;
                resulting_string += sep;
                if (has_char_escapes && opt.unescape_strings) {
                    resulting_string = unescape_string(resulting_string);
                }
                if (sep === '/') {
                    // regexps may have modifiers /regexp/MOD , so fetch those, too
                    while (parser_pos < input_length && in_array(input.charAt(parser_pos), wordchar)) {
                        resulting_string += input.charAt(parser_pos);
                        parser_pos += 1;
                    }
                }
                return [resulting_string, 'TK_STRING'];
            }
            if (c === '#') {
                if (output_lines.length === 1 && output_lines[0].text.length === 0 &&
                    input.charAt(parser_pos) === '!') {
                    // shebang
                    resulting_string = c;
                    while (parser_pos < input_length && c !== '\n') {
                        c = input.charAt(parser_pos);
                        resulting_string += c;
                        parser_pos += 1;
                    }
                    return [trim(resulting_string) + '\n', 'TK_UNKNOWN'];
                }
                // Spidermonkey-specific sharp variables for circular references
                // https://developer.mozilla.org/En/SharpVariablesIn_JavaScript
                // http://mxr.mozilla.org/mozilla-central/source/js/src/jsscan.cpp around line 1935
                var sharp = '#';
                if (parser_pos < input_length && in_array(input.charAt(parser_pos), digits)) {
                    do {
                        c = input.charAt(parser_pos);
                        sharp += c;
                        parser_pos += 1;
                    } while (parser_pos < input_length && c !== '#' && c !== '=');
                    if (c === '#') {
                    }
                    else if (input.charAt(parser_pos) === '[' && input.charAt(parser_pos + 1) === ']') {
                        sharp += '[]';
                        parser_pos += 2;
                    }
                    else if (input.charAt(parser_pos) === '{' && input.charAt(parser_pos + 1) === '}') {
                        sharp += '{}';
                        parser_pos += 2;
                    }
                    return [sharp, 'TK_WORD'];
                }
            }
            if (c === '<' && input.substring(parser_pos - 1, parser_pos + 3) === '<!--') {
                parser_pos += 3;
                c = '<!--';
                while (input.charAt(parser_pos) !== '\n' && parser_pos < input_length) {
                    c += input.charAt(parser_pos);
                    parser_pos++;
                }
                flags.in_html_comment = true;
                return [c, 'TK_COMMENT'];
            }
            if (c === '-' && flags.in_html_comment && input.substring(parser_pos - 1, parser_pos + 2) === '-->') {
                flags.in_html_comment = false;
                parser_pos += 2;
                return ['-->', 'TK_COMMENT'];
            }
            if (c === '.') {
                return [c, 'TK_DOT'];
            }
            if (in_array(c, punct)) {
                while (parser_pos < input_length && in_array(c + input.charAt(parser_pos), punct)) {
                    c += input.charAt(parser_pos);
                    parser_pos += 1;
                    if (parser_pos >= input_length) {
                        break;
                    }
                }
                if (c === ',') {
                    return [c, 'TK_COMMA'];
                }
                else if (c === '=') {
                    return [c, 'TK_EQUALS'];
                }
                else {
                    return [c, 'TK_OPERATOR'];
                }
            }
            return [c, 'TK_UNKNOWN'];
        }
        function handle_start_expr() {
            if (start_of_statement()) {
            }
            var next_mode = MODE.Expression;
            if (token_text === '[') {
                if (last_type === 'TK_WORD' || flags.last_text === ')') {
                    // this is array index specifier, break immediately
                    // a[x], fn()[x]
                    if (last_type === 'TK_RESERVED' && in_array(flags.last_text, line_starters)) {
                        output_space_before_token = true;
                    }
                    set_mode(next_mode);
                    print_token();
                    indent();
                    if (opt.spaceIn_paren) {
                        output_space_before_token = true;
                    }
                    return;
                }
                next_mode = MODE.ArrayLiteral;
                if (is_array(flags.mode)) {
                    if (flags.last_text === '[' ||
                        (flags.last_text === ',' && (last_last_text === ']' || last_last_text === '}'))) {
                        // ], [ goes to new line
                        // }, [ goes to new line
                        if (!opt.keep_arrayIndentation) {
                            print_newline();
                        }
                    }
                }
            }
            else {
                if (last_type === 'TK_RESERVED' && flags.last_text === 'for') {
                    next_mode = MODE.ForInitializer;
                }
                else if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['if', 'while'])) {
                    next_mode = MODE.Conditional;
                }
                else {
                }
            }
            if (flags.last_text === ';' || last_type === 'TK_START_BLOCK') {
                print_newline();
            }
            else if (last_type === 'TK_END_EXPR' || last_type === 'TK_START_EXPR' || last_type === 'TK_END_BLOCK' || flags.last_text === '.') {
                // TODO: Consider whether forcing this is required.  Review failing tests when removed.
                allow_wrap_or_preserved_newline(input_wanted_newline);
            }
            else if (!(last_type === 'TK_RESERVED' && token_text === '(') && last_type !== 'TK_WORD' && last_type !== 'TK_OPERATOR') {
                output_space_before_token = true;
            }
            else if ((last_type === 'TK_RESERVED' && (flags.last_word === 'function' || flags.last_word === 'typeof')) ||
                (flags.last_text === '*' && last_last_text === 'function')) {
                // function () vs function ()
                if (opt.jslint_happy) {
                    output_space_before_token = true;
                }
            }
            else if (last_type === 'TK_RESERVED' && (in_array(flags.last_text, line_starters) || flags.last_text === 'catch')) {
                if (opt.space_before_conditional) {
                    output_space_before_token = true;
                }
            }
            // Support of this kind of newline preservation.
            // a = (b &&
            //     (c || d));
            if (token_text === '(') {
                if (last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
                    if (!start_of_object_property()) {
                        allow_wrap_or_preserved_newline();
                    }
                }
            }
            set_mode(next_mode);
            print_token();
            if (opt.spaceIn_paren) {
                output_space_before_token = true;
            }
            // In all cases, if we newline while inside an expression it should be indented.
            indent();
        }
        function handle_end_expr() {
            // statements inside expressions are not valid syntax, but...
            // statements must all be closed when their container closes
            while (flags.mode === MODE.Statement) {
                restore_mode();
            }
            if (flags.multiline_frame) {
                allow_wrap_or_preserved_newline(token_text === ']' && is_array(flags.mode) && !opt.keep_arrayIndentation);
            }
            if (opt.spaceIn_paren) {
                if (last_type === 'TK_START_EXPR' && !opt.spaceIn_empty_paren) {
                    // () [] no inner space in empty parens like these, ever, ref #320
                    trimOutput();
                    output_space_before_token = false;
                }
                else {
                    output_space_before_token = true;
                }
            }
            if (token_text === ']' && opt.keep_arrayIndentation) {
                print_token();
                restore_mode();
            }
            else {
                restore_mode();
                print_token();
            }
            remove_redundantIndentation(previous_flags);
            // do {} while () // no statement required after
            if (flags.do_while && previous_flags.mode === MODE.Conditional) {
                previous_flags.mode = MODE.Expression;
                flags.do_block = false;
                flags.do_while = false;
            }
        }
        function handle_start_block() {
            set_mode(MODE.BlockStatement);
            var empty_braces = is_next('}');
            var empty_anonymous_function = empty_braces && flags.last_word === 'function' &&
                last_type === 'TK_END_EXPR';
            if (opt.brace_style === "expand") {
                if (last_type !== 'TK_OPERATOR' &&
                    (empty_anonymous_function ||
                        last_type === 'TK_EQUALS' ||
                        (last_type === 'TK_RESERVED' && is_special_word(flags.last_text) && flags.last_text !== 'else'))) {
                    output_space_before_token = true;
                }
                else {
                    print_newline(false, true);
                }
            }
            else {
                if (last_type !== 'TK_OPERATOR' && last_type !== 'TK_START_EXPR') {
                    if (last_type === 'TK_START_BLOCK') {
                        print_newline();
                    }
                    else {
                        output_space_before_token = true;
                    }
                }
                else {
                    // if TK_OPERATOR or TK_START_EXPR
                    if (is_array(previous_flags.mode) && flags.last_text === ',') {
                        if (last_last_text === '}') {
                            // }, { in array context
                            output_space_before_token = true;
                        }
                        else {
                            print_newline(); // [a, b, c, {
                        }
                    }
                }
            }
            print_token();
            indent();
        }
        function handle_end_block() {
            // statements must all be closed when their container closes
            while (flags.mode === MODE.Statement) {
                restore_mode();
            }
            var empty_braces = last_type === 'TK_START_BLOCK';
            if (opt.brace_style === "expand") {
                if (!empty_braces) {
                    print_newline();
                }
            }
            else {
                // skip {}
                if (!empty_braces) {
                    if (is_array(flags.mode) && opt.keep_arrayIndentation) {
                        // we REALLY need a newline here, but newliner would skip that
                        opt.keep_arrayIndentation = false;
                        print_newline();
                        opt.keep_arrayIndentation = true;
                    }
                    else {
                        print_newline();
                    }
                }
            }
            restore_mode();
            print_token();
        }
        function handle_word() {
            if (start_of_statement()) {
            }
            else if (input_wanted_newline && !is_expression(flags.mode) &&
                (last_type !== 'TK_OPERATOR' || (flags.last_text === '--' || flags.last_text === '++')) &&
                last_type !== 'TK_EQUALS' &&
                (opt.preserve_newlines || !(last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const', 'set', 'get'])))) {
                print_newline();
            }
            if (flags.do_block && !flags.do_while) {
                if (token_type === 'TK_RESERVED' && token_text === 'while') {
                    // do {} ## while ()
                    output_space_before_token = true;
                    print_token();
                    output_space_before_token = true;
                    flags.do_while = true;
                    return;
                }
                else {
                    // do {} should always have while as the next word.
                    // if we don't see the expected while, recover
                    print_newline();
                    flags.do_block = false;
                }
            }
            // if may be followed by else, or not
            // Bare/inline ifs are tricky
            // Need to unwind the modes correctly: if (a) if (b) c(); else d(); else e();
            if (flags.if_block) {
                if (!flags.else_block && (token_type === 'TK_RESERVED' && token_text === 'else')) {
                    flags.else_block = true;
                }
                else {
                    while (flags.mode === MODE.Statement) {
                        restore_mode();
                    }
                    flags.if_block = false;
                    flags.else_block = false;
                }
            }
            if (token_type === 'TK_RESERVED' && (token_text === 'case' || (token_text === 'default' && flags.in_case_statement))) {
                print_newline();
                if (flags.case_body || opt.jslint_happy) {
                    // switch cases following one another
                    deindent();
                    flags.case_body = false;
                }
                print_token();
                flags.in_case = true;
                flags.in_case_statement = true;
                return;
            }
            if (token_type === 'TK_RESERVED' && token_text === 'function') {
                if (in_array(flags.last_text, ['}', ';']) || (justAdded_newline() && !in_array(flags.last_text, ['[', '{', ':', '=', ',']))) {
                    // make sure there is a nice clean space of at least one blank line
                    // before a new function definition
                    if (!justAdded_blankline() && !flags.had_comment) {
                        print_newline();
                        print_newline(true);
                    }
                }
                if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD') {
                    if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set', 'new', 'return'])) {
                        output_space_before_token = true;
                    }
                    else {
                        print_newline();
                    }
                }
                else if (last_type === 'TK_OPERATOR' || flags.last_text === '=') {
                    // foo = function
                    output_space_before_token = true;
                }
                else if (is_expression(flags.mode)) {
                }
                else {
                    print_newline();
                }
            }
            if (last_type === 'TK_COMMA' || last_type === 'TK_START_EXPR' || last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
                if (!start_of_object_property()) {
                    allow_wrap_or_preserved_newline();
                }
            }
            if (token_type === 'TK_RESERVED' && token_text === 'function') {
                print_token();
                flags.last_word = token_text;
                return;
            }
            prefix = 'NONE';
            if (last_type === 'TK_END_BLOCK') {
                if (!(token_type === 'TK_RESERVED' && in_array(token_text, ['else', 'catch', 'finally']))) {
                    prefix = 'NEWLINE';
                }
                else {
                    if (opt.brace_style === "expand" || opt.brace_style === "end-expand") {
                        prefix = 'NEWLINE';
                    }
                    else {
                        prefix = 'SPACE';
                        output_space_before_token = true;
                    }
                }
            }
            else if (last_type === 'TK_SEMICOLON' && flags.mode === MODE.BlockStatement) {
                // TODO: Should this be for STATEMENT as well?
                prefix = 'NEWLINE';
            }
            else if (last_type === 'TK_SEMICOLON' && is_expression(flags.mode)) {
                prefix = 'SPACE';
            }
            else if (last_type === 'TK_STRING') {
                prefix = 'NEWLINE';
            }
            else if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD' ||
                (flags.last_text === '*' && last_last_text === 'function')) {
                prefix = 'SPACE';
            }
            else if (last_type === 'TK_START_BLOCK') {
                prefix = 'NEWLINE';
            }
            else if (last_type === 'TK_END_EXPR') {
                output_space_before_token = true;
                prefix = 'NEWLINE';
            }
            if (token_type === 'TK_RESERVED' && in_array(token_text, line_starters) && flags.last_text !== ')') {
                if (flags.last_text === 'else') {
                    prefix = 'SPACE';
                }
                else {
                    prefix = 'NEWLINE';
                }
            }
            if (token_type === 'TK_RESERVED' && in_array(token_text, ['else', 'catch', 'finally'])) {
                if (last_type !== 'TK_END_BLOCK' || opt.brace_style === "expand" || opt.brace_style === "end-expand") {
                    print_newline();
                }
                else {
                    trimOutput(true);
                    var line = output_lines[output_lines.length - 1];
                    // If we trimmed and there's something other than a close block before us
                    // put a newline back in.  Handles '} // comment' scenario.
                    if (line.text[line.text.length - 1] !== '}') {
                        print_newline();
                    }
                    output_space_before_token = true;
                }
            }
            else if (prefix === 'NEWLINE') {
                if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {
                    // no newline between 'return nnn'
                    output_space_before_token = true;
                }
                else if (last_type !== 'TK_END_EXPR') {
                    if ((last_type !== 'TK_START_EXPR' || !(token_type === 'TK_RESERVED' && in_array(token_text, ['var', 'let', 'const']))) && flags.last_text !== ':') {
                        // no need to force newline on 'var': for (var x = 0...)
                        if (token_type === 'TK_RESERVED' && token_text === 'if' && flags.last_word === 'else' && flags.last_text !== '{') {
                            // no newline for } else if {
                            output_space_before_token = true;
                        }
                        else {
                            print_newline();
                        }
                    }
                }
                else if (token_type === 'TK_RESERVED' && in_array(token_text, line_starters) && flags.last_text !== ')') {
                    print_newline();
                }
            }
            else if (is_array(flags.mode) && flags.last_text === ',' && last_last_text === '}') {
                print_newline(); // }, in lists get a newline treatment
            }
            else if (prefix === 'SPACE') {
                output_space_before_token = true;
            }
            print_token();
            flags.last_word = token_text;
            if (token_type === 'TK_RESERVED' && token_text === 'do') {
                flags.do_block = true;
            }
            if (token_type === 'TK_RESERVED' && token_text === 'if') {
                flags.if_block = true;
            }
        }
        function handle_semicolon() {
            if (start_of_statement()) {
                // The conditional starts the statement if appropriate.
                // Semicolon can be the start (and end) of a statement
                output_space_before_token = false;
            }
            while (flags.mode === MODE.Statement && !flags.if_block && !flags.do_block) {
                restore_mode();
            }
            print_token();
            if (flags.mode === MODE.ObjectLiteral) {
                // if we're in OBJECT mode and see a semicolon, its invalid syntax
                // recover back to treating this as a BLOCK
                flags.mode = MODE.BlockStatement;
            }
        }
        function handle_string() {
            if (start_of_statement()) {
                // The conditional starts the statement if appropriate.
                // One difference - strings want at least a space before
                output_space_before_token = true;
            }
            else if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD') {
                output_space_before_token = true;
            }
            else if (last_type === 'TK_COMMA' || last_type === 'TK_START_EXPR' || last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
                if (!start_of_object_property()) {
                    allow_wrap_or_preserved_newline();
                }
            }
            else {
                print_newline();
            }
            print_token();
        }
        function handle_equals() {
            if (start_of_statement()) {
            }
            if (flags.declaration_statement) {
                // just got an '=' in a var-line, different formatting/line-breaking, etc will now be done
                flags.declaration_assignment = true;
            }
            output_space_before_token = true;
            print_token();
            output_space_before_token = true;
        }
        function handle_comma() {
            if (flags.declaration_statement) {
                if (is_expression(flags.parent.mode)) {
                    // do not break on comma, for (var a = 1, b = 2)
                    flags.declaration_assignment = false;
                }
                print_token();
                if (flags.declaration_assignment) {
                    flags.declaration_assignment = false;
                    print_newline(false, true);
                }
                else {
                    output_space_before_token = true;
                }
                return;
            }
            print_token();
            if (flags.mode === MODE.ObjectLiteral ||
                (flags.mode === MODE.Statement && flags.parent.mode === MODE.ObjectLiteral)) {
                if (flags.mode === MODE.Statement) {
                    restore_mode();
                }
                print_newline();
            }
            else {
                // EXPR or DO_BLOCK
                output_space_before_token = true;
            }
        }
        function handle_operator() {
            // Check if this is a BlockStatement that should be treated as a ObjectLiteral
            if (token_text === ':' && flags.mode === MODE.BlockStatement &&
                last_last_text === '{' &&
                (last_type === 'TK_WORD' || last_type === 'TK_RESERVED')) {
                flags.mode = MODE.ObjectLiteral;
            }
            if (start_of_statement()) {
            }
            var space_before = true;
            var spaceAfter = true;
            if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {
                // "return" had a special handling in TK_WORD. Now we need to return the favor
                output_space_before_token = true;
                print_token();
                return;
            }
            // hack for actionscript's import .*;
            if (token_text === '*' && last_type === 'TK_DOT' && !last_last_text.match(/^\d+$/)) {
                print_token();
                return;
            }
            if (token_text === ':' && flags.in_case) {
                flags.case_body = true;
                indent();
                print_token();
                print_newline();
                flags.in_case = false;
                return;
            }
            if (token_text === '::') {
                // no spaces around exotic namespacing syntax operator
                print_token();
                return;
            }
            // http://www.ecma-international.org/ecma-262/5.1/#sec-7.9.1
            // if there is a newline between -- or ++ and anything else we should preserve it.
            if (input_wanted_newline && (token_text === '--' || token_text === '++')) {
                print_newline(false, true);
            }
            // Allow line wrapping between operators
            if (last_type === 'TK_OPERATOR') {
                allow_wrap_or_preserved_newline();
            }
            if (in_array(token_text, ['--', '++', '!', '~']) || (in_array(token_text, ['-', '+']) && (in_array(last_type, ['TK_START_BLOCK', 'TK_START_EXPR', 'TK_EQUALS', 'TK_OPERATOR']) || in_array(flags.last_text, line_starters) || flags.last_text === ','))) {
                // unary operators (and binary +/- pretending to be unary) special cases
                space_before = false;
                spaceAfter = false;
                if (flags.last_text === ';' && is_expression(flags.mode)) {
                    // for (;; ++i)
                    //        ^^^
                    space_before = true;
                }
                if (last_type === 'TK_RESERVED' || last_type === 'TK_END_EXPR') {
                    space_before = true;
                }
                if ((flags.mode === MODE.BlockStatement || flags.mode === MODE.Statement) && (flags.last_text === '{' || flags.last_text === ';')) {
                    // { foo; --i }
                    // foo(); --bar;
                    print_newline();
                }
            }
            else if (token_text === ':') {
                if (flags.ternary_depth === 0) {
                    if (flags.mode === MODE.BlockStatement) {
                        flags.mode = MODE.ObjectLiteral;
                    }
                    space_before = false;
                }
                else {
                    flags.ternary_depth -= 1;
                }
            }
            else if (token_text === '?') {
                flags.ternary_depth += 1;
            }
            else if (token_text === '*' && last_type === 'TK_RESERVED' && flags.last_text === 'function') {
                space_before = false;
                spaceAfter = false;
            }
            output_space_before_token = output_space_before_token || space_before;
            print_token();
            output_space_before_token = spaceAfter;
        }
        function handle_block_comment() {
            var lines = split_newlines(token_text);
            var j; // iterator for this case
            var javadoc = false;
            var starless = false;
            var lastIndent = whitespace_before_token.join('');
            var lastIndentLength = lastIndent.length;
            // block comment starts with a new line
            print_newline(false, true);
            if (lines.length > 1) {
                if (all_lines_start_with(lines.slice(1), '*')) {
                    javadoc = true;
                }
                else if (each_line_matchesIndent(lines.slice(1), lastIndent)) {
                    starless = true;
                }
            }
            // first line always indented
            print_token(lines[0]);
            for (j = 1; j < lines.length; j++) {
                print_newline(false, true);
                if (javadoc) {
                    // javadoc: reformat and re-indent
                    print_token(' ' + trim(lines[j]));
                }
                else if (starless && lines[j].length > lastIndentLength) {
                    // starless: re-indent non-empty content, avoiding trim
                    print_token(lines[j].substring(lastIndentLength));
                }
                else {
                    // normal comments output raw
                    output_lines[output_lines.length - 1].text.push(lines[j]);
                }
            }
            // for comments of more than one line, make sure there's a new line after
            print_newline(false, true);
        }
        function handleInline_comment() {
            output_space_before_token = true;
            print_token();
            output_space_before_token = true;
        }
        function handle_comment() {
            if (input_wanted_newline) {
                print_newline(false, true);
            }
            else {
                trimOutput(true);
            }
            output_space_before_token = true;
            print_token();
            print_newline(false, true);
        }
        function handle_dot() {
            if (start_of_statement()) {
            }
            if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {
                output_space_before_token = true;
            }
            else {
                // allow preserved newlines before dots in general
                // force newlines on dots after close paren when break_chained - for bar().baz()
                allow_wrap_or_preserved_newline(flags.last_text === ')' && opt.break_chained_methods);
            }
            print_token();
        }
        function handle_unknown() {
            print_token();
            if (token_text[token_text.length - 1] === '\n') {
                print_newline();
            }
        }
    }
    if (typeof define === "function" && define.amd) {
        // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
        define([], function () {
            return { js_beautify: js_beautify };
        });
    }
    else if (typeof exports !== "undefined") {
        // Add support for CommonJS. Just put this file somewhere on your require.paths
        // and you will be able to `var js_beautify = require("beautify").js_beautify`.
        exports.js_beautify = js_beautify;
    }
    else if (typeof window !== "undefined") {
        // If we're running a web page and don't have either of the above, add our one global
        window.js_beautify = js_beautify;
    }
    else if (typeof global !== "undefined") {
        // If we don't even have window, try global.
        global.js_beautify = js_beautify;
    }
}());
/// <reference path="AreaSpawnr-0.2.0.ts" />
/// <reference path="AudioPlayr-0.2.1.ts" />
/// <reference path="ChangeLinr-0.2.0.ts" />
/// <reference path="DeviceLayr-0.2.0.ts" />
/// <reference path="EightBittr-0.2.0.ts" />
/// <reference path="FPSAnalyzr-0.2.1.ts" />
/// <reference path="GamesRunnr-0.2.0.ts" />
/// <reference path="GroupHoldr-0.2.1.ts" />
/// <reference path="InputWritr-0.2.0.ts" />
/// <reference path="ItemsHoldr-0.2.1.ts" />
/// <reference path="LevelEditr-0.2.0.ts" />
/// <reference path="MapsCreatr-0.2.1.ts" />
/// <reference path="MapScreenr-0.2.1.ts" />
/// <reference path="MathDecidr-0.2.0.ts" />
/// <reference path="ModAttachr-0.2.2.ts" />
/// <reference path="NumberMakr-0.2.2.ts" />
/// <reference path="ObjectMakr-0.2.2.ts" />
/// <reference path="PixelDrawr-0.2.0.ts" />
/// <reference path="PixelRendr-0.2.0.ts" />
/// <reference path="QuadsKeepr-0.2.1.ts" />
/// <reference path="ScenePlayr-0.2.0.ts" />
/// <reference path="StringFilr-0.2.1.ts" />
/// <reference path="ThingHittr-0.2.0.ts" />
/// <reference path="TimeHandlr-0.2.0.ts" />
/// <reference path="TouchPassr-0.2.0.ts" />
/// <reference path="UsageHelpr-0.2.0.ts" />
/// <reference path="UserWrappr-0.2.0.ts" />
/// <reference path="WorldSeedr-0.2.0.ts" />
/// <reference path="js_beautify.ts" />
var GameStartr;
(function (GameStartr_1) {
    "use strict";
    /**
     * A general-use game engine for 2D 8-bit games.
     */
    var GameStartr = (function (_super) {
        __extends(GameStartr, _super);
        /**
         * Initializes a new instance of the GameStartr class.
         *
         * @param customs   Any optional custom settings.
         */
        function GameStartr(settings) {
            if (settings === void 0) { settings = {}; }
            _super.call(this, {
                "unitsize": settings.unitsize,
                "constantsSource": settings.constantsSource,
                "constants": settings.constants
            });
            /**
             * Default list of reset Functions to call during this.reset or this.resetTimed,
             * in order of when they should be called.
             */
            this.resets = [
                "resetUsageHelper",
                "resetObjectMaker",
                "resetPixelRender",
                "resetTimeHandler",
                "resetItemsHolder",
                "resetAudioPlayer",
                "resetQuadsKeeper",
                "resetGamesRunner",
                "resetGroupHolder",
                "resetThingHitter",
                "resetMapScreener",
                "resetPixelDrawer",
                "resetNumberMaker",
                "resetMapsCreator",
                "resetAreaSpawner",
                "resetInputWriter",
                "resetDeviceLayer",
                "resetTouchPasser",
                "resetLevelEditor",
                "resetWorldSeeder",
                "resetScenePlayer",
                "resetMathDecider",
                "resetModAttacher",
                "startModAttacher",
                "resetContainer"
            ];
            if (settings.extraResets) {
                this.resets.push.apply(this.resets, settings.extraResets);
            }
            if (settings.resetTimed) {
                this.resetTimed(this, settings);
            }
            else {
                this.reset(this, settings);
            }
        }
        /* Resets
        */
        /**
         * Resets the GameStartr by calling the parent EightBittr.prototype.reset.
         *
         * @param GameStarter
         * @param customs   Any optional custom settings.
         */
        GameStartr.prototype.reset = function (GameStarter, settings) {
            _super.prototype.reset.call(this, GameStarter, GameStarter.resets, settings);
        };
        /**
         * Resets the EightBittr and records the time by calling the parent
         * EightBittr.prototype.resetTimed.
         *
         * @param GameStarter
         * @param customs   Any optional custom settings.
         */
        GameStartr.prototype.resetTimed = function (GameStarter, settings) {
            _super.prototype.resetTimed.call(this, GameStarter, GameStarter.resets, settings);
        };
        /**
         * Sets this.UsageHelper.
         *
         * @param GameStarter
         * @param customs   Any optional custom settings.
         */
        GameStartr.prototype.resetUsageHelper = function (GameStarter, settings) {
            GameStarter.UsageHelper = new UsageHelpr.UsageHelpr(GameStarter.settings.help);
        };
        /**
         * Sets this.ObjectMaker.
         *
         * Because many Thing functions require access to other GameStartr modules, each is
         * given a reference to this container GameStartr via properties.thing.GameStarter.
         *
         * @param GameStarter
         * @param customs   Any optional custom settings.
         */
        GameStartr.prototype.resetObjectMaker = function (GameStarter, settings) {
            GameStarter.ObjectMaker = new ObjectMakr.ObjectMakr(GameStarter.proliferate({
                "properties": {
                    "Quadrant": {
                        "EightBitter": GameStarter,
                        "GameStarter": GameStarter
                    },
                    "Thing": {
                        "EightBitter": GameStarter,
                        "GameStarter": GameStarter
                    }
                }
            }, GameStarter.settings.objects));
        };
        /**
         * Sets this.QuadsKeeper.
         *
         * @param GameStarter
         * @param customs   Any optional custom settings.
         */
        GameStartr.prototype.resetQuadsKeeper = function (GameStarter, settings) {
            var quadrantWidth = settings.width / (GameStarter.settings.quadrants.numCols - 3), quadrantHeight = settings.height / (GameStarter.settings.quadrants.numRows - 2);
            GameStarter.QuadsKeeper = new QuadsKeepr.QuadsKeepr(GameStarter.proliferate({
                "ObjectMaker": GameStarter.ObjectMaker,
                "createCanvas": GameStarter.createCanvas,
                "quadrantWidth": quadrantWidth,
                "quadrantHeight": quadrantHeight,
                "startLeft": -quadrantWidth,
                "startHeight": -quadrantHeight,
                "onAdd": GameStarter.onAreaSpawn.bind(GameStarter, GameStarter),
                "onRemove": GameStarter.onAreaUnspawn.bind(GameStarter, GameStarter)
            }, GameStarter.settings.quadrants));
        };
        /**
         * Sets this.PixelRender.
         *
         * @param GameStarter
         * @param customs   Any optional custom settings.
         */
        GameStartr.prototype.resetPixelRender = function (GameStarter, settings) {
            GameStarter.PixelRender = new PixelRendr.PixelRendr(GameStarter.proliferate({
                "scale": GameStarter.scale,
                "QuadsKeeper": GameStarter.QuadsKeeper,
                "unitsize": GameStarter.unitsize
            }, GameStarter.settings.sprites));
        };
        /**
         * Sets this.PixelDrawer.
         *
         * @param GameStarter
         * @param customs   Any optional custom settings.
         */
        GameStartr.prototype.resetPixelDrawer = function (GameStarter, settings) {
            GameStarter.PixelDrawer = new PixelDrawr.PixelDrawr(GameStarter.proliferate({
                "PixelRender": GameStarter.PixelRender,
                "MapScreener": GameStarter.MapScreener,
                "createCanvas": GameStarter.createCanvas,
                "unitsize": GameStarter.unitsize,
                "generateObjectKey": GameStarter.generateThingKey
            }, GameStarter.settings.renderer));
        };
        /**
         * Sets this.TimeHandler.
         *
         * @param GameStarter
         * @param customs   Any optional custom settings.
         */
        GameStartr.prototype.resetTimeHandler = function (GameStarter, settings) {
            GameStarter.TimeHandler = new TimeHandlr.TimeHandlr(GameStarter.proliferate({
                "classAdd": GameStarter.addClass,
                "classRemove": GameStarter.removeClass
            }, GameStarter.settings.events));
        };
        /**
         * Sets this.AudioPlayer.
         *
         * @param GameStarter
         * @param customs   Any optional custom settings.
         */
        GameStartr.prototype.resetAudioPlayer = function (GameStarter, settings) {
            GameStarter.AudioPlayer = new AudioPlayr.AudioPlayr(GameStarter.proliferate({
                "ItemsHolder": GameStarter.ItemsHolder
            }, GameStarter.settings.audio));
        };
        /**
         * Sets this.GamesRunner.
         *
         * @param GameStarter
         * @param customs   Any optional custom settings.
         */
        GameStartr.prototype.resetGamesRunner = function (GameStarter, settings) {
            GameStarter.GamesRunner = new GamesRunnr.GamesRunnr(GameStarter.proliferate({
                "adjustFramerate": true,
                "scope": GameStarter,
                "onPlay": GameStarter.onGamePlay.bind(GameStarter, GameStarter),
                "onPause": GameStarter.onGamePause.bind(GameStarter, GameStarter),
                "FPSAnalyzer": new FPSAnalyzr.FPSAnalyzr()
            }, GameStarter.settings.runner));
            GameStarter.FPSAnalyzer = GameStarter.GamesRunner.getFPSAnalyzer();
        };
        /**
         * Sets this.ItemsHolder.
         *
         * @param GameStarter
         * @param customs   Any optional custom settings.
         */
        GameStartr.prototype.resetItemsHolder = function (GameStarter, settings) {
            GameStarter.ItemsHolder = new ItemsHoldr.ItemsHoldr(GameStarter.proliferate({
                "callbackArgs": [GameStarter]
            }, GameStarter.settings.items));
        };
        /**
         * Sets this.GroupHolder.
         *
         * @param GameStarter
         * @param customs   Any optional custom settings.
         */
        GameStartr.prototype.resetGroupHolder = function (GameStarter, settings) {
            GameStarter.GroupHolder = new GroupHoldr.GroupHoldr(GameStarter.settings.groups);
        };
        /**
         * Sets this.ThingHitter.
         *
         * @param GameStarter
         * @param customs   Any optional custom settings.
         */
        GameStartr.prototype.resetThingHitter = function (GameStarter, settings) {
            GameStarter.ThingHitter = new ThingHittr.ThingHittr(GameStarter.proliferate({
                "scope": GameStarter
            }, GameStarter.settings.collisions));
        };
        /**
         * Sets this.MapScreener.
         *
         * @param GameStarter
         * @param customs   Any optional custom settings.
         */
        GameStartr.prototype.resetMapScreener = function (GameStarter, settings) {
            GameStarter.MapScreener = new MapScreenr.MapScreenr({
                "EightBitter": GameStarter,
                "unitsize": GameStarter.unitsize,
                "width": settings.width,
                "height": settings.height,
                "variableArgs": [GameStarter],
                "variables": GameStarter.settings.maps.screenVariables
            });
        };
        /**
         * Sets this.NumberMaker.
         *
         * @param GameStarter
         * @param customs   Any optional custom settings.
         */
        GameStartr.prototype.resetNumberMaker = function (GameStarter, settings) {
            GameStarter.NumberMaker = new NumberMakr.NumberMakr();
        };
        /**
         * Sets this.MapCreator.
         *
         * @param GameStarter
         * @param customs   Any optional custom settings.
         */
        GameStartr.prototype.resetMapsCreator = function (GameStarter, settings) {
            GameStarter.MapsCreator = new MapsCreatr.MapsCreatr({
                "ObjectMaker": GameStarter.ObjectMaker,
                "groupTypes": GameStarter.settings.maps.groupTypes,
                "macros": GameStarter.settings.maps.macros,
                "entrances": GameStarter.settings.maps.entrances,
                "maps": GameStarter.settings.maps.library,
                "scope": GameStarter
            });
        };
        /**
         * Sets this.AreaSpawner.
         *
         * @param GameStarter
         * @param customs   Any optional custom settings.
         */
        GameStartr.prototype.resetAreaSpawner = function (GameStarter, settings) {
            GameStarter.AreaSpawner = new AreaSpawnr.AreaSpawnr({
                "MapsCreator": GameStarter.MapsCreator,
                "MapScreener": GameStarter.MapScreener,
                "screenAttributes": GameStarter.settings.maps.screenAttributes,
                "onSpawn": GameStarter.settings.maps.onSpawn,
                "onUnspawn": GameStarter.settings.maps.onUnspawn,
                "stretchAdd": GameStarter.settings.maps.stretchAdd,
                "afterAdd": GameStarter.settings.maps.afterAdd,
                "commandScope": GameStarter
            });
        };
        /**
         * Sets this.InputWriter.
         *
         * @param GameStarter
         * @param customs   Any optional custom settings.
         */
        GameStartr.prototype.resetInputWriter = function (GameStarter, settings) {
            GameStarter.InputWriter = new InputWritr.InputWritr(GameStarter.proliferate({
                "canTrigger": GameStarter.canInputsTrigger.bind(GameStarter, GameStarter),
                "eventInformation": GameStarter
            }, GameStarter.settings.input.InputWritrArgs));
        };
        /**
         * Sets this.DeviceLayer.
         *
         * @param GameStarter
         * @param customs   Any optional custom settings.
         */
        GameStartr.prototype.resetDeviceLayer = function (GameStarter, settings) {
            GameStarter.DeviceLayer = new DeviceLayr.DeviceLayr(GameStarter.proliferate({
                "InputWriter": GameStarter.InputWriter
            }, GameStarter.settings.devices));
        };
        /**
         * Sets this.InputWriter.
         *
         * @param GameStarter
         * @param customs   Any optional custom settings.
         */
        GameStartr.prototype.resetTouchPasser = function (GameStarter, settings) {
            GameStarter.TouchPasser = new TouchPassr.TouchPassr(GameStarter.proliferate({
                "InputWriter": GameStarter.InputWriter
            }, GameStarter.settings.touch));
        };
        /**
         * Sets this.LevelEditor.
         *
         * @param GameStarter
         * @param customs   Any optional custom settings.
         */
        GameStartr.prototype.resetLevelEditor = function (GameStarter, settings) {
            GameStarter.LevelEditor = new LevelEditr.LevelEditr(GameStarter.proliferate({
                "GameStarter": GameStarter,
                "beautifier": js_beautify
            }, GameStarter.settings.editor));
        };
        /**
         * Sets this.WorldSeeder.
         *
         * @param GameStarter
         * @param customs   Any optional custom settings.
         */
        GameStartr.prototype.resetWorldSeeder = function (GameStarter, settings) {
            GameStarter.WorldSeeder = new WorldSeedr.WorldSeedr(GameStarter.proliferate({
                "random": GameStarter.NumberMaker.random.bind(GameStarter.NumberMaker),
                "onPlacement": GameStarter.mapPlaceRandomCommands.bind(GameStarter, GameStarter)
            }, GameStarter.settings.generator));
        };
        /**
         * Sets this.ScenePlayer.
         *
         * @param GameStarter
         * @param customs   Any optional custom settings.
         */
        GameStartr.prototype.resetScenePlayer = function (GameStarter, settings) {
            GameStarter.ScenePlayer = new ScenePlayr.ScenePlayr(GameStarter.proliferate({
                "cutsceneArguments": [GameStarter]
            }, GameStarter.settings.scenes));
        };
        /**
         * Sets this.MathDecider.
         *
         * @param GameStarter
         * @param customs   Any optional custom settings.
         */
        GameStartr.prototype.resetMathDecider = function (GameStarter, settings) {
            GameStarter.MathDecider = new MathDecidr.MathDecidr(GameStarter.settings.math);
        };
        /**
         * Sets this.ModAttacher.
         *
         * @param GameStarter
         * @param customs   Any optional custom settings.
         */
        GameStartr.prototype.resetModAttacher = function (GameStarter, settings) {
            GameStarter.ModAttacher = new ModAttachr.ModAttachr(GameStarter.proliferate({
                "scopeDefault": GameStarter,
                "ItemsHoldr": GameStarter.ItemsHolder
            }, GameStarter.settings.mods));
        };
        /**
         * Starts self.ModAttacher. All mods are enabled, and the "onReady" trigger
         * is fired.
         *
         * @param GameStarter
         * @param customs   Any optional custom settings.
         */
        GameStartr.prototype.startModAttacher = function (GameStarter, settings) {
            var mods = settings.mods, i;
            if (mods) {
                for (i in mods) {
                    if (mods.hasOwnProperty(i) && mods[i]) {
                        GameStarter.ModAttacher.enableMod(i);
                    }
                }
            }
            GameStarter.ModAttacher.fireEvent("onReady", GameStarter, GameStarter);
        };
        /**
         * Resets the parent HTML container. Width and height are set by customs,
         * and canvas, ItemsHolder, and TouchPassr container elements are added.
         *
         * @param GameStarter
         * @param customs   Any optional custom settings.
         */
        GameStartr.prototype.resetContainer = function (GameStarter, settings) {
            GameStarter.container = GameStarter.createElement("div", {
                "className": "EightBitter",
                "style": GameStarter.proliferate({
                    "position": "relative",
                    "width": settings.width + "px",
                    "height": settings.height + "px"
                }, settings.style)
            });
            GameStarter.canvas = GameStarter.createCanvas(settings.width, settings.height);
            GameStarter.PixelDrawer.setCanvas(GameStarter.canvas);
            GameStarter.container.appendChild(GameStarter.canvas);
            GameStarter.TouchPasser.setParentContainer(GameStarter.container);
        };
        /* Global manipulations
        */
        /**
         * Scrolls the game window by shifting all Things and checking for quadrant
         * refreshes. Shifts are rounded to the nearest integer, to preserve pixels.
         *
         * @param customs   Any optional custom settings.
         * @param dx   How far to scroll horizontally.
         * @param dy   How far to scroll vertically.
         */
        GameStartr.prototype.scrollWindow = function (dx, dy) {
            var GameStarter = GameStartr.prototype.ensureCorrectCaller(this);
            dx = dx | 0;
            dy = dy | 0;
            if (!dx && !dy) {
                return;
            }
            GameStarter.MapScreener.shift(dx, dy);
            GameStarter.shiftAll(-dx, -dy);
            GameStarter.QuadsKeeper.shiftQuadrants(-dx, -dy);
        };
        /**
         * Scrolls everything but a single Thing.
         *
         * @param thing   The only Thing that shouldn't move on the screen.
         * @param dx   How far to scroll horizontally.
         * @param dy   How far to scroll vertically.
         */
        GameStartr.prototype.scrollThing = function (thing, dx, dy) {
            var saveleft = thing.left, savetop = thing.top;
            thing.GameStarter.scrollWindow(dx, dy);
            thing.GameStarter.setLeft(thing, saveleft);
            thing.GameStarter.setTop(thing, savetop);
        };
        /**
         * Spawns all Things within a given area that should be there.
         *
         * @param GameStarter
         * @param direction   The direction spawning comes from.
         * @param top   A top boundary to spawn within.
         * @param right   A right boundary to spawn within.
         * @param bottom   A bottom boundary to spawn within.
         * @param left   A left boundary to spawn within.
         * @remarks This is generally called by a QuadsKeepr during a screen update.
         */
        GameStartr.prototype.onAreaSpawn = function (GameStarter, direction, top, right, bottom, left) {
            GameStarter.AreaSpawner.spawnArea(direction, (top + GameStarter.MapScreener.top) / GameStarter.unitsize, (right + GameStarter.MapScreener.left) / GameStarter.unitsize, (bottom + GameStarter.MapScreener.top) / GameStarter.unitsize, (left + GameStarter.MapScreener.left) / GameStarter.unitsize);
        };
        /**
         * "Unspawns" all Things within a given area that should be gone by marking
         * their PreThings as not in game.
         *
         * @param GameStarter
         * @param direction   The direction spawning comes from.
         * @param top   A top boundary to spawn within.
         * @param right   A right boundary to spawn within.
         * @param bottom   A bottom boundary to spawn within.
         * @param left   A left boundary to spawn within.
         * @remarks This is generally called by a QuadsKeepr during a screen update.
         */
        GameStartr.prototype.onAreaUnspawn = function (GameStarter, direction, top, right, bottom, left) {
            GameStarter.AreaSpawner.unspawnArea(direction, (top + GameStarter.MapScreener.top) / GameStarter.unitsize, (right + GameStarter.MapScreener.left) / GameStarter.unitsize, (bottom + GameStarter.MapScreener.top) / GameStarter.unitsize, (left + GameStarter.MapScreener.left) / GameStarter.unitsize);
        };
        /**
         * Adds a new Thing to the game at a given position, relative to the top
         * left corner of the screen.
         *
         * @param thingRaw   What type of Thing to add. This may be a String of
         *                   the class title, an Array containing the String
         *                   and an Object of settings, or an actual Thing.
         * @param left   The horizontal point to place the Thing's left at (by default, 0).
         * @param top   The vertical point to place the Thing's top at (by default, 0).
         */
        GameStartr.prototype.addThing = function (thingRaw, left, top) {
            if (left === void 0) { left = 0; }
            if (top === void 0) { top = 0; }
            var thing;
            if (typeof thingRaw === "string" || thingRaw instanceof String) {
                thing = this.ObjectMaker.make(thingRaw);
            }
            else if (thingRaw.constructor === Array) {
                thing = this.ObjectMaker.make.apply(this.ObjectMaker, thingRaw);
            }
            else {
                thing = thingRaw;
            }
            if (arguments.length > 2) {
                thing.GameStarter.setLeft(thing, left);
                thing.GameStarter.setTop(thing, top);
            }
            else if (arguments.length > 1) {
                thing.GameStarter.setLeft(thing, left);
            }
            thing.GameStarter.updateSize(thing);
            thing.GameStarter.GroupHolder.getFunctions().add[thing.groupType](thing);
            thing.placed = true;
            // This will typically be a TimeHandler.cycleClass call
            if (thing.onThingAdd) {
                thing.onThingAdd(thing);
            }
            thing.GameStarter.PixelDrawer.setThingSprite(thing);
            // This will typically be a spawn* call
            if (thing.onThingAdded) {
                thing.onThingAdded(thing);
            }
            thing.GameStarter.ModAttacher.fireEvent("onAddThing", thing, left, top);
            return thing;
        };
        /**
         * Processes a Thing so that it is ready to be placed in gameplay. There are
         * a lot of steps here: width and height must be set with defaults and given
         * to spritewidth and spriteheight, a quadrants Array must be given, the
         * sprite must be set, attributes and onThingMake called upon, and initial
         * class cycles and flipping set.
         *
         * @param thing   The Thing being processed.
         * @param title   What type Thing this is (the name of the class).
         * @param settings   Additional settings to be given to the Thing.
         * @param defaults   The default settings for the Thing's class.
         * @remarks This is generally called as the onMake call in an ObjectMakr.
         */
        GameStartr.prototype.thingProcess = function (thing, title, settings, defaults) {
            var maxQuads = 4, num, cycle;
            // If the Thing doesn't specify its own title, use the type by default
            thing.title = thing.title || title;
            // If a width/height is provided but no spritewidth/height,
            // use the default spritewidth/height
            if (thing.width && !thing.spritewidth) {
                thing.spritewidth = defaults.spritewidth || defaults.width;
            }
            if (thing.height && !thing.spriteheight) {
                thing.spriteheight = defaults.spriteheight || defaults.height;
            }
            // Each thing has at least 4 maximum quadrants for the QuadsKeepr
            num = Math.floor(thing.width * (thing.GameStarter.unitsize / thing.GameStarter.QuadsKeeper.getQuadrantWidth()));
            if (num > 0) {
                maxQuads += ((num + 1) * maxQuads / 2);
            }
            num = Math.floor(thing.height * thing.GameStarter.unitsize / thing.GameStarter.QuadsKeeper.getQuadrantHeight());
            if (num > 0) {
                maxQuads += ((num + 1) * maxQuads / 2);
            }
            thing.maxquads = maxQuads;
            thing.quadrants = new Array(maxQuads);
            // Basic sprite information
            thing.spritewidth = thing.spritewidth || thing.width;
            thing.spriteheight = thing.spriteheight || thing.height;
            // Sprite sizing
            thing.spritewidthpixels = thing.spritewidth * thing.GameStarter.unitsize;
            thing.spriteheightpixels = thing.spriteheight * thing.GameStarter.unitsize;
            // Canvas, context
            thing.canvas = thing.GameStarter.createCanvas(thing.spritewidthpixels, thing.spriteheightpixels);
            thing.context = thing.canvas.getContext("2d");
            if (thing.opacity !== 1) {
                thing.GameStarter.setOpacity(thing, thing.opacity);
            }
            // Attributes, such as Koopa.smart
            if (thing.attributes) {
                thing.GameStarter.thingProcessAttributes(thing, thing.attributes);
            }
            // Important custom functions
            if (thing.onThingMake) {
                thing.onThingMake(thing, settings);
            }
            // Initial class / sprite setting
            thing.GameStarter.setSize(thing, thing.width, thing.height);
            thing.GameStarter.setClassInitial(thing, thing.name || thing.title);
            // Sprite cycles
            if (cycle = thing.spriteCycle) {
                thing.GameStarter.TimeHandler.addClassCycle(thing, cycle[0], cycle[1] || null, cycle[2] || null);
            }
            if (cycle = thing.spriteCycleSynched) {
                thing.GameStarter.TimeHandler.addClassCycleSynched(thing, cycle[0], cycle[1] || null, cycle[2] || null);
            }
            // flipHoriz and flipVert initially 
            if (thing.flipHoriz) {
                thing.GameStarter.flipHoriz(thing);
            }
            if (thing.flipVert) {
                thing.GameStarter.flipVert(thing);
            }
            // Mods!
            thing.GameStarter.ModAttacher.fireEvent("onThingMake", thing.GameStarter, thing, title, settings, defaults);
        };
        /**
         * Processes additional Thing attributes. For each attribute the Thing's
         * class says it may have, if it has it, the attribute's key is appeneded to
         * the Thing's name and the attribute value proliferated onto the Thing.
         *
         * @param thing
         * @param attributes   A lookup of attributes that may be added to the Thing's class.
         */
        GameStartr.prototype.thingProcessAttributes = function (thing, attributes) {
            var attribute;
            // For each listing in the attributes...
            for (attribute in attributes) {
                // If the thing has that attribute as true:
                if (thing[attribute]) {
                    // Add the extra options
                    thing.GameStarter.proliferate(thing, attributes[attribute]);
                    // Also add a marking to the name, which will go into the className
                    if (thing.name) {
                        thing.name += " " + attribute;
                    }
                    else {
                        thing.name = thing.title + " " + attribute;
                    }
                }
            }
        };
        /**
         * Runs through commands generated by a WorldSeedr and evaluates all of
         * to create PreThings via MapsCreator.analyzePreSwitch.
         *
         * @param GameStarter
         * @param generatedCommands   Commands generated by WorldSeedr.generateFull.
         */
        GameStartr.prototype.mapPlaceRandomCommands = function (GameStarter, generatedCommands) {
            var MapsCreator = GameStarter.MapsCreator, AreaSpawner = GameStarter.AreaSpawner, prethings = AreaSpawner.getPreThings(), area = AreaSpawner.getArea(), map = AreaSpawner.getMap(), command, output, i;
            for (i = 0; i < generatedCommands.length; i += 1) {
                command = generatedCommands[i];
                output = {
                    "thing": command.title,
                    "x": command.left,
                    "y": command.top
                };
                if (command.arguments) {
                    GameStarter.proliferateHard(output, command.arguments, true);
                }
                MapsCreator.analyzePreSwitch(output, prethings, area, map);
            }
        };
        /**
         * Triggered Function for when the game is unpaused. Music resumes, and
         * the mod event is fired.
         *
         * @param GameStartr
         */
        GameStartr.prototype.onGamePlay = function (GameStarter) {
            GameStarter.AudioPlayer.resumeAll();
            GameStarter.ModAttacher.fireEvent("onGamePlay");
        };
        /**
         * Triggered Function for when the game is paused. Music stops, and the
         * mod event is fired.
         *
         * @param GameStartr
         */
        GameStartr.prototype.onGamePause = function (GameStarter) {
            GameStarter.AudioPlayer.pauseAll();
            GameStarter.ModAttacher.fireEvent("onGamePause");
        };
        /**
         * Checks whether inputs can be fired, which by default is always true.
         *
         * @param GameStartr
         * @returns Whether inputs can be fired, which is always true.
         */
        GameStartr.prototype.canInputsTrigger = function (GameStarter) {
            return true;
        };
        /**
         * Generic Function to start the game. Nothing actually happens here.
         */
        GameStartr.prototype.gameStart = function () {
            this.ModAttacher.fireEvent("onGameStart");
        };
        /* Physics & similar
        */
        /**
         * Generically kills a Thing by setting its alive to false, hidden to true,
         * and clearing its movement.
         *
         * @param thing
         */
        GameStartr.prototype.killNormal = function (thing) {
            if (!thing) {
                return;
            }
            thing.alive = false;
            thing.hidden = true;
            thing.movement = undefined;
        };
        /**
         * Sets a Thing's "changed" flag to true, which indicates to the PixelDrawr
         * to redraw the Thing and its quadrant.
         *
         * @param thing
         */
        GameStartr.prototype.markChanged = function (thing) {
            thing.changed = true;
        };
        /**
         * Shifts a Thing vertically using the EightBittr utility, and marks the
         * Thing as having a changed appearance.
         *
         * @param thing
         * @param dy   How far to shift the Thing vertically.
         * @param notChanged   Whether to skip marking the Thing as changed (by
         *                     default, false).
         */
        GameStartr.prototype.shiftVert = function (thing, dy, notChanged) {
            EightBittr.EightBittr.prototype.shiftVert(thing, dy);
            if (!notChanged) {
                thing.GameStarter.markChanged(thing);
            }
        };
        /**
         * Shifts a Thing horizontally using the EightBittr utility, and marks the
         * Thing as having a changed appearance.
         *
         * @param thing
         * @param dx   How far to shift the Thing horizontally.
         * @param notChanged   Whether to skip marking the Thing as changed (by
         *                     default, false).
         */
        GameStartr.prototype.shiftHoriz = function (thing, dx, notChanged) {
            EightBittr.EightBittr.prototype.shiftHoriz(thing, dx);
            if (!notChanged) {
                thing.GameStarter.markChanged(thing);
            }
        };
        /**
         * Sets a Thing's top using the EightBittr utility, and marks the Thing as
         * having a changed appearance.
         *
         * @param thing
         * @param top   A new top border for the Thing.
         */
        GameStartr.prototype.setTop = function (thing, top) {
            EightBittr.EightBittr.prototype.setTop(thing, top);
            thing.GameStarter.markChanged(thing);
        };
        /**
         * Sets a Thing's right using the EightBittr utility, and marks the Thing as
         * having a changed appearance.
         *
         * @param thing
         * @param right   A new right border for the Thing.
         */
        GameStartr.prototype.setRight = function (thing, right) {
            EightBittr.EightBittr.prototype.setRight(thing, right);
            thing.GameStarter.markChanged(thing);
        };
        /**
         * Sets a Thing's bottom using the EightBittr utility, and marks the Thing
         * as having a changed appearance.
         *
         * @param thing
         * @param bottom   A new bottom border for the Thing.
         */
        GameStartr.prototype.setBottom = function (thing, bottom) {
            EightBittr.EightBittr.prototype.setBottom(thing, bottom);
            thing.GameStarter.markChanged(thing);
        };
        /**
         * Sets a Thing's left using the EightBittr utility, and marks the Thing
         * as having a changed appearance.
         *
         * @param thing
         * @param left   A new left border for the Thing.
         */
        GameStartr.prototype.setLeft = function (thing, left) {
            EightBittr.EightBittr.prototype.setLeft(thing, left);
            thing.GameStarter.markChanged(thing);
        };
        /**
         * Shifts a thing both horizontally and vertically. If the Thing marks
         * itself as having a parallax effect (parallaxHoriz or parallaxVert), that
         * proportion of movement is respected (.5 = half, etc.).
         *
         * @param thing
         * @param dx   How far to shift the Thing horizontally.
         * @param dy   How far to shift the Thing vertically.
         * @param notChanged   Whether to skip marking the Thing as changed (by
         *                     default, false).
         */
        GameStartr.prototype.shiftBoth = function (thing, dx, dy, notChanged) {
            dx = dx || 0;
            dy = dy || 0;
            if (!thing.noshiftx) {
                if (thing.parallaxHoriz) {
                    thing.GameStarter.shiftHoriz(thing, thing.parallaxHoriz * dx, notChanged);
                }
                else {
                    thing.GameStarter.shiftHoriz(thing, dx, notChanged);
                }
            }
            if (!thing.noshifty) {
                if (thing.parallaxVert) {
                    thing.GameStarter.shiftVert(thing, thing.parallaxVert * dy, notChanged);
                }
                else {
                    thing.GameStarter.shiftVert(thing, dy, notChanged);
                }
            }
        };
        /**
         * Calls shiftBoth on all members of an Array.
         *
         * @param dx   How far to shift the Things horizontally.
         * @param dy   How far to shift the Things vertically.
         * @param notChanged   Whether to skip marking the Things as changed (by
         *                     default, false).
         */
        GameStartr.prototype.shiftThings = function (things, dx, dy, notChanged) {
            for (var i = things.length - 1; i >= 0; i -= 1) {
                things[i].GameStarter.shiftBoth(things[i], dx, dy, notChanged);
            }
        };
        /**
         * Calls shiftBoth on all groups in the calling GameStartr's GroupHoldr.
         *
         * @param dx   How far to shift the Things horizontally.
         * @param dy   How far to shift the Things vertically.
         */
        GameStartr.prototype.shiftAll = function (dx, dy) {
            var GameStarter = GameStartr.prototype.ensureCorrectCaller(this);
            GameStarter.GroupHolder.callAll(GameStarter, GameStarter.shiftThings, dx, dy, true);
        };
        /**
         * Sets the width and unitwidth of a Thing, and optionally updates the
         * Thing's spritewidth and spritewidth pixels, and/or calls updateSize.
         * The thing is marked as having changed appearance.
         *
         * @param thing
         * @param width   A new width for the Thing.
         * @param updateSprite   Whether to update the Thing's spritewidth and
         *                       spritewidthpixels (by default, false).
         * @param updateSize   Whether to call updateSize on the Thing (by
         *                     default, false).
         */
        GameStartr.prototype.setWidth = function (thing, width, updateSprite, updateSize) {
            thing.width = width;
            thing.unitwidth = width * thing.GameStarter.unitsize;
            if (updateSprite) {
                thing.spritewidth = width;
                thing.spritewidthpixels = width * thing.GameStarter.unitsize;
            }
            if (updateSize) {
                thing.GameStarter.updateSize(thing);
            }
            thing.GameStarter.markChanged(thing);
        };
        /**
         * Sets the height and unitheight of a Thing, and optionally updates the
         * Thing's spriteheight and spriteheight pixels, and/or calls updateSize.
         * The thing is marked as having changed appearance.
         *
         * @param thing
         * @param height   A new height for the Thing.
         * @param updateSprite   Whether to update the Thing's spriteheight and
         *                       spriteheightpixels (by default, false).
         * @param updateSize   Whether to call updateSize on the Thing (by
         *                     default, false).
         */
        GameStartr.prototype.setHeight = function (thing, height, updateSprite, updateSize) {
            thing.height = height;
            thing.unitheight = height * thing.GameStarter.unitsize;
            if (updateSprite) {
                thing.spriteheight = height;
                thing.spriteheightpixels = height * thing.GameStarter.unitsize;
            }
            if (updateSize) {
                thing.GameStarter.updateSize(thing);
            }
            thing.GameStarter.markChanged(thing);
        };
        /**
         * Utility to call both setWidth and setHeight on a Thing.
         *
         * @param thing
         * @param width   A new width for the Thing.
         * @param height   A new height for the Thing.
         * @param updateSprite   Whether to update the Thing's spritewidth,
         *                       spriteheight, spritewidthpixels, and
         *                       spritspriteheightpixels (by default, false).
         * @param updateSize   Whether to call updateSize on the Thing (by
         *                     default, false).
         */
        GameStartr.prototype.setSize = function (thing, width, height, updateSprite, updateSize) {
            thing.GameStarter.setWidth(thing, width, updateSprite, updateSize);
            thing.GameStarter.setHeight(thing, height, updateSprite, updateSize);
        };
        /**
         * Shifts a Thing horizontally by its xvel and vertically by its yvel, using
         * shiftHoriz and shiftVert.
         *
         * @param thing
         */
        GameStartr.prototype.updatePosition = function (thing) {
            thing.GameStarter.shiftHoriz(thing, thing.xvel);
            thing.GameStarter.shiftVert(thing, thing.yvel);
        };
        /**
         * Completely updates the size measurements of a Thing. That means the
         * unitwidth, unitheight, spritewidthpixels, spriteheightpixels, and
         * spriteheightpixels attributes. The Thing's sprite is then updated by the
         * PixelDrawer, and its appearance is marked as changed.
         *
         * @param thing
         */
        GameStartr.prototype.updateSize = function (thing) {
            thing.unitwidth = thing.width * thing.GameStarter.unitsize;
            thing.unitheight = thing.height * thing.GameStarter.unitsize;
            thing.spritewidthpixels = thing.spritewidth * thing.GameStarter.unitsize;
            thing.spriteheightpixels = thing.spriteheight * thing.GameStarter.unitsize;
            thing.canvas.width = thing.spritewidthpixels;
            thing.canvas.height = thing.spriteheightpixels;
            thing.GameStarter.PixelDrawer.setThingSprite(thing);
            thing.GameStarter.markChanged(thing);
        };
        /**
         * Reduces a Thing's width by pushing back its right and decreasing its
         * width. It is marked as changed in appearance.
         *
         * @param thing
         * @param dx   How much to reduce the Thing's width.
         * @param updateSize   Whether to also call updateSize on the Thing
         *                     (by default, false).
         */
        GameStartr.prototype.reduceWidth = function (thing, dx, updateSize) {
            thing.right -= dx;
            thing.width -= dx / thing.GameStarter.unitsize;
            if (updateSize) {
                thing.GameStarter.updateSize(thing);
            }
            else {
                thing.GameStarter.markChanged(thing);
            }
        };
        /**
         * Reduces a Thing's height by pushing down its top and decreasing its
         * height. It is marked as changed in appearance.
         *
         * @param thing
         * @param dy   How much to reduce the Thing's height.
         * @param updateSize   Whether to also call updateSize on the Thing
         *                     (by default, false).
         */
        GameStartr.prototype.reduceHeight = function (thing, dy, updateSize) {
            thing.top += dy;
            thing.height -= dy / thing.GameStarter.unitsize;
            if (updateSize) {
                thing.GameStarter.updateSize(thing);
            }
            else {
                thing.GameStarter.markChanged(thing);
            }
        };
        /**
         * Increases a Thing's width by pushing forward its right and decreasing its
         * width. It is marked as changed in appearance.
         *
         * @param thing
         * @param dx   How much to increase the Thing's width.
         * @param updateSize   Whether to also call updateSize on the Thing
         *                     (by default, false).
         */
        GameStartr.prototype.increaseWidth = function (thing, dx, updateSize) {
            thing.right += dx;
            thing.width += dx / thing.GameStarter.unitsize;
            thing.unitwidth = thing.width * thing.GameStarter.unitsize;
            if (updateSize) {
                thing.GameStarter.updateSize(thing);
            }
            else {
                thing.GameStarter.markChanged(thing);
            }
        };
        /**
         * Reduces a Thing's height by pushing down its top and decreasing its
         * height. It is marked as changed in appearance.
         *
         * @param thing
         * @param dy   How much to increase the Thing's height.
         * @param updateSize   Whether to also call updateSize on the Thing
         *                     (by default, false).
         */
        GameStartr.prototype.increaseHeight = function (thing, dy, updateSize) {
            thing.top -= dy;
            thing.height += dy / thing.GameStarter.unitsize;
            thing.unitheight = thing.height * thing.GameStarter.unitsize;
            if (updateSize) {
                thing.GameStarter.updateSize(thing);
            }
            else {
                thing.GameStarter.markChanged(thing);
            }
        };
        /* Appearance utilities
        */
        /**
         * Generates a key for a Thing based off the Thing's basic attributes.
         * This key should be used for PixelRender.get calls, to cache the Thing's
         * sprite.
         *
         * @param thing
         * @returns A key that to identify the Thing's sprite.
         */
        GameStartr.prototype.generateThingKey = function (thing) {
            return thing.groupType + " " + thing.title + " " + thing.className;
        };
        /**
         * Sets the class of a Thing, sets the new sprite for it, and marks it as
         * having changed appearance. The class is stored in the Thing's internal
         * .className attribute.
         *
         * @param thing
         * @param className   A new .className for the Thing.
         */
        GameStartr.prototype.setClass = function (thing, className) {
            thing.className = className;
            thing.GameStarter.PixelDrawer.setThingSprite(thing);
            thing.GameStarter.markChanged(thing);
        };
        /**
         * A version of setClass to be used before the Thing's sprite attributes
         * have been set. This just sets the internal .className.
         *
         * @param thing
         * @param className   A new .className for the Thing.
         */
        GameStartr.prototype.setClassInitial = function (thing, className) {
            thing.className = className;
        };
        /**
         * Adds a string to a Thing's class after a " ", updates the Thing's
         * sprite, and marks it as having changed appearance.
         *
         * @param thing
         * @param className   A class to add to the Thing.
         */
        GameStartr.prototype.addClass = function (thing, className) {
            thing.className += " " + className;
            thing.GameStarter.PixelDrawer.setThingSprite(thing);
            thing.GameStarter.markChanged(thing);
        };
        /**
         * Adds multiple strings to a Thing's class after a " ", updates the Thing's
         * sprite, and marks it as having changed appearance. Strings may be given
         * as Arrays or Strings; Strings will be split on " ". Any number of
         * additional arguments may be given.
         *
         * @param thing
         * @param classes   Any number of classes to add to the Thing.
         */
        GameStartr.prototype.addClasses = function (thing) {
            var classes = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                classes[_i - 1] = arguments[_i];
            }
            var adder, i, j;
            for (i = 0; i < classes.length; i += 1) {
                adder = classes[i];
                if (adder.constructor === String || typeof adder === "string") {
                    adder = adder.split(" ");
                }
                for (j = adder.length - 1; j >= 0; j -= 1) {
                    thing.GameStarter.addClass(thing, adder[j]);
                }
            }
        };
        /**
         * Removes a string from a Thing's class, updates the Thing's sprite, and
         * marks it as having changed appearance.
         *
         * @param thing
         * @param className   A class to remove from the Thing.
         */
        GameStartr.prototype.removeClass = function (thing, className) {
            if (!className) {
                return;
            }
            if (className.indexOf(" ") !== -1) {
                thing.GameStarter.removeClasses(thing, className);
            }
            thing.className = thing.className.replace(new RegExp(" " + className, "gm"), "");
            thing.GameStarter.PixelDrawer.setThingSprite(thing);
        };
        /**
         * Removes multiple strings from a Thing's class, updates the Thing's
         * sprite, and marks it as having changed appearance. Strings may be given
         * as Arrays or Strings; Strings will be split on " ". Any number of
         * additional arguments may be given.
         *
         * @param thing
         * @param classes   Any number of classes to remove from the Thing.
         */
        GameStartr.prototype.removeClasses = function (thing) {
            var classes = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                classes[_i - 1] = arguments[_i];
            }
            var adder, i, j;
            for (i = 0; i < classes.length; i += 1) {
                adder = classes[i];
                if (adder.constructor === String || typeof adder === "string") {
                    adder = adder.split(" ");
                }
                for (j = adder.length - 1; j >= 0; --j) {
                    thing.GameStarter.removeClass(thing, adder[j]);
                }
            }
        };
        /**
         * @param thing
         * @param className   A class to check for in the Thing.
         * @returns  Whether the Thing's class contains the class.
         */
        GameStartr.prototype.hasClass = function (thing, className) {
            return thing.className.indexOf(className) !== -1;
        };
        /**
         * Removes the first class from a Thing and adds the second. All typical
         * sprite updates are called.
         *
         * @param thing
         * @param classNameOut   A class to remove from the Thing.
         * @param classNameIn   A class to add to the thing.
         */
        GameStartr.prototype.switchClass = function (thing, classNameOut, classNameIn) {
            thing.GameStarter.removeClass(thing, classNameOut);
            thing.GameStarter.addClass(thing, classNameIn);
        };
        /**
         * Marks a Thing as being flipped horizontally by setting its .flipHoriz
         * attribute to true and giving it a "flipped" class.
         *
         * @param thing
         */
        GameStartr.prototype.flipHoriz = function (thing) {
            thing.flipHoriz = true;
            thing.GameStarter.addClass(thing, "flipped");
        };
        /**
         * Marks a Thing as being flipped vertically by setting its .flipVert
         * attribute to true and giving it a "flipped" class.
         *
         * @param thing
         */
        GameStartr.prototype.flipVert = function (thing) {
            thing.flipVert = true;
            thing.GameStarter.addClass(thing, "flip-vert");
        };
        /**
         * Marks a Thing as not being flipped horizontally by setting its .flipHoriz
         * attribute to false and giving it a "flipped" class.
         *
         * @param thing
         */
        GameStartr.prototype.unflipHoriz = function (thing) {
            thing.flipHoriz = false;
            thing.GameStarter.removeClass(thing, "flipped");
        };
        /**
         * Marks a Thing as not being flipped vertically by setting its .flipVert
         * attribute to true and giving it a "flipped" class.
         *
         * @param thing
         */
        GameStartr.prototype.unflipVert = function (thing) {
            thing.flipVert = false;
            thing.GameStarter.removeClass(thing, "flip-vert");
        };
        /**
         * Sets the opacity of the Thing and marks its appearance as changed.
         *
         * @param thing
         * @param opacity   A number in [0,1].
         */
        GameStartr.prototype.setOpacity = function (thing, opacity) {
            thing.opacity = opacity;
            thing.GameStarter.markChanged(thing);
        };
        /* Miscellaneous utilities
        */
        /**
         * Ensures the current object is a GameStartr by throwing an error if it
         * is not. This should be used for Functions in any GameStartr descendants
         * that have to call 'this' to ensure their caller is what the programmer
         * expected it to be.
         *
         * @param current
         */
        GameStartr.prototype.ensureCorrectCaller = function (current) {
            if (!(current instanceof GameStartr)) {
                throw new Error("A function requires the scope ('this') to be the "
                    + "manipulated GameStartr object. Unfortunately, 'this' is a "
                    + typeof (this) + ".");
            }
            return current;
        };
        /**
         * Removes a Thing from an Array using Array.splice. If the thing has an
         * onDelete, that is called.
         *
         * @param thing
         * @param array   The group containing the thing.
         * @param location   The index of the Thing in the Array, for speed's
         *                   sake (by default, it is found using Array.indexOf).
         */
        GameStartr.prototype.arrayDeleteThing = function (thing, array, location) {
            if (location === void 0) { location = array.indexOf(thing); }
            if (location === -1) {
                return;
            }
            array.splice(location, 1);
            if (typeof thing.onDelete === "function") {
                thing.onDelete(thing);
            }
        };
        /**
         * Takes a snapshot of the current screen canvas by simulating a click event
         * on a dummy link.
         *
         * @param name   A name for the image to be saved as.
         * @param format   A format for the image to be saved as (by default, png).
         * @remarks For security concerns, browsers won't allow this unless it's
         *          called within a callback of a genuine user-triggered event.
         */
        GameStartr.prototype.takeScreenshot = function (name, format) {
            if (format === void 0) { format = "image/png"; }
            var GameStarter = GameStartr.prototype.ensureCorrectCaller(this), link = GameStarter.createElement("a", {
                "download": name + "." + format.split("/")[1],
                "href": GameStarter.canvas.toDataURL(format).replace(format, "image/octet-stream")
            });
            link.click();
        };
        /**
         * Adds a set of CSS styles to the page.
         *
         * @param styles   CSS styles represented as JSON.
         */
        GameStartr.prototype.addPageStyles = function (styles) {
            var GameStarter = GameStartr.prototype.ensureCorrectCaller(this), sheet = GameStarter.createElement("style", {
                "type": "text/css"
            }), compiled = "", i, j;
            for (i in styles) {
                if (!styles.hasOwnProperty(i)) {
                    continue;
                }
                compiled += i + " { \r\n";
                for (j in styles[i]) {
                    if (styles[i].hasOwnProperty(j)) {
                        compiled += "  " + j + ": " + styles[i][j] + ";\r\n";
                    }
                }
                compiled += "}\r\n";
            }
            if (sheet.styleSheet) {
                sheet.style.cssText = compiled;
            }
            else {
                sheet.appendChild(document.createTextNode(compiled));
            }
            document.querySelector("head").appendChild(sheet);
        };
        return GameStartr;
    })(EightBittr.EightBittr);
    GameStartr_1.GameStartr = GameStartr;
})(GameStartr || (GameStartr = {}));
/// <reference path="GameStartr-0.2.0.ts" />
var MenuGraphr;
(function (MenuGraphr_1) {
    "use strict";
    /**
     * Cardinal directions as Numbers.
     */
    (function (Direction) {
        Direction[Direction["Top"] = 0] = "Top";
        Direction[Direction["Right"] = 1] = "Right";
        Direction[Direction["Bottom"] = 2] = "Bottom";
        Direction[Direction["Left"] = 3] = "Left";
    })(MenuGraphr_1.Direction || (MenuGraphr_1.Direction = {}));
    var Direction = MenuGraphr_1.Direction;
    /**
     * A menu management system for GameStartr. Menus can have dialog-style text, scrollable
     * and unscrollable grids, and children menus or decorations added.
     */
    var MenuGraphr = (function () {
        /**
         * Initializes a new instance of the MenuGraphr class.
         *
         * @param settings   Settings to be used for initialization.
         */
        function MenuGraphr(settings) {
            if (!settings) {
                throw new Error("No settings object given to MenuGraphr.");
            }
            if (!settings.GameStarter) {
                throw new Error("No GameStarter given to MenuGraphr.");
            }
            this.GameStarter = settings.GameStarter;
            this.schemas = settings.schemas || {};
            this.aliases = settings.aliases || {};
            this.replacements = settings.replacements || {};
            this.replacerKey = settings.replacerKey || "%%%%%%%";
            this.menus = {};
        }
        /* Simple gets
        */
        /**
         * @returns All available menus, keyed by name.
         */
        MenuGraphr.prototype.getMenus = function () {
            return this.menus;
        };
        /**
         * @param name   A name of a menu.
         * @returns The menu under the given name.
         */
        MenuGraphr.prototype.getMenu = function (name) {
            return this.menus[name];
        };
        /**
         * Returns a menu, throwing an error if it doesn't exist.
         *
         * @param name   A name of a menu.
         * @returns The menu under the given name.
         */
        MenuGraphr.prototype.getExistingMenu = function (name) {
            if (!this.menus[name]) {
                throw new Error("'" + name + "' menu does not exist.");
            }
            return this.menus[name];
        };
        /**
         * @returns The currently active menu.
         */
        MenuGraphr.prototype.getActiveMenu = function () {
            return this.activeMenu;
        };
        /**
         * @returns The name of the currently active menu.
         */
        MenuGraphr.prototype.getActiveMenuName = function () {
            return this.activeMenu.name;
        };
        /**
         * @returns The alternate Thing titles for characters.
         */
        MenuGraphr.prototype.getAliases = function () {
            return this.aliases;
        };
        /**
         * @returns The programmatic replacements for deliniated words.
         */
        MenuGraphr.prototype.getReplacements = function () {
            return this.replacements;
        };
        /* Creations
        */
        /**
         * Creates a menu with the given name and attributes, and stores it under the name.
         * Default information is used from the schema of that name, such as position and
         * children, but may be override by attributes.
         *
         * @param name   The name of the menu.
         * @param attributes   Custom attributes to apply to the menu.
         * @returns The newly created menu.
         */
        MenuGraphr.prototype.createMenu = function (name, attributes) {
            var schemaRaw = this.GameStarter.proliferate({}, this.schemas[name]), schema = this.GameStarter.proliferate(schemaRaw, attributes), menu = this.GameStarter.ObjectMaker.make("Menu", schema), 
            // If the container menu doesn't exist, a pseudo-menu the size of the screen is used
            container = schema.container
                ? this.menus[schema.container]
                : {
                    top: 0,
                    right: this.GameStarter.MapScreener.width,
                    bottom: this.GameStarter.MapScreener.height,
                    left: 0,
                    width: Math.ceil(this.GameStarter.MapScreener.width / this.GameStarter.unitsize),
                    height: Math.ceil(this.GameStarter.MapScreener.height / this.GameStarter.unitsize),
                    EightBitter: this.GameStarter,
                    GameStarter: this.GameStarter,
                    children: []
                };
            this.deleteMenu(name);
            this.menus[name] = menu;
            menu.name = name;
            this.placeMenuThing(container, menu, schema.size, schema.position);
            menu.children = [];
            menu.textAreaWidth = (menu.width - menu.textXOffset * 2) * this.GameStarter.unitsize;
            if (menu.childrenSchemas) {
                menu.childrenSchemas.forEach(this.createMenuChild.bind(this, name));
            }
            if (container.children) {
                container.children.push(menu);
            }
            this.GameStarter.proliferate(menu, attributes);
            return menu;
        };
        /**
         * Adds a child object to an existing menu.
         *
         * @param name   The name of the existing menu.
         * @param schema   Settings for the child, including name and child type.
         * @returns The newly created Thing or Things.
         * @remarks Creating a menu is done using this.createMenu, so the created menu might
         *          not mark itself as a child of the parent.
         */
        MenuGraphr.prototype.createMenuChild = function (name, schema) {
            switch (schema.type) {
                case "menu":
                    return this.createMenu(schema.name, schema.attributes);
                case "text":
                    return this.createMenuWord(name, schema);
                case "thing":
                    return this.createMenuThing(name, schema);
                default:
                    throw new Error("Unknown schema type: " + schema.type);
            }
        };
        /**
         * Creates a series of words as a child of a menu.
         *
         * @param name   The name of the menu.
         * @param schema   Settings for the words.
         * @returns The words' character Things.
         */
        MenuGraphr.prototype.createMenuWord = function (name, schema) {
            var menu = this.getExistingMenu(name), container = this.GameStarter.ObjectMaker.make("Menu"), words = this.filterMenuWords(schema.words);
            this.placeMenuThing(menu, container, schema.size, schema.position, true);
            menu.textX = container.left;
            return this.addMenuWords(name, words, 0, container.left, container.top);
        };
        /**
         * Creates a Thing as a child of a menu.
         *
         * @param name   The name of the menu.
         * @param schema   Settings for the Thing.
         * @returns The newly created Thing.
         */
        MenuGraphr.prototype.createMenuThing = function (name, schema) {
            var menu = this.getExistingMenu(name), thing = this.GameStarter.ObjectMaker.make(schema.thing, schema.args);
            this.placeMenuThing(menu, thing, schema.size, schema.position);
            this.GameStarter.GroupHolder.switchMemberGroup(thing, thing.groupType, "Text");
            menu.children.push(thing);
            return thing;
        };
        /* Removals
        */
        /**
         * Hides a menu of the given name and deletes its children, if it exists.
         *
         * @param name   The name of the menu to hide.
         */
        MenuGraphr.prototype.hideMenu = function (name) {
            var menu = this.menus[name];
            if (menu) {
                menu.hidden = true;
                this.deleteMenuChildren(name);
            }
        };
        /**
         * Deletes a menu of the given name, if it exists.
         *
         * @param name   The name of the menu to delete.
         */
        MenuGraphr.prototype.deleteMenu = function (name) {
            var menu = this.menus[name];
            if (menu) {
                this.deleteMenuChild(menu);
            }
        };
        /**
         * Deletes the active menu, if it exists.
         */
        MenuGraphr.prototype.deleteActiveMenu = function () {
            if (this.activeMenu) {
                this.deleteMenu(this.activeMenu.name);
            }
        };
        /* Menu text
        */
        /**
         * Adds dialog-style text to a menu. If the text overflows,
         *
         * @param name   The name of the menu.
         * @param dialog   Raw dialog to add to the menu.
         * @param onCompletion   An optional callback for when the text is done.
         */
        MenuGraphr.prototype.addMenuDialog = function (name, dialog, onCompletion) {
            var _this = this;
            var dialogParsed = this.parseRawDialog(dialog), currentLine = 1, callback = function () {
                // If all dialog has been exhausted, delete the menu and finish
                if (currentLine >= dialogParsed.length) {
                    if (_this.menus[name].deleteOnFinish) {
                        _this.deleteMenu(name);
                    }
                    if (onCompletion) {
                        onCompletion();
                    }
                    return;
                }
                currentLine += 1;
                // Delete any previous texts. This is only done if continuing
                // so that when the dialog is finished, the last text remains
                _this.deleteMenuChildren(name);
                // This continues the dialog with the next iteration (word)
                _this.addMenuText(name, dialogParsed[currentLine - 1], callback);
            };
            // This first call to addmenuText shouldn't be the callback, because if 
            // being called from a childrenSchema of type "text", it shouldn't delete 
            // any other menu children from childrenSchemas.
            this.addMenuText(name, dialogParsed[0], callback);
        };
        /**
         * Continues a menu from its current display words to the next line.
         *
         * @param name    The name of the menu.
         */
        MenuGraphr.prototype.continueMenu = function (name) {
            var _this = this;
            var menu = this.getExistingMenu(name), children = menu.children, progress = menu.progress, character, i;
            if (!progress || progress.working) {
                return;
            }
            progress.working = true;
            if (progress.complete) {
                if (!progress.onCompletion || progress.onCompletion(this.GameStarter, menu)) {
                    this.deleteMenu(name);
                }
                return;
            }
            for (i = 0; i < children.length; i += 1) {
                character = children[i];
                this.GameStarter.TimeHandler.addEventInterval(this.scrollCharacterUp.bind(this), 1, character.paddingY, character, menu, -1);
            }
            this.GameStarter.TimeHandler.addEvent(function () {
                _this.addMenuWords(name, progress.words, progress.i, progress.x, progress.y, progress.onCompletion);
            }, character.paddingY + 1);
        };
        /* Lists
        */
        /**
         * Adds a list of text options to a menu.
         *
         * @param name   The name of the menu.
         * @param settings   Settings for the list, particularly its options, starting
         *                   index, and optional floating bottom.
         */
        MenuGraphr.prototype.addMenuList = function (name, settings) {
            var menu = this.getExistingMenu(name), options = settings.options.constructor === Function
                ? settings.options()
                : settings.options, left = menu.left + menu.textXOffset * this.GameStarter.unitsize, top = menu.top + menu.textYOffset * this.GameStarter.unitsize, textProperties = this.GameStarter.ObjectMaker.getPropertiesOf("Text"), textWidth = (menu.textWidth || textProperties.width) * this.GameStarter.unitsize, textHeight = (menu.textHeight || textProperties.height) * this.GameStarter.unitsize, textPaddingY = (menu.textPaddingY || textProperties.paddingY) * this.GameStarter.unitsize, selectedIndex = settings.selectedIndex || [0, 0], optionChildren = [], index = 0, y = top, option, optionChild, schema, title, character, column, x, i, j, k;
            menu.options = options;
            menu.optionChildren = optionChildren;
            menu.callback = this.triggerMenuListOption.bind(this);
            menu.onActive = this.activateMenuList.bind(this);
            menu.onInactive = this.deactivateMenuList.bind(this);
            menu.grid = [];
            menu.grid[0] = column = [];
            menu.gridRows = 0;
            if (!options.length) {
                return;
            }
            for (i = 0; i < options.length; i += 1) {
                x = left;
                option = options[i];
                optionChild = {
                    "option": option,
                    "things": []
                };
                optionChildren.push(optionChild);
                option.x = x;
                option.y = y;
                column.push(option);
                option.column = column;
                option.index = index;
                option.columnNumber = menu.grid.length - 1;
                option.rowNumber = column.length - 1;
                menu.gridRows = Math.max(menu.gridRows, column.length);
                index += 1;
                if (option.things) {
                    for (j = 0; j < option.things.length; j += 1) {
                        schema = option.things[j];
                        character = this.createMenuThing(name, schema);
                        menu.children.push(character);
                        optionChild.things.push(character);
                        if (!schema.position || !schema.position.relative) {
                            this.GameStarter.shiftVert(character, y - menu.top);
                        }
                    }
                }
                if (option.textsFloating) {
                    for (j = 0; j < option.textsFloating.length; j += 1) {
                        schema = option.textsFloating[j];
                        optionChild.things = optionChild.things.concat(this.addMenuWords(name, [schema.text], 0, x + schema.x * this.GameStarter.unitsize, y + schema.y * this.GameStarter.unitsize));
                    }
                }
                option.schema = schema = this.filterText(option.text);
                if (schema !== "\n") {
                    for (j = 0; j < schema.length; j += 1) {
                        for (k = 0; k < schema[j].length; k += 1) {
                            if (schema[j][k].command) {
                                if (schema[j][k].x) {
                                    x += schema[j][k].x * this.GameStarter.unitsize;
                                }
                                if (schema[j][k].y) {
                                    y += schema[j][k].y * this.GameStarter.unitsize;
                                }
                            }
                            else {
                                option.title = title = "Char" + this.getCharacterEquivalent(schema[j][k]);
                                character = this.GameStarter.ObjectMaker.make(title);
                                menu.children.push(character);
                                optionChild.things.push(character);
                                this.GameStarter.addThing(character, x, y);
                                x += character.width * this.GameStarter.unitsize;
                            }
                        }
                    }
                }
                y += textPaddingY;
                if (!menu.singleColumnList && y > menu.bottom - textHeight + 1) {
                    y = top;
                    left += menu.textColumnWidth * this.GameStarter.unitsize;
                    column = [];
                    menu.grid.push(column);
                }
            }
            while (menu.grid[menu.grid.length - 1].length === 0) {
                menu.grid.pop();
            }
            menu.gridColumns = menu.grid.length;
            if (settings.bottom) {
                option = settings.bottom;
                option.schema = schema = this.filterText(option.text);
                optionChild = {
                    "option": option,
                    "things": []
                };
                optionChildren.push(optionChild);
                x = menu.left + (menu.textXOffset + option.position.left) * this.GameStarter.unitsize;
                y = menu.top + (menu.textYOffset + option.position.top) * this.GameStarter.unitsize;
                option.x = x;
                option.y = y;
                // Copy & pasted from the above options loop
                // Todo: make this into its own helper function?
                for (j = 0; j < schema.length; j += 1) {
                    for (k = 0; k < schema[j].length; k += 1) {
                        if (schema[j][k].command) {
                            if (schema[j][k].x) {
                                x += schema[j][k].x * this.GameStarter.unitsize;
                            }
                            if (schema[j][k].y) {
                                y += schema[j][k].y * this.GameStarter.unitsize;
                            }
                        }
                        else if (schema[j][k] !== " ") {
                            option.title = title = "Char" + this.getCharacterEquivalent(schema[j][k]);
                            character = this.GameStarter.ObjectMaker.make(title);
                            menu.children.push(character);
                            optionChild.things.push(character);
                            this.GameStarter.addThing(character, x, y);
                            x += character.width * this.GameStarter.unitsize;
                        }
                        else {
                            x += textWidth;
                        }
                    }
                }
                menu.gridRows += 1;
                for (j = 0; j < menu.grid.length; j += 1) {
                    menu.grid[j].push(option);
                }
            }
            if (menu.scrollingItemsComputed) {
                menu.scrollingItems = this.computeMenuScrollingItems(menu);
            }
            if (menu.scrollingItems) {
                menu.scrollingVisualOffset = 0;
                for (i = menu.scrollingItems; i < menu.gridRows; i += 1) {
                    optionChild = optionChildren[i];
                    for (j = 0; j < optionChild.things.length; j += 1) {
                        optionChild.things[j].hidden = true;
                    }
                }
            }
            menu.selectedIndex = selectedIndex;
            menu.arrow = character = this.GameStarter.ObjectMaker.make("CharArrowRight");
            menu.children.push(character);
            character.hidden = (this.activeMenu !== menu);
            option = menu.grid[selectedIndex[0]][selectedIndex[1]];
            this.GameStarter.addThing(character);
            this.GameStarter.setRight(character, option.x - menu.arrowXOffset * this.GameStarter.unitsize);
            this.GameStarter.setTop(character, option.y + menu.arrowYOffset * this.GameStarter.unitsize);
        };
        /**
         * Retrives the currently selected grid cell of a menu.
         *
         * @param name   The name of the menu.
         * @returns The currently selected grid cell of the menu.
         */
        MenuGraphr.prototype.getMenuSelectedOption = function (name) {
            var menu = this.getExistingMenu(name);
            if (!menu.grid || !menu.selectedIndex) {
                throw new Error("The " + name + " menu does not behave like a list menu.");
            }
            return menu.grid[menu.selectedIndex[0]][menu.selectedIndex[1]];
        };
        /**
         * Shifts the selected index of a list menu, adjusting for scrolling if necessary.
         *
         * @param name   The name of the menu.
         * @param dx   How far along the menu's grid to shift horizontally.
         * @param dy   How far along the menu's grid to shift vertically.
         */
        MenuGraphr.prototype.shiftSelectedIndex = function (name, dx, dy) {
            var menu = this.getExistingMenu(name), textProperties = this.GameStarter.ObjectMaker.getPropertiesOf("Text"), textPaddingY = (menu.textPaddingY || textProperties.paddingY) * this.GameStarter.unitsize, option, x, y;
            if (menu.scrollingItems) {
                x = menu.selectedIndex[0] + dx;
                y = menu.selectedIndex[1] + dy;
                x = Math.max(Math.min(menu.gridColumns - 1, x), 0);
                y = Math.max(Math.min(menu.gridRows - 1, y), 0);
            }
            else {
                x = (menu.selectedIndex[0] + dx) % menu.gridColumns;
                y = (menu.selectedIndex[1] + dy) % menu.gridRows;
                while (x < 0) {
                    x += menu.gridColumns;
                }
                while (y < 0) {
                    y += menu.gridRows;
                }
            }
            if (x === menu.selectedIndex[0] && y === menu.selectedIndex[1]) {
                return;
            }
            menu.selectedIndex[0] = x;
            menu.selectedIndex[1] = y;
            option = this.getMenuSelectedOption(name);
            if (menu.scrollingItems) {
                this.scrollListThings(name, dy, textPaddingY);
            }
            this.GameStarter.setRight(menu.arrow, option.x - menu.arrowXOffset * this.GameStarter.unitsize);
            this.GameStarter.setTop(menu.arrow, option.y + menu.arrowYOffset * this.GameStarter.unitsize);
        };
        /**
         * Sets the current selected index of a menu.
         *
         * @param name   The name of the menu.
         * @param x   The new horizontal value for the index.
         * @param y   The new vertical value for the index.
         */
        MenuGraphr.prototype.setSelectedIndex = function (name, x, y) {
            var menu = this.getExistingMenu(name), selectedIndex = menu.selectedIndex;
            this.shiftSelectedIndex(name, x - selectedIndex[0], y - selectedIndex[1]);
        };
        /* Interactivity
        */
        /**
         * Sets the currently active menu.
         *
         * @param name   The name of the menu to set as active. If not given, no menu
         *               is set as active.
         */
        MenuGraphr.prototype.setActiveMenu = function (name) {
            if (this.activeMenu && this.activeMenu.onInactive) {
                this.activeMenu.onInactive(this.activeMenu.name);
            }
            if (typeof name !== "undefined") {
                this.activeMenu = this.menus[name];
                if (this.activeMenu && this.activeMenu.onActive) {
                    this.activeMenu.onActive(name);
                }
            }
        };
        /**
         * Reacts to a user event directing in the given direction.
         *
         * @param direction   The direction of the interaction.
         */
        MenuGraphr.prototype.registerDirection = function (direction) {
            switch (direction) {
                case Direction.Top:
                    return this.registerUp();
                case Direction.Right:
                    return this.registerRight();
                case Direction.Bottom:
                    return this.registerDown();
                case Direction.Left:
                    return this.registerLeft();
                default:
                    throw new Error("Unknown direction: " + direction);
            }
        };
        /**
         * Reacts to a user event directing up.
         */
        MenuGraphr.prototype.registerUp = function () {
            var menu = this.activeMenu;
            if (!menu) {
                return;
            }
            if (menu.selectedIndex) {
                this.shiftSelectedIndex(menu.name, 0, -1);
            }
            if (menu.onUp) {
                menu.onUp(this.GameStarter);
            }
        };
        /**
         * Reacts to a user event directing to the right.
         */
        MenuGraphr.prototype.registerRight = function () {
            var menu = this.activeMenu;
            if (!menu) {
                return;
            }
            if (menu.selectedIndex) {
                this.shiftSelectedIndex(menu.name, 1, 0);
            }
            if (menu.onRight) {
                menu.onRight(this.GameStarter);
            }
        };
        /**
         * Reacts to a user event directing down.
         */
        MenuGraphr.prototype.registerDown = function () {
            var menu = this.activeMenu;
            if (!menu) {
                return;
            }
            if (menu.selectedIndex) {
                this.shiftSelectedIndex(menu.name, 0, 1);
            }
            if (menu.onDown) {
                menu.onDown(this.GameStarter);
            }
        };
        /**
         * Reacts to a user event directing to the left.
         */
        MenuGraphr.prototype.registerLeft = function () {
            var menu = this.activeMenu;
            if (!menu) {
                return;
            }
            if (menu.selectedIndex) {
                this.shiftSelectedIndex(menu.name, -1, 0);
            }
            if (menu.onLeft) {
                menu.onLeft(this.GameStarter);
            }
        };
        /**
         * Reacts to a user event from pressing a selection key.
         */
        MenuGraphr.prototype.registerA = function () {
            var menu = this.activeMenu;
            if (!menu || menu.ignoreA) {
                return;
            }
            if (menu.callback) {
                menu.callback(menu.name);
            }
        };
        /**
         * Reacts to a user event from pressing a deselection key.
         */
        MenuGraphr.prototype.registerB = function () {
            var menu = this.activeMenu;
            if (!menu) {
                return;
            }
            if (menu.progress && !menu.ignoreProgressB) {
                return this.registerA();
            }
            if (menu.ignoreB) {
                return;
            }
            if (menu.onBPress) {
                menu.onBPress(menu.name);
                return;
            }
            if (menu.keepOnBack) {
                this.setActiveMenu(menu.backMenu);
            }
            else {
                this.deleteMenu(menu.name);
            }
        };
        /**
         * Reacts to a user event from pressing a start key.
         */
        MenuGraphr.prototype.registerStart = function () {
            var menu = this.activeMenu;
            if (!menu) {
                return;
            }
            if (menu.startMenu) {
                this.setActiveMenu(menu.startMenu);
            }
        };
        /* Utilities
        */
        /**
         * Adds a series of words to a menu.
         *
         * @param name   The name of the menu.
         * @param words   Words to add to the menu, as String[]s and/or commands.
         * @param onCompletion   An optional event for when the words are added.
         */
        MenuGraphr.prototype.addMenuText = function (name, words, onCompletion) {
            var menu = this.getExistingMenu(name), x = this.GameStarter.getMidX(menu), y = menu.top + menu.textYOffset * this.GameStarter.unitsize;
            switch (menu.textStartingX) {
                case "right":
                    x += menu.textAreaWidth / 2;
                    break;
                case "center":
                    break;
                default:
                    x -= menu.textAreaWidth / 2;
            }
            menu.callback = this.continueMenu.bind(this);
            menu.textX = x;
            if (words.length) {
                this.addMenuWords(name, words, 0, x, y, onCompletion);
            }
            else {
                onCompletion();
            }
        };
        /**
         * Adds a word within a series of words to a menu, then adds the next word,
         * and so on. This is the real force behind addMenuDialog and addMenuText.
         *
         * @param name   The name of the menu.
         * @param words   Words to add to the menu, as String[]s and/or commands.
         * @param i   The index of the current word to add.
         * @param x   The x-location to place the word at.
         * @param y   The y-location to place the word at.
         * @param onCompletion   An optional event for when the words are added.
         * @returns The generated Things from the word's characters.
         */
        MenuGraphr.prototype.addMenuWords = function (name, words, i, x, y, onCompletion) {
            var _this = this;
            var menu = this.getExistingMenu(name), textProperties = this.GameStarter.ObjectMaker.getPropertiesOf("Text"), command, word, things = [], textWidth, textPaddingX, textPaddingY, textSpeed, textWidthMultiplier, character, j;
            // Command objects must be parsed here in case they modify the x/y position
            if (words[i].command) {
                command = words[i];
                word = this.parseWordCommand(command, menu);
                if (command.command === "position") {
                    x += command.x || 0;
                    y += command.y || 0;
                }
            }
            else {
                word = words[i];
            }
            textSpeed = menu.textSpeed;
            textWidth = (menu.textWidth || textProperties.width) * this.GameStarter.unitsize;
            textPaddingX = (menu.textPaddingX || textProperties.paddingX) * this.GameStarter.unitsize;
            textPaddingY = (menu.textPaddingY || textProperties.paddingY) * this.GameStarter.unitsize;
            textWidthMultiplier = menu.textWidthMultiplier || 1;
            // For each character in the word, schedule it appearing in the menu
            for (j = 0; j < word.length; j += 1) {
                // For non-whitespace characters, add them and move to the right
                if (/\S/.test(word[j])) {
                    character = this.addMenuCharacter(name, word[j], x, y, j * textSpeed);
                    x += textWidthMultiplier * (character.width * this.GameStarter.unitsize + textPaddingX);
                    continue;
                }
                // Endlines skip a line; general whitespace moves to the right
                // (" " spaces at the start do not move to the right)
                if (word[j] === "\n") {
                    x = menu.textX;
                    y += textPaddingY;
                }
                else if (word[j] !== " " || x !== menu.textX) {
                    x += textWidth * textWidthMultiplier;
                }
            }
            // Only create a new progress object if one doesn't exist (slight performance boost)
            if (!menu.progress) {
                menu.progress = {};
            }
            // If this is the last word in the the line (words), mark progress as done
            if (i === words.length - 1) {
                menu.progress.complete = true;
                menu.progress.onCompletion = onCompletion;
                if (menu.finishAutomatically) {
                    this.GameStarter.TimeHandler.addEvent(onCompletion, (word.length + (menu.finishAutomaticSpeed || 1)) * textSpeed);
                }
                this.GameStarter.TimeHandler.addEvent(function () {
                    menu.progress.working = false;
                }, (j + 1) * textSpeed);
                return things;
            }
            // If the next word would pass the edge of the menu, move down a line
            if (x + this.computeFutureWordLength(words[i + 1], textWidth, textPaddingX) >= menu.right - menu.textXOffset) {
                x = menu.textX;
                y += textPaddingY;
            }
            // Mark the menu's progress as working and incomplete
            menu.progress.working = true;
            menu.progress.complete = false;
            menu.progress.onCompletion = onCompletion;
            menu.progress.words = words;
            menu.progress.i = i + 1;
            menu.progress.x = x;
            menu.progress.y = y - textPaddingY;
            // If the bottom of the menu has been reached, pause the progress
            if (y >= menu.bottom - (menu.textYOffset - 1) * this.GameStarter.unitsize) {
                this.GameStarter.TimeHandler.addEvent(function () {
                    menu.progress.working = false;
                }, (j + 1) * textSpeed);
                return things;
            }
            if (textSpeed) {
                this.GameStarter.TimeHandler.addEvent(function () {
                    _this.addMenuWords(name, words, i + 1, x, y, onCompletion);
                }, (j + 1) * textSpeed);
            }
            else {
                this.addMenuWords(name, words, i + 1, x, y, onCompletion);
            }
            return things;
        };
        /**
         * Places and positions a Thing within a menu basd on its size and position schemas.
         *
         * @param thing   The Thing to place and position.
         * @param size   An optional description of the Thing's size.
         * @param position   An optional description of the Thing's position.
         * @param skipAdd   Whether to skip calling this.GameStarter.addThing on the Thing.
         */
        MenuGraphr.prototype.placeMenuThing = function (menu, thing, size, position, skipAdd) {
            if (size === void 0) { size = {}; }
            if (position === void 0) { position = {}; }
            var offset = position.offset || {};
            if (size.width) {
                this.GameStarter.setWidth(thing, size.width);
            }
            else if (position.horizontal === "stretch") {
                this.GameStarter.setLeft(thing, 0);
                this.GameStarter.setWidth(thing, menu.width - (offset.left || 0) - (offset.right || 0));
            }
            if (size.height) {
                this.GameStarter.setHeight(thing, size.height);
            }
            else if (position.vertical === "stretch") {
                this.GameStarter.setTop(thing, 0);
                this.GameStarter.setHeight(thing, menu.height - (offset.top || 0) - (offset.bottom || 0));
            }
            switch (position.horizontal) {
                case "center":
                    this.GameStarter.setMidXObj(thing, menu);
                    break;
                case "right":
                    this.GameStarter.setRight(thing, menu.right);
                    break;
                default:
                    this.GameStarter.setLeft(thing, menu.left);
                    break;
            }
            switch (position.vertical) {
                case "center":
                    this.GameStarter.setMidYObj(thing, menu);
                    break;
                case "bottom":
                    this.GameStarter.setBottom(thing, menu.bottom);
                    break;
                default:
                    this.GameStarter.setTop(thing, menu.top);
                    break;
            }
            if (offset.top) {
                this.GameStarter.shiftVert(thing, position.offset.top * this.GameStarter.unitsize);
            }
            if (offset.left) {
                this.GameStarter.shiftHoriz(thing, position.offset.left * this.GameStarter.unitsize);
            }
            if (!skipAdd) {
                this.GameStarter.addThing(thing, thing.left, thing.top);
            }
        };
        /**
         * Adds a single character as an GameStartr.IThing to a menu, potentially with a time delay.
         *
         * @param name   The name of the menu.
         * @param character   The character to add.
         * @param x   The x-position of the character.
         * @param y   The y-position of the character.
         * @param delay   Optionally, how long to delay adding using TimeHandlr.
         * @returns The character's new Thing representation.
         */
        MenuGraphr.prototype.addMenuCharacter = function (name, character, x, y, delay) {
            var _this = this;
            var menu = this.getExistingMenu(name), textProperties = this.GameStarter.ObjectMaker.getPropertiesOf("Text"), textPaddingY = (menu.textPaddingY || textProperties.paddingY) * this.GameStarter.unitsize, title = "Char" + this.getCharacterEquivalent(character), thing = this.GameStarter.ObjectMaker.make(title, {
                "textPaddingY": textPaddingY
            });
            menu.children.push(thing);
            if (delay) {
                this.GameStarter.TimeHandler.addEvent(function () {
                    _this.GameStarter.addThing(thing, x, y);
                }, delay);
            }
            else {
                this.GameStarter.addThing(thing, x, y);
            }
            return thing;
        };
        /**
         * Scrolls a menu's character up once. If it's above the menu's area, it's deleted.
         *
         * @param character   The Thing to scroll up.
         * @param menu
         * @returns Whether the character was deleted.
         */
        MenuGraphr.prototype.scrollCharacterUp = function (character, menu) {
            this.GameStarter.shiftVert(character, -this.GameStarter.unitsize);
            if (character.top < menu.top + (menu.textYOffset - 1) * this.GameStarter.unitsize) {
                this.GameStarter.killNormal(character);
                return true;
            }
            return false;
        };
        /**
         * Deletes all children of a menu.
         *
         * @param name   The name of the menu.
         */
        MenuGraphr.prototype.deleteMenuChildren = function (name) {
            var _this = this;
            var menu = this.menus[name];
            if (menu && menu.children) {
                menu.children.forEach(function (child) { return _this.deleteMenuChild(child); });
            }
        };
        /**
         * Deletes the child of a menu and any of its children.
         *
         * @param child   A menu child to delete.
         */
        MenuGraphr.prototype.deleteMenuChild = function (child) {
            if (this.activeMenu === child) {
                if (child.backMenu) {
                    this.setActiveMenu(child.backMenu);
                }
                else {
                    this.activeMenu = undefined;
                }
            }
            if (child.killOnB) {
                child.killOnB.forEach(this.deleteMenu.bind(this));
            }
            if (child.name) {
                delete this.menus[child.name];
            }
            this.GameStarter.killNormal(child);
            this.deleteMenuChildren(name);
            if (child.onMenuDelete) {
                child.onMenuDelete.call(this.GameStarter);
            }
            if (child.children) {
                child.children.forEach(this.deleteMenuChild.bind(this));
            }
        };
        /* List utilities
        */
        /**
         * Un-hides a list menu's arrow Thing.
         *
         * @param name   The name of the menu.
         */
        MenuGraphr.prototype.activateMenuList = function (name) {
            var menu = this.menus[name];
            if (menu && menu.arrow) {
                menu.arrow.hidden = false;
            }
        };
        /**
         * Hides a list menu's arrow Thing.
         *
         * @param name   The name of the menu.
         */
        MenuGraphr.prototype.deactivateMenuList = function (name) {
            var menu = this.menus[name];
            if (menu && menu.arrow) {
                menu.arrow.hidden = true;
            }
        };
        /**
         * Runs the callback for a menu's selected list option.
         *
         * @param name   The name of the menu.
         */
        MenuGraphr.prototype.triggerMenuListOption = function (name) {
            var selected = this.getMenuSelectedOption(name);
            if (selected.callback) {
                selected.callback.call(this, name);
            }
        };
        /**
         * Determines how many scrolling items are able to fit within a list menu, as
         * the index of the first bottom not within the menu.
         *
         * @param menu   The list menu.
         * @returns The number of scrolling items, or Infinity if they all fit.
         */
        MenuGraphr.prototype.computeMenuScrollingItems = function (menu) {
            var bottom = menu.bottom
                - (menu.textPaddingY * this.GameStarter.unitsize || 0)
                - (menu.textYOffset * this.GameStarter.unitsize || 0), i;
            for (i = 0; i < menu.gridRows; i += 1) {
                if (menu.grid[0][i].y >= bottom) {
                    return i;
                }
            }
            return Infinity;
        };
        /**
         * Scrolls a list menu's Things vertically.
         *
         * @param name   The name of the menu.
         * @param dy   How far along the list menu's grid to scroll.
         * @param textPaddingY   How much text is padded, to compute scrolling with dy.
         */
        MenuGraphr.prototype.scrollListThings = function (name, dy, textPaddingY) {
            var menu = this.getExistingMenu(name), scrollingOld = menu.selectedIndex[1] - dy, offset = -dy * textPaddingY, option, optionChild, i, j;
            if (dy > 0) {
                if (scrollingOld - menu.scrollingVisualOffset < menu.scrollingItems - 1) {
                    return;
                }
            }
            else if (scrollingOld - menu.scrollingVisualOffset > 0) {
                return;
            }
            menu.scrollingVisualOffset += dy;
            for (i = 0; i < menu.optionChildren.length; i += 1) {
                option = menu.options[i];
                optionChild = menu.optionChildren[i];
                option.y += offset;
                for (j = 0; j < optionChild.things.length; j += 1) {
                    this.GameStarter.shiftVert(optionChild.things[j], offset);
                    if (i < menu.scrollingVisualOffset
                        || i >= menu.scrollingItems + menu.scrollingVisualOffset) {
                        optionChild.things[j].hidden = true;
                    }
                    else {
                        optionChild.things[j].hidden = false;
                    }
                }
            }
        };
        /* Text parsing
        */
        /**
         * @param character   A String to retrieve an equivalent title of.
         * @returns The character's title from this.aliases if it exists, or the
         *          character itself otherwise.
         */
        MenuGraphr.prototype.getCharacterEquivalent = function (character) {
            if (this.aliases.hasOwnProperty(character)) {
                return this.aliases[character];
            }
            return character;
        };
        /**
         * @param dialogRaw   Raw dialog of any type.
         * @returns The dialog parsed into lines of words.
         */
        MenuGraphr.prototype.parseRawDialog = function (dialogRaw) {
            // A raw String becomes a single line of dialog
            if (dialogRaw.constructor === String) {
                return [this.parseRawDialogString(dialogRaw)];
            }
            var output = [], component, i;
            for (i = 0; i < dialogRaw.length; i += 1) {
                component = dialogRaw[i];
                if (component.constructor === String) {
                    output.push(this.parseRawDialogString(component));
                }
                else {
                    output.push(this.parseRawDialogStrings(component));
                }
            }
            return output;
        };
        /**
         * @param dialogRaw   A raw String or set of Strings.
         * @returns The raw dialog as lines of words.
         */
        MenuGraphr.prototype.parseRawDialogString = function (dialogRaw) {
            var characters = this.filterWord(dialogRaw), words = [], word, currentlyWhitespace = undefined, i;
            word = [];
            // For each character to be added...
            for (i = 0; i < characters.length; i += 1) {
                // If it matches what's currently being added (whitespace or not), keep going
                if (currentlyWhitespace) {
                    if (/\s/.test(characters[i])) {
                        word.push(characters[i]);
                        continue;
                    }
                }
                else {
                    if (/\S/.test(characters[i])) {
                        word.push(characters[i]);
                        continue;
                    }
                }
                // Since it doesn't match, start a new word
                currentlyWhitespace = /\s/.test(characters[i]);
                words.push(word);
                word = [characters[i]];
            }
            // Any extra characters should be added as well
            if (word.length > 0) {
                words.push(word);
            }
            return words;
        };
        /**
         * @param words   Any number of raw dialog words.
         * @returns The words filtered using this.parseRawDialogString.
         */
        MenuGraphr.prototype.parseRawDialogStrings = function (words) {
            var output = [], i;
            for (i = 0; i < words.length; i += 1) {
                output.push.apply(output, this.parseRawDialogString(words[i]));
            }
            return output;
        };
        /**
         * @param wordRaw   A word that may need to have replacements applied.
         * @returns The same word as an Array of characters, and with replacements applied.
         */
        MenuGraphr.prototype.filterWord = function (wordRaw) {
            if (wordRaw.constructor === Array) {
                return wordRaw;
            }
            var word = wordRaw, output = [], start = 0, end, inside;
            start = word.indexOf("%%%%%%%", start);
            end = word.indexOf("%%%%%%%", start + 1);
            if (start !== -1 && end !== -1) {
                inside = this.getReplacement(word.substring(start + "%%%%%%%".length, end));
                if (inside.constructor === Number) {
                    inside = inside.toString().split("");
                }
                else if (inside.constructor === String) {
                    inside = inside.split("");
                }
                output.push.apply(output, word.substring(0, start).split(""));
                output.push.apply(output, inside);
                output.push.apply(output, this.filterWord(word.substring(end + "%%%%%%%".length)));
                return output;
            }
            return word.split("");
        };
        /**
         * Filters all String words in a menu's text using this.filterWord.
         *
         * @param words   The words to filter, as Strings or command Objects.
         * @returns The words, with all Strings filtered.
         */
        MenuGraphr.prototype.filterMenuWords = function (words) {
            var output = [], i;
            for (i = 0; i < words.length; i += 1) {
                if (words[i].constructor === String) {
                    output.push(this.filterWord(words[i]));
                }
                else {
                    output.push(words[i]);
                }
            }
            return output;
        };
        /**
         * @param textRaw   Text that, if String(s), should be filtered using this.filterWord.
         * @returns The words, filtered.
         */
        MenuGraphr.prototype.filterText = function (textRaw) {
            if (textRaw.constructor === Array) {
                if (textRaw.length === 0) {
                    return [];
                }
                if (textRaw[0].constructor === String) {
                    return [textRaw];
                }
                return textRaw;
            }
            var characters = [], total = textRaw, component = "", i;
            for (i = 0; i < total.length; i += 1) {
                if (/\s/.test(total[i])) {
                    if (component.length > 0) {
                        characters.push.apply(characters, this.filterWord(component));
                        component = "";
                    }
                    characters.push(total[i]);
                    continue;
                }
                component += total[i];
            }
            if (component.length > 0) {
                characters.push.apply(characters, this.filterWord(component));
            }
            return [characters];
        };
        /**
         * Converts a word command into its equivalent word text.
         *
         * @param wordCommand   The word command.
         * @param menu   The menu containing the word command.
         * @returns The equivalent word text for the command.
         */
        MenuGraphr.prototype.parseWordCommand = function (wordCommand, menu) {
            // If no menu is provided, this is from a simulation; pretend there is a menu
            if (!menu) {
                menu = {};
            }
            switch (wordCommand.command) {
                case "attribute":
                    menu[wordCommand.attribute + "Old"] = menu[wordCommand.attribute];
                    menu[wordCommand.attribute] = wordCommand.value;
                    if (wordCommand.applyUnitsize) {
                        menu[wordCommand.attribute] *= this.GameStarter.unitsize;
                    }
                    break;
                case "attributeReset":
                    menu[wordCommand.attribute] = menu[wordCommand.attribute + "Old"];
                    break;
                case "padLeft":
                    return this.parseWordCommandPadLeft(wordCommand);
                // Position is handled directly in addMenuWord
                case "position":
                    break;
                default:
                    throw new Error("Unknown word command: " + wordCommand.command);
            }
            return wordCommand.word.split("");
        };
        /**
         * Converts a word command to pad text from the left.
         *
         * @param wordCommand   The word command.
         * @returns   The word command's parsed text.
         */
        MenuGraphr.prototype.parseWordCommandPadLeft = function (wordCommand) {
            var filtered = this.filterWord(wordCommand.word), length;
            // Length may be a String (for its length) or a direct number
            switch (wordCommand.length.constructor) {
                case String:
                    length = this.filterText(wordCommand.length)[0].length;
                    break;
                case Number:
                    length = wordCommand.length;
                    break;
                default:
                    throw new Error("Unknown padLeft command: " + wordCommand);
            }
            // Right-aligned commands reduce the amount of spacing by the length of the word
            if (wordCommand.alignRight) {
                length = Math.max(0, length - filtered.length);
            }
            // Tabs are considered to be a single space, so they're added to the left
            filtered.unshift.apply(filtered, this.stringOf("\t", length).split(""));
            return filtered;
        };
        /**
         * Retrieves the value of a text replacement of the given key.
         *
         * @param key   The key of the text replacement to retrieve.
         * @returns The value of the text replacement, if it exists.
         */
        MenuGraphr.prototype.getReplacement = function (key) {
            var replacement = this.replacements[key];
            if (typeof replacement === "undefined") {
                return [""];
            }
            else if (typeof replacement === "function") {
                return replacement.call(this, this.GameStarter);
            }
            else {
                return replacement;
            }
        };
        /**
         * Creates a new String equivalent to an old String repeated any number of
         * times. If times is 0, a blank String is returned.
         *
         * @param string   The characters to repeat.
         * @param times   How many times to repeat (by default, 1).
         * @returns The original string, repeated.
         */
        MenuGraphr.prototype.stringOf = function (string, times) {
            if (times === void 0) { times = 1; }
            return (times === 0) ? "" : new Array(1 + (times)).join(string);
        };
        /**
         * Predicts how wide a word's area will be when displayed as dialog.
         *
         * @param wordRaw   The word that will be displayed.
         * @param textWidth   How wide each character should be.
         * @param textPaddingX   How much space between each character.
         * @returns The total predicted width of the word's area.
         * @remarks This ignores commands under the assumption they shouldn't be
         *          used in dialogs that react to box size. This may be wrong.
         */
        MenuGraphr.prototype.computeFutureWordLength = function (wordRaw, textWidth, textPaddingX) {
            var total = 0, word, i;
            if (wordRaw.constructor === Array) {
                word = wordRaw;
            }
            else {
                word = this.parseWordCommand(wordRaw);
            }
            for (i = 0; i < word.length; i += 1) {
                if (/\s/.test(word[i])) {
                    total += textWidth + textPaddingX;
                }
                else {
                    total += this.computeFutureLetterLength(word[i]) + textPaddingX;
                }
            }
            return total;
        };
        /**
         * Predicts how wide a letter will be, based on its equivalent Thing's width.
         *
         * @param letter   The name of the letter to create.
         * @returns How wide the letter will be on the screen.
         */
        MenuGraphr.prototype.computeFutureLetterLength = function (letter) {
            var title = "Char" + this.getCharacterEquivalent(letter), properties = this.GameStarter.ObjectMaker.getFullPropertiesOf(title);
            return properties.width * this.GameStarter.unitsize;
        };
        return MenuGraphr;
    })();
    MenuGraphr_1.MenuGraphr = MenuGraphr;
})(MenuGraphr || (MenuGraphr = {}));
/// <reference path="EightBittr-0.2.0.ts" />
/// <reference path="GroupHoldr-0.2.1.ts" />
/// <reference path="MathDecidr-0.2.0.ts" />
/// <reference path="MapScreenr-0.2.1.ts" />
/// <reference path="MenuGraphr-0.2.0.ts" />
/// <reference path="ObjectMakr-0.2.2.ts" />
/// <reference path="ScenePlayr-0.2.0.ts" />
var BattleMovr;
(function (BattleMovr_1) {
    "use strict";
    var BattleMovr = (function () {
        /**
         * @param {IBattleMovrSettings} settings
         */
        function BattleMovr(settings) {
            if (typeof settings.GameStarter === "undefined") {
                throw new Error("No GameStarter given to BattleMovr.");
            }
            if (typeof settings.MenuGrapher === "undefined") {
                throw new Error("No MenuGrapher given to BattleMovr.");
            }
            if (typeof settings.battleMenuName === "undefined") {
                throw new Error("No battleMenuName given to BattleMovr.");
            }
            if (typeof settings.battleOptionNames === "undefined") {
                throw new Error("No battleOptionNames given to BattleMovr.");
            }
            if (typeof settings.menuNames === "undefined") {
                throw new Error("No menuNames given to BattleMovr.");
            }
            this.GameStarter = settings.GameStarter;
            this.MenuGrapher = settings.MenuGrapher;
            this.battleMenuName = settings.battleMenuName;
            this.battleOptionNames = settings.battleOptionNames;
            this.menuNames = settings.menuNames;
            this.openItemsMenuCallback = settings.openItemsMenuCallback;
            this.openActorsMenuCallback = settings.openActorsMenuCallback;
            this.defaults = settings.defaults || {};
            this.backgroundType = settings.backgroundType;
            this.positions = settings.positions;
            this.inBattle = false;
            this.things = {};
        }
        /* Simple gets
        */
        /**
         *
         */
        BattleMovr.prototype.getGameStarter = function () {
            return this.GameStarter;
        };
        /**
         *
         */
        BattleMovr.prototype.getThings = function () {
            return this.things;
        };
        /**
         *
         */
        BattleMovr.prototype.getThing = function (name) {
            return this.things[name];
        };
        /**
         *
         */
        BattleMovr.prototype.getBattleInfo = function () {
            return this.battleInfo;
        };
        /**
         *
         */
        BattleMovr.prototype.getBackgroundType = function () {
            return this.backgroundType;
        };
        /**
         *
         */
        BattleMovr.prototype.getBackgroundThing = function () {
            return this.backgroundThing;
        };
        /**
         *
         */
        BattleMovr.prototype.getInBattle = function () {
            return this.inBattle;
        };
        /* Actor manipulations
        */
        /**
         *
         */
        BattleMovr.prototype.startBattle = function (settings) {
            if (this.inBattle) {
                return;
            }
            var i;
            this.inBattle = true;
            this.battleInfo = this.GameStarter.proliferate({}, this.defaults);
            // A shallow copy is used here for performance, and so Things in .keptThings
            // don't cause an infinite loop proliferating
            for (i in settings) {
                if (settings.hasOwnProperty(i)) {
                    this.battleInfo[i] = settings[i];
                }
            }
            this.battleInfo.player.selectedActor = this.battleInfo.player.actors[0];
            this.battleInfo.opponent.selectedActor = this.battleInfo.opponent.actors[0];
            this.createBackground();
            this.MenuGrapher.createMenu("Battle", {
                "ignoreB": true
            });
            this.MenuGrapher.createMenu("BattleDisplayInitial");
            this.things.menu = this.MenuGrapher.getMenu("BattleDisplayInitial");
            this.setThing("opponent", this.battleInfo.opponent.sprite);
            this.setThing("player", this.battleInfo.player.sprite);
            this.GameStarter.ScenePlayer.startCutscene("Battle", {
                "things": this.things,
                "battleInfo": this.battleInfo,
                "nextCutscene": settings.nextCutscene,
                "nextCutsceneSettings": settings.nextCutsceneSettings
            });
        };
        /**
         *
         */
        BattleMovr.prototype.closeBattle = function (callback) {
            var i;
            if (!this.inBattle) {
                return;
            }
            this.inBattle = false;
            for (i in this.things) {
                if (this.things.hasOwnProperty(i)) {
                    this.GameStarter.killNormal(this.things[i]);
                }
            }
            this.deleteBackground();
            this.GameStarter.MapScreener.inMenu = false;
            this.MenuGrapher.deleteMenu("Battle");
            this.MenuGrapher.deleteMenu("GeneralText");
            this.MenuGrapher.deleteMenu("BattleOptions");
            if (callback) {
                callback();
            }
            this.GameStarter.ScenePlayer.playRoutine("Complete");
            if (this.battleInfo.nextCutscene) {
                this.GameStarter.ScenePlayer.startCutscene(this.battleInfo.nextCutscene, this.battleInfo.nextCutsceneSettings);
            }
            else if (this.battleInfo.nextRoutine) {
                this.GameStarter.ScenePlayer.playRoutine(this.battleInfo.nextRoutine, this.battleInfo.nextRoutineSettings);
            }
            else {
                this.GameStarter.ScenePlayer.stopCutscene();
            }
        };
        /**
         *
         */
        BattleMovr.prototype.showPlayerMenu = function () {
            this.MenuGrapher.createMenu("BattleOptions", {
                "ignoreB": true
            });
            this.MenuGrapher.addMenuList("BattleOptions", {
                "options": [
                    {
                        "text": this.battleOptionNames.moves,
                        "callback": this.openMovesMenu.bind(this)
                    }, {
                        "text": this.battleOptionNames.items,
                        "callback": this.openItemsMenu.bind(this)
                    }, {
                        "text": this.battleOptionNames.actors,
                        "callback": this.openActorsMenu.bind(this)
                    }, {
                        "text": this.battleOptionNames.exit,
                        "callback": this.startBattleExit.bind(this)
                    }]
            });
            this.MenuGrapher.setActiveMenu("BattleOptions");
        };
        /**
         *
         */
        BattleMovr.prototype.setThing = function (name, title, settings) {
            var position = this.positions[name] || {}, battleMenu = this.MenuGrapher.getMenu(this.battleMenuName), thing = this.things[name];
            if (thing) {
                this.GameStarter.killNormal(thing);
            }
            thing = this.things[name] = this.GameStarter.ObjectMaker.make(title, settings);
            this.GameStarter.addThing(thing, battleMenu.left + (position.left || 0) * this.GameStarter.unitsize, battleMenu.top + (position.top || 0) * this.GameStarter.unitsize);
            this.GameStarter.GroupHolder.switchMemberGroup(thing, thing.groupType, "Text");
            return thing;
        };
        /* In-battle menus
        */
        /**
         *
         */
        BattleMovr.prototype.openMovesMenu = function () {
            var actorMoves = this.battleInfo.player.selectedActor.moves, moveOptions = [], move, i;
            for (i = 0; i < actorMoves.length; i += 1) {
                move = actorMoves[i];
                moveOptions[i] = {
                    "text": move.title.toUpperCase(),
                    "remaining": move.remaining,
                    "callback": this.playMove.bind(this, move.title)
                };
            }
            for (i = actorMoves.length; i < 4; i += 1) {
                moveOptions[i] = {
                    "text": "-"
                };
            }
            this.MenuGrapher.createMenu(this.menuNames.moves);
            this.MenuGrapher.addMenuList(this.menuNames.moves, {
                "options": moveOptions
            });
            this.MenuGrapher.setActiveMenu(this.menuNames.moves);
        };
        /**
         *
         */
        BattleMovr.prototype.openItemsMenu = function () {
            this.openItemsMenuCallback({
                "items": this.battleInfo.items,
                "position": {
                    "horizontal": "right",
                    "vertical": "bottom",
                    "offset": {
                        "left": 0
                    }
                },
                "size": {
                    "height": 44
                },
                "container": "Battle",
                "backMenu": "BattleOptions",
                "scrollingItems": 4
            });
        };
        /**
         *
         */
        BattleMovr.prototype.openActorsMenu = function (callback) {
            this.openActorsMenuCallback({
                "backMenu": "BattleOptions",
                "container": "Battle",
                "onSwitch": this.switchActor.bind(this)
            });
        };
        /* Battle shenanigans
        */
        /**
         *
         */
        BattleMovr.prototype.playMove = function (choicePlayer) {
            var choiceOpponent, playerMovesFirst;
            choiceOpponent = this.GameStarter.MathDecider.compute("opponentMove", this.battleInfo.player, this.battleInfo.opponent);
            playerMovesFirst = this.GameStarter.MathDecider.compute("playerMovesFirst", this.battleInfo.player, choicePlayer, this.battleInfo.opponent, choiceOpponent);
            if (playerMovesFirst) {
                this.GameStarter.ScenePlayer.playRoutine("MovePlayer", {
                    "nextRoutine": "MoveOpponent",
                    "choicePlayer": choicePlayer,
                    "choiceOpponent": choiceOpponent
                });
            }
            else {
                this.GameStarter.ScenePlayer.playRoutine("MoveOpponent", {
                    "nextRoutine": "MovePlayer",
                    "choicePlayer": choicePlayer,
                    "choiceOpponent": choiceOpponent
                });
            }
        };
        /**
         *
         */
        BattleMovr.prototype.switchActor = function (battlerName, i) {
            var battler = this.battleInfo[battlerName];
            if (battler.selectedIndex === i) {
                this.GameStarter.ScenePlayer.playRoutine("PlayerSwitchesSamePokemon");
                return;
            }
            battler.selectedIndex = i;
            battler.selectedActor = battler.actors[i];
            this.GameStarter.ScenePlayer.playRoutine((battlerName === "player" ? "Player" : "Opponent") + "SendOut");
        };
        /* Battle exits
        */
        /**
         *
         */
        BattleMovr.prototype.startBattleExit = function () {
            if (this.battleInfo.opponent.category === "Trainer") {
                this.GameStarter.ScenePlayer.playRoutine("BattleExitFail");
                return;
            }
            this.MenuGrapher.deleteMenu("BattleOptions");
            this.MenuGrapher.addMenuDialog("GeneralText", this.battleInfo.exitDialog || this.defaults.exitDialog || "", this.closeBattle.bind(this));
            this.MenuGrapher.setActiveMenu("GeneralText");
        };
        /* Utilities
        */
        /**
         *
         */
        BattleMovr.prototype.createBackground = function () {
            if (!this.backgroundType) {
                return;
            }
            this.backgroundThing = this.GameStarter.addThing(this.backgroundType);
            this.GameStarter.setWidth(this.backgroundThing, this.GameStarter.MapScreener.width / 4);
            this.GameStarter.setHeight(this.backgroundThing, this.GameStarter.MapScreener.height / 4);
            this.GameStarter.GroupHolder.switchMemberGroup(this.backgroundThing, this.backgroundThing.groupType, "Text");
        };
        /**
         *
         */
        BattleMovr.prototype.deleteBackground = function () {
            if (this.backgroundThing) {
                this.GameStarter.killNormal(this.backgroundThing);
            }
        };
        return BattleMovr;
    })();
    BattleMovr_1.BattleMovr = BattleMovr;
})(BattleMovr || (BattleMovr = {}));
/// <reference path="ItemsHoldr-0.2.1.ts" />
var StateHoldr;
(function (StateHoldr_1) {
    "use strict";
    /**
     * A utility to save collections of game state using an ItemsHoldr.
     * Keyed changes to named collections can be saved temporarily or permanently.
     */
    var StateHoldr = (function () {
        /**
         * Initializes a new instance of the StateHoldr class.
         *
         * @param settings   Settings to be used for initialization.
         */
        function StateHoldr(settings) {
            if (!settings.ItemsHolder) {
                throw new Error("No ItemsHolder given to StateHoldr.");
            }
            this.ItemsHolder = settings.ItemsHolder;
            this.prefix = settings.prefix || "StateHolder";
        }
        /* Simple gets
        */
        /**
         * @returns The ItemsHoldr instance that stores data.
         */
        StateHoldr.prototype.getItemsHolder = function () {
            return this.ItemsHolder;
        };
        /**
         * @returns The prefix used for ItemsHoldr keys.
         */
        StateHoldr.prototype.getPrefix = function () {
            return this.prefix;
        };
        /**
         * @returns The current key for the collection, with the prefix.
         */
        StateHoldr.prototype.getCollectionKey = function () {
            return this.collectionKey;
        };
        /**
         * @returns The current key for the collection, without the prefix.
         */
        StateHoldr.prototype.getCollectionKeyRaw = function () {
            return this.collectionKeyRaw;
        };
        /**
         * @returns The current Object with attributes saved within.
         */
        StateHoldr.prototype.getCollection = function () {
            return this.collection;
        };
        /**
         * @param otherCollectionKeyRaw   A key for a collection to retrieve.
         * @returns The collection stored under the raw key, if it exists.
         */
        StateHoldr.prototype.getOtherCollection = function (otherCollectionKeyRaw) {
            var otherCollectionKey = this.prefix + otherCollectionKeyRaw;
            this.ensureCollectionKeyExists(otherCollectionKey);
            return this.ItemsHolder.getItem(otherCollectionKey);
        };
        /**
         * @param itemKey   The item key whose changes are being retrieved.
         * @returns Any changes under the itemKey, if it exists.
         */
        StateHoldr.prototype.getChanges = function (itemKey) {
            return this.getCollectionItemSafely(itemKey);
        };
        /**
         * @param itemKey   The item key whose changes are being retrieved.
         * @param valueKey   The specific change being requested.
         * @returns The changes for the specific item, if it exists.
         */
        StateHoldr.prototype.getChange = function (itemKey, valueKey) {
            return this.getCollectionItemSafely(itemKey)[valueKey];
        };
        /* Storage
        */
        /**
         * Sets the currently tracked collection.
         *
         * @param collectionKeyRawNew   The raw key of the new collection
         *                              to switch to.
         * @param value   An optional container of values to set the new
         *                collection equal to.
         */
        StateHoldr.prototype.setCollection = function (collectionKeyRawNew, value) {
            this.collectionKeyRaw = collectionKeyRawNew;
            this.collectionKey = this.prefix + this.collectionKeyRaw;
            this.ensureCollectionKeyExists(this.collectionKey);
            if (value) {
                this.ItemsHolder.setItem(this.collectionKey, value);
            }
            this.collection = this.ItemsHolder.getItem(this.collectionKey);
        };
        /**
         * Saves the currently tracked collection into the ItemsHolder.
         */
        StateHoldr.prototype.saveCollection = function () {
            this.ItemsHolder.setItem(this.collectionKey, this.collection);
        };
        /**
         * Adds a change to the collection, stored as a key-value pair under an item.
         *
         * @param itemKey   The key for the item experiencing the change.
         * @param valueKey   The attribute of the item being changed.
         * @param value   The actual value being stored.
         */
        StateHoldr.prototype.addChange = function (itemKey, valueKey, value) {
            this.getCollectionItemSafely(itemKey)[valueKey] = value;
        };
        /**
         * Adds a change to any collection requested by the key, stored as a key-value
         * pair under an item.
         *
         * @param collectionKeyOtherRaw   The raw key for the other collection
         *                                to add the change under.
         * @param itemKey   The key for the item experiencing the change.
         * @param valueKey   The attribute of the item being changed.
         * @param value   The actual value being stored.
         */
        StateHoldr.prototype.addCollectionChange = function (collectionKeyOtherRaw, itemKey, valueKey, value) {
            var collectionKeyOther = this.prefix + collectionKeyOtherRaw, otherCollection;
            this.ensureCollectionKeyExists(collectionKeyOther);
            otherCollection = this.ItemsHolder.getItem(collectionKeyOther);
            if (typeof otherCollection[itemKey] === "undefined") {
                otherCollection[itemKey] = {};
            }
            otherCollection[itemKey][valueKey] = value;
            this.ItemsHolder.setItem(collectionKeyOther, otherCollection);
        };
        /**
         * Copies all changes from a contained item into an output item.
         *
         * @param itemKey   The key for the contained item.
         * @param output   The recipient for all the changes.
         */
        StateHoldr.prototype.applyChanges = function (itemKey, output) {
            var changes = this.collection[itemKey], key;
            if (!changes) {
                return;
            }
            for (key in changes) {
                if (changes.hasOwnProperty(key)) {
                    output[key] = changes[key];
                }
            }
        };
        /* Utilities
        */
        /**
         * Ensures a collection exists by checking for it and creating it under
         * the internal ItemsHoldr if it doesn't.
         *
         * @param collectionKey   The key for the collection that must exist,
         *                        including the prefix.
         */
        StateHoldr.prototype.ensureCollectionKeyExists = function (collectionKey) {
            if (!this.ItemsHolder.hasKey(collectionKey)) {
                this.ItemsHolder.addItem(collectionKey, {
                    "valueDefault": {},
                    "storeLocally": true
                });
            }
        };
        /**
         * Ensures an item in the current collection exists by checking for it and
         * creating it if it doesn't.
         *
         * @param itemKey   The item key that must exist.
         * @returns The item in the collection under the given key.
         */
        StateHoldr.prototype.getCollectionItemSafely = function (itemKey) {
            if (typeof this.collection[itemKey] === "undefined") {
                return this.collection[itemKey] = {};
            }
            return this.collection[itemKey];
        };
        return StateHoldr;
    })();
    StateHoldr_1.StateHoldr = StateHoldr;
})(StateHoldr || (StateHoldr = {}));
// @echo '/// <reference path="BattleMovr-0.2.0.ts" />'
// @echo '/// <reference path="GameStartr-0.2.0.ts" />'
// @echo '/// <reference path="MenuGraphr-0.2.0.ts" />'
// @echo '/// <reference path="StateHoldr-0.2.0.ts" />'
// @ifdef INCLUDE_DEFINITIONS
/// <reference path="References/BattleMovr-0.2.0.ts" />
/// <reference path="References/GameStartr-0.2.0.ts" />
/// <reference path="References/MenuGraphr-0.2.0.ts" />
/// <reference path="References/StateHoldr-0.2.0.ts" />
/// <reference path="FullScreenPokemon.d.ts" />
/// <reference path="FullScreenPokemon.Cutscenes.d.ts" />
// @endif
// @include ../Source/FullScreenPokemon.d.ts
// @include ../Source/FullScreenPokemon.Cutscenes.d.ts
var FullScreenPokemon;
(function (FullScreenPokemon_1) {
    "use strict";
    /**
     * What direction(s) the screen may scroll from player movement.
     */
    (function (Scrollability) {
        /**
         * The screen may not scroll in either direction.
         */
        Scrollability[Scrollability["None"] = 0] = "None";
        /**
         * The screen may scroll vertically.
         */
        Scrollability[Scrollability["Vertical"] = 1] = "Vertical";
        /**
         * The screen may scroll horizontally.
         */
        Scrollability[Scrollability["Horizontal"] = 2] = "Horizontal";
        /**
         * The screen may scroll vertically and horizontally.
         */
        Scrollability[Scrollability["Both"] = 3] = "Both";
    })(FullScreenPokemon_1.Scrollability || (FullScreenPokemon_1.Scrollability = {}));
    var Scrollability = FullScreenPokemon_1.Scrollability;
    ;
    /**
     * Cardinal directions a Thing may face in-game.
     */
    (function (Direction) {
        Direction[Direction["Top"] = 0] = "Top";
        Direction[Direction["Right"] = 1] = "Right";
        Direction[Direction["Bottom"] = 2] = "Bottom";
        Direction[Direction["Left"] = 3] = "Left";
    })(FullScreenPokemon_1.Direction || (FullScreenPokemon_1.Direction = {}));
    var Direction = FullScreenPokemon_1.Direction;
    ;
    /**
     * Whether a Pokemon is unknown, has been caught, or has been seen.
     */
    (function (PokedexListingStatus) {
        PokedexListingStatus[PokedexListingStatus["Unknown"] = 0] = "Unknown";
        PokedexListingStatus[PokedexListingStatus["Caught"] = 1] = "Caught";
        PokedexListingStatus[PokedexListingStatus["Seen"] = 2] = "Seen";
    })(FullScreenPokemon_1.PokedexListingStatus || (FullScreenPokemon_1.PokedexListingStatus = {}));
    var PokedexListingStatus = FullScreenPokemon_1.PokedexListingStatus;
    ;
    /**
     * Direction names, mapped to their opposites.
     */
    FullScreenPokemon_1.DirectionOpposites = {
        "Top": "Bottom",
        "top": "bottom",
        "Right": "Left",
        "right": "left",
        "Bottom": "Top",
        "bottom": "top",
        "Left": "Right",
        "left": "right"
    };
    /**
     * Directions, keyed by their string aliases.
     */
    FullScreenPokemon_1.DirectionAliases = {
        "top": Direction.Top,
        "right": Direction.Right,
        "bottom": Direction.Bottom,
        "left": Direction.Left
    };
    /**
     * String aliases of directions, keyed by the direction.
     */
    FullScreenPokemon_1.DirectionsToAliases = ["top", "right", "bottom", "left"];
    /**
     * Classes to add to Things facing particular directions.
     */
    FullScreenPokemon_1.DirectionClasses = ["up", "right", "down", "left"];
    /**
     * Direction aliases for AreaSpawner activations.
     */
    FullScreenPokemon_1.DirectionSpawns = ["yDec", "xInc", "yInc", "xInc"];
    /**
     * A free HTML5 remake of Nintendo's original Pokemon, expanded for the modern web.
     */
    var FullScreenPokemon = (function (_super) {
        __extends(FullScreenPokemon, _super);
        /**
         * Initializes a new instance of the FullScreenPokemon class using the static
         * settings stored in `FullScreenPokemon.settings`.
         *
         * @param settings   Extra settings such as screen size.
         */
        function FullScreenPokemon(settings) {
            this.settings = FullScreenPokemon.settings;
            this.ticksElapsed = 0;
            _super.call(this, this.proliferate({
                "constantsSource": FullScreenPokemon,
                "constants": [
                    "unitsize",
                    "scale"
                ],
                "extraResets": [
                    "resetStateHolder",
                    "resetMenuGrapher",
                    "resetBattleMover",
                ]
            }, settings));
        }
        /* Resets
        */
        /**
         * Sets this.ObjectMaker.
         *
         * Because many Thing functions require access to other FSP modules, each is
         * given a reference to this container FSP via properties.thing.FSP.
         *
         * @param FSP
         * @param customs   Any optional custom settings.
         */
        FullScreenPokemon.prototype.resetObjectMaker = function (FSP, settings) {
            FSP.ObjectMaker = new ObjectMakr.ObjectMakr(FSP.proliferate({
                "properties": {
                    "Quadrant": {
                        "EightBitter": FSP,
                        "GameStarter": FSP,
                        "FSP": FSP
                    },
                    "Thing": {
                        "EightBitter": FSP,
                        "GameStarter": FSP,
                        "FSP": FSP
                    }
                }
            }, FSP.settings.objects));
        };
        /**
         * Sets this.MathDecider, adding its existing NumberMaker to the constants.
         *
         * @param FSP
         * @param customs   Any optional custom settings.
         */
        FullScreenPokemon.prototype.resetMathDecider = function (FSP, settings) {
            FSP.MathDecider = new MathDecidr.MathDecidr(FSP.proliferate({
                "constants": {
                    "NumberMaker": FSP.NumberMaker
                }
            }, FSP.settings.math));
        };
        /**
         * Sets this.StateHolder.
         *
         * @param FSP
         * @param customs   Any optional custom settings.
         */
        FullScreenPokemon.prototype.resetStateHolder = function (FSP, settings) {
            FSP.StateHolder = new StateHoldr.StateHoldr(FSP.proliferate({
                "ItemsHolder": FSP.ItemsHolder
            }, FSP.settings.states));
        };
        /**
         * Sets this.MenuGrapher.
         *
         * @param FSP
         * @param customs   Any optional custom settings.
         */
        FullScreenPokemon.prototype.resetMenuGrapher = function (FSP, settings) {
            FSP.MenuGrapher = new MenuGraphr.MenuGraphr(FSP.proliferate({
                "GameStarter": FSP
            }, FSP.settings.menus));
        };
        /**
         * Sets this.BattleMover.
         *
         * @param FSP
         * @param customs   Any optional custom settings.
         */
        FullScreenPokemon.prototype.resetBattleMover = function (FSP, settings) {
            FSP.BattleMover = new BattleMovr.BattleMovr(FSP.proliferate({
                "GameStarter": FSP,
                "MenuGrapher": FSP.MenuGrapher,
                "openItemsMenuCallback": FSP.openItemsMenu.bind(FSP),
                "openActorsMenuCallback": FSP.openPokemonMenu.bind(FSP)
            }, FSP.settings.battles));
        };
        /**
         * Sets this.container.
         *
         * The container is given the "Press Start" font, and the PixelRender is told
         * which groups to draw in order.
         *
         * @param FSM
         * @param settings   Extra settings such as screen size.
         */
        FullScreenPokemon.prototype.resetContainer = function (FSP, settings) {
            _super.prototype.resetContainer.call(this, FSP, settings);
            FSP.container.style.fontFamily = "Press Start";
            FSP.container.className += " FullScreenPokemon";
            FSP.PixelDrawer.setThingArrays([
                FSP.GroupHolder.getGroup("Terrain"),
                FSP.GroupHolder.getGroup("Solid"),
                FSP.GroupHolder.getGroup("Scenery"),
                FSP.GroupHolder.getGroup("Character"),
                FSP.GroupHolder.getGroup("Text")
            ]);
        };
        /* Global manipulations
        */
        /**
         * Completely restarts the game. The StartOptions menu is shown.
         */
        FullScreenPokemon.prototype.gameStart = function () {
            this.gameStartOptions(this);
            this.ModAttacher.fireEvent("onGameStart");
        };
        /**
         * Sets the map to Blank and displays the StartOptions menu.
         *
         * @param FSP
         */
        FullScreenPokemon.prototype.gameStartOptions = function (FSP) {
            var options = [
                {
                    "text": "NEW GAME",
                    "callback": FSP.gameStartIntro.bind(FSP, FSP)
                }, {
                    "text": "LOAD FILE",
                    "callback": FSP.gameLoadFile.bind(FSP, FSP)
                }];
            if (FSP.ItemsHolder.getItem("gameStarted")) {
                options.unshift({
                    "text": "CONTINUE",
                    "callback": FSP.gameStartPlay.bind(FSP, FSP)
                });
            }
            FSP.setMap("Blank");
            FSP.MenuGrapher.createMenu("StartOptions");
            FSP.MenuGrapher.addMenuList("StartOptions", {
                options: options
            });
            FSP.MenuGrapher.setActiveMenu("StartOptions");
        };
        /**
         * Starts the game in the saved map and location from ItemsHolder, and fires the
         * onGameStartPlay mod trigger.
         *
         * @param FSP
         */
        FullScreenPokemon.prototype.gameStartPlay = function (FSP) {
            FSP.setMap(FSP.ItemsHolder.getItem("map") || FSP.settings.maps.mapDefault, FSP.ItemsHolder.getItem("location"), true);
            FSP.mapEntranceResume(FSP);
            FSP.ModAttacher.fireEvent("onGameStartPlay");
        };
        /**
         * Starts the game's intro, and fires the onGameStartIntro mod trigger.
         *
         * @param FSP
         */
        FullScreenPokemon.prototype.gameStartIntro = function (FSP) {
            FSP.ItemsHolder.clear();
            FSP.ScenePlayer.startCutscene("Intro", {
                "disablePauseMenu": true
            });
            FSP.ModAttacher.fireEvent("onGameStartIntro");
        };
        /**
         * Loads a file using a dummy HTMLInputElement, then starts the game with it as
         * game state. The onGameStartIntro mod event is triggered.
         *
         * @param FSP
         */
        FullScreenPokemon.prototype.gameLoadFile = function (FSP) {
            var dummy = FSP.createElement("input", {
                "type": "file",
                "onchange": function (event) {
                    var file = (dummy.files || event.dataTransfer.files)[0], reader;
                    event.preventDefault();
                    event.stopPropagation();
                    if (!file) {
                        return;
                    }
                    reader = new FileReader();
                    reader.onloadend = function (event) {
                        FSP.gameLoadData(FSP, event.currentTarget.result);
                    };
                    reader.readAsText(file);
                }
            });
            dummy.click();
            FSP.ModAttacher.fireEvent("onGameStartIntro");
        };
        /**
         * Loads JSON game data from a data string and sets it as the game state,
         * then starts gameplay.
         *
         * @param FSP
         * @param dataRaw   Raw data to be parsed as JSON.
         */
        FullScreenPokemon.prototype.gameLoadData = function (FSP, dataRaw) {
            var data = JSON.parse(dataRaw), key, keyStart = "StateHolder::", split;
            for (key in data) {
                if (!data.hasOwnProperty(key)) {
                    continue;
                }
                if (key.slice(0, keyStart.length) === keyStart) {
                    split = key.split("::");
                    FSP.StateHolder.setCollection(split[1] + "::" + split[2], data[key]);
                }
                else {
                    FSP.ItemsHolder.setItem(key, data[key]);
                }
            }
            FSP.MenuGrapher.deleteActiveMenu();
            FSP.gameStartPlay(FSP);
            FSP.ItemsHolder.setItem("gameStarted", true);
        };
        /**
         * Slight addition to the parent thingProcess Function. The Thing's hit
         * check type is cached immediately, and a default id is assigned if an id
         * isn't already present.
         *
         * @param thing   The Thing being processed.
         * @param title   What type Thing this is (the name of the class).
         * @param settings   Additional settings to be given to the Thing.
         * @param defaults   The default settings for the Thing's class.
         * @remarks This is generally called as the onMake call in an ObjectMakr.
         */
        FullScreenPokemon.prototype.thingProcess = function (thing, title, settings, defaults) {
            _super.prototype.thingProcess.call(this, thing, title, settings, defaults);
            // ThingHittr becomes very non-performant if functions aren't generated
            // for each Thing constructor (optimization does not respect prototypal 
            // inheritance, sadly).
            thing.FSP.ThingHitter.cacheChecksForType(thing.title, thing.groupType);
            thing.bordering = [undefined, undefined, undefined, undefined];
            if (typeof thing.id === "undefined") {
                thing.id = [
                    thing.FSP.AreaSpawner.getMapName(),
                    thing.FSP.AreaSpawner.getAreaName(),
                    thing.title,
                    (thing.name || "Anonymous")
                ].join("::");
            }
        };
        /**
         * Processes additional Thing attributes. For each attribute the Area's
         * class says it may have, if it has it, the attribute value proliferated
         * onto the Area.
         *
         * @param area The Area being processed.
         */
        FullScreenPokemon.prototype.areaProcess = function (area) {
            var attributes = area.attributes, attribute;
            for (attribute in attributes) {
                if (area[attribute]) {
                    FullScreenPokemon.prototype.proliferate(area, attributes[attribute]);
                }
            }
        };
        /**
         * Starts the game (currently a no-op).
         *
         * @param FSP
         */
        FullScreenPokemon.prototype.onGamePlay = function (FSP) {
            console.log("Playing!");
        };
        /**
         * Pauses the game (currently a no-op).
         *
         * @param FSP
         */
        FullScreenPokemon.prototype.onGamePause = function (FSP) {
            console.log("Paused.");
        };
        /**
         * Overriden Function to adds a new Thing to the game at a given position,
         * relative to the top left corner of the screen. The Thing is also
         * added to the MapScreener.thingsById container.
         *
         *
         * @param thingRaw   What type of Thing to add. This may be a String of
         *                   the class title, an Array containing the String
         *                   and an Object of settings, or an actual Thing.
         * @param left   The horizontal point to place the Thing's left at (by
         *               default, 0).
         * @param top   The vertical point to place the Thing's top at (by default,
         *              0).
         * @param useSavedInfo   Whether an Area's saved info in StateHolder should be
         *                       applied to the Thing's position (by default, false).
         */
        FullScreenPokemon.prototype.addThing = function (thingRaw, left, top, useSavedInfo) {
            if (left === void 0) { left = 0; }
            if (top === void 0) { top = 0; }
            var thing = _super.prototype.addThing.call(this, thingRaw, left, top);
            if (useSavedInfo) {
                thing.FSP.applyThingSavedPosition(thing);
            }
            if (thing.id) {
                thing.FSP.StateHolder.applyChanges(thing.id, thing);
                thing.FSP.MapScreener.thingsById[thing.id] = thing;
            }
            if (typeof thing.direction !== "undefined") {
                thing.FSP.animateCharacterSetDirection(thing, thing.direction);
            }
            return thing;
        };
        /**
         * Applies a thing's stored xloc and yloc to its position.
         *
         * @param thing   A Thing being placed in the game.
         */
        FullScreenPokemon.prototype.applyThingSavedPosition = function (thing) {
            var savedInfo = thing.FSP.StateHolder.getChanges(thing.id);
            if (!savedInfo) {
                return;
            }
            if (savedInfo.xloc) {
                thing.FSP.setLeft(thing, thing.FSP.MapScreener.left + savedInfo.xloc * thing.FSP.unitsize);
            }
            if (savedInfo.yloc) {
                thing.FSP.setTop(thing, thing.FSP.MapScreener.top + savedInfo.yloc * thing.FSP.unitsize);
            }
        };
        /**
         * Adds a Thing via addPreThing based on the specifications in a PreThing.
         * This is done relative to MapScreener.left and MapScreener.top.
         *
         * @param prething   A PreThing whose Thing is to be added to the game.
         */
        FullScreenPokemon.prototype.addPreThing = function (prething) {
            var thing = prething.thing, position = prething.position || thing.position;
            if (thing.spawned) {
                return;
            }
            thing.spawned = true;
            thing.areaName = thing.areaName || thing.FSP.AreaSpawner.getAreaName();
            thing.mapName = thing.mapName || thing.FSP.AreaSpawner.getMapName();
            thing.FSP.addThing(thing, prething.left * thing.FSP.unitsize - thing.FSP.MapScreener.left, prething.top * thing.FSP.unitsize - thing.FSP.MapScreener.top, true);
            // Either the prething or thing, in that order, may request to be in the
            // front or back of the container
            if (position) {
                thing.FSP.TimeHandler.addEvent(function () {
                    switch (position) {
                        case "beginning":
                            thing.FSP.arrayToBeginning(thing, thing.FSP.GroupHolder.getGroup(thing.groupType));
                            break;
                        case "end":
                            thing.FSP.arrayToEnd(thing, thing.FSP.GroupHolder.getGroup(thing.groupType));
                            break;
                        default:
                            throw new Error("Unknown position: " + position + ".");
                    }
                });
            }
            thing.FSP.ModAttacher.fireEvent("onAddPreThing", prething);
        };
        /**
         * Adds a new Player Thing to the game and sets it as EightBitter.player. Any
         * required additional settings (namely keys, power/size, and swimming) are
         * applied here.
         *
         * @param left   A left edge to place the Thing at (by default, 0).
         * @param bottom   A top to place the Thing upon (by default, 0).
         * @param useSavedInfo   Whether an Area's saved info in StateHolder should be
         *                       applied to the Thing's position (by default, false).
         * @returns A newly created Player in the game.
         */
        FullScreenPokemon.prototype.addPlayer = function (left, top, useSavedInfo) {
            if (left === void 0) { left = 0; }
            if (top === void 0) { top = 0; }
            var player = this.player = this.ObjectMaker.make("Player");
            player.keys = player.getKeys();
            this.InputWriter.setEventInformation(player);
            this.addThing(player, left || 0, top || 0, useSavedInfo);
            this.ModAttacher.fireEvent("onAddPlayer", player);
            return player;
        };
        /**
         * Retrieves the Thing in MapScreener.thingById of the given id.
         *
         * @param id   An id of a Thing to retrieve.
         * @returns The Thing under the given id, if it exists.
         */
        FullScreenPokemon.prototype.getThingById = function (id) {
            return this.MapScreener.thingsById[id];
        };
        /* Inputs
        */
        /**
         * Checks whether inputs may trigger, which is always true, and prevents the event.
         *
         * @param FSP
         * @param player   FSP's current user-controlled Player.
         * @param code   An key/mouse code from the event.
         * @param event   The original user-caused Event.
         * @returns Whether inputs may trigger (true).
         */
        FullScreenPokemon.prototype.canInputsTrigger = function (FSP, player, code, event) {
            if (event) {
                event.preventDefault();
            }
            return true;
        };
        /**
         * Checks whether direction keys such as up may trigger, which is true if the
         * game isn't paused, the isn't an active menu, and the MapScreener doesn't
         * specify blockInputs = true.
         *
         * @param FSP
         * @returns Whether direction keys may trigger.
         */
        FullScreenPokemon.prototype.canDirectionsTrigger = function (FSP) {
            if (FSP.GamesRunner.getPaused()) {
                return false;
            }
            if (FSP.MenuGrapher.getActiveMenu()) {
                return true;
            }
            return !FSP.MapScreener.blockInputs;
        };
        /**
         *
         * Reacts to a Character simulating an up key press. If possible, this causes
         * walking in the left direction. The onKeyDownUp mod trigger is fired.
         *
         * @param thing   The triggering Character.
         * @param event   The original user-caused Event.
         */
        FullScreenPokemon.prototype.keyDownUp = function (thing, event) {
            if (!thing.FSP.canDirectionsTrigger(thing.FSP)) {
                return;
            }
            if (thing.player) {
                thing.keys[Direction.Top] = true;
            }
            thing.FSP.TimeHandler.addEvent(thing.FSP.keyDownDirectionReal, FullScreenPokemon.inputTimeTolerance, thing, 0);
            thing.FSP.ModAttacher.fireEvent("onKeyDownUpReal");
            if (event && event.preventDefault) {
                event.preventDefault();
            }
        };
        /**
         *
         * Reacts to a Character simulating a right key press. If possible, this causes
         * walking in the left direction. The onKeyDownRight mod trigger is fired.
         *
         * @param thing   The triggering Character.
         * @param event   The original user-caused Event.
         */
        FullScreenPokemon.prototype.keyDownRight = function (thing, event) {
            if (!thing.FSP.canDirectionsTrigger(thing.FSP)) {
                return;
            }
            if (thing.player) {
                thing.keys[Direction.Right] = true;
            }
            thing.FSP.TimeHandler.addEvent(thing.FSP.keyDownDirectionReal, FullScreenPokemon.inputTimeTolerance, thing, 1);
            if (event && event.preventDefault) {
                event.preventDefault();
            }
        };
        /**
         *
         * Reacts to a Character simulating a down key press. If possible, this causes
         * walking in the left direction. The onKeyDownDown mod trigger is fired.
         *
         * @param thing   The triggering Character.
         * @param event   The original user-caused Event.
         */
        FullScreenPokemon.prototype.keyDownDown = function (thing, event) {
            if (!thing.FSP.canDirectionsTrigger(thing.FSP)) {
                return;
            }
            if (thing.player) {
                thing.keys[Direction.Bottom] = true;
            }
            thing.FSP.TimeHandler.addEvent(thing.FSP.keyDownDirectionReal, FullScreenPokemon.inputTimeTolerance, thing, 2);
            thing.FSP.ModAttacher.fireEvent("onKeyDownDown");
            if (event && event.preventDefault) {
                event.preventDefault();
            }
        };
        /**
         * Reacts to a Character simulating a left key press. If possible, this causes
         * walking in the left direction. The onKeyDownLeft mod trigger is fired.
         *
         * @param thing   The triggering Character.
         * @param event   The original user-caused Event.
         */
        FullScreenPokemon.prototype.keyDownLeft = function (thing, event) {
            if (!thing.FSP.canDirectionsTrigger(thing.FSP)) {
                return;
            }
            if (thing.player) {
                thing.keys[Direction.Left] = true;
            }
            thing.FSP.TimeHandler.addEvent(thing.FSP.keyDownDirectionReal, FullScreenPokemon.inputTimeTolerance, thing, 3);
            thing.FSP.ModAttacher.fireEvent("onKeyDownLeft");
        };
        /**
         * Driver for a direction key being pressed. The MenuGraphr's active menu reacts
         * to the movement if it exists, or the triggering Character attempts to walk
         * if not. The onKeyDownDirectionReal mod event is fired.
         *
         * @param thing   The triggering Character.
         * @param event   The original user-caused Event.
         */
        FullScreenPokemon.prototype.keyDownDirectionReal = function (thing, direction) {
            if (!thing.player || !thing.keys[direction]) {
                return;
            }
            if (thing.FSP.MenuGrapher.getActiveMenu()) {
                thing.FSP.MenuGrapher.registerDirection(direction);
            }
            else {
                if (thing.direction !== direction) {
                    thing.turning = direction;
                }
                if (thing.player) {
                    thing.FSP.keyDownDirectionRealPlayer(thing, direction);
                }
            }
            thing.FSP.ModAttacher.fireEvent("onKeyDownDirectionReal", direction);
        };
        FullScreenPokemon.prototype.keyDownDirectionRealPlayer = function (player, direction) {
            if (player.canKeyWalking && !player.shouldWalk) {
                player.FSP.setPlayerDirection(player, direction);
                player.canKeyWalking = false;
            }
            else {
                player.nextDirection = direction;
            }
        };
        /**
         * Reacts to the A key being pressed. The MenuGraphr's active menu reacts to
         * the selection if it exists. The onKeyDownA mod event is fired.
         *
         * @param thing   The triggering Character.
         * @param event   The original user-caused Event.
         */
        FullScreenPokemon.prototype.keyDownA = function (thing, event) {
            if (thing.FSP.GamesRunner.getPaused()) {
                return;
            }
            if (thing.FSP.MenuGrapher.getActiveMenu()) {
                thing.FSP.MenuGrapher.registerA();
            }
            else if (thing.bordering[thing.direction]) {
                if (thing.bordering[thing.direction].activate) {
                    thing.bordering[thing.direction].activate(thing, thing.bordering[thing.direction]);
                }
                if (thing.keys) {
                    thing.keys.a = true;
                }
            }
            thing.FSP.ModAttacher.fireEvent("onKeyDownA");
            if (event && event.preventDefault) {
                event.preventDefault();
            }
        };
        /**
         * Reacts to the B key being pressed. The MenuGraphr's active menu reacts to
         * the deselection if it exists. The onKeyDownB mod event is fired.
         *
         * @param thing   The triggering Character.
         * @param event   The original user-caused Event.
         */
        FullScreenPokemon.prototype.keyDownB = function (thing, event) {
            if (thing.FSP.GamesRunner.getPaused()) {
                return;
            }
            if (thing.FSP.MenuGrapher.getActiveMenu()) {
                thing.FSP.MenuGrapher.registerB();
            }
            else if (thing.keys) {
                thing.keys.b = true;
            }
            thing.FSP.ModAttacher.fireEvent("onKeyDownB");
            if (event && event.preventDefault) {
                event.preventDefault();
            }
        };
        /**
         * Reacts to the pause key being pressed. The game is paused if it isn't
         * already. The onKeyDownPause mod event is fired.
         *
         * @param thing   The triggering Character.
         * @param event   The original user-caused Event.
         */
        FullScreenPokemon.prototype.keyDownPause = function (thing, event) {
            if (!thing.FSP.GamesRunner.getPaused()) {
                thing.FSP.GamesRunner.pause();
            }
            thing.FSP.ModAttacher.fireEvent("onKeyDownPause");
            if (event && event.preventDefault) {
                event.preventDefault();
            }
        };
        /**
         * Reacts to the mute key being pressed. The game has mute toggled, and the
         * onKeyDownMute mod event is fired.
         *
         * @param thing   The triggering Character.
         * @param event   The original user-caused Event.
         */
        FullScreenPokemon.prototype.keyDownMute = function (thing, event) {
            thing.FSP.AudioPlayer.toggleMuted();
            thing.FSP.ModAttacher.fireEvent("onKeyDownMute");
            if (event && event.preventDefault) {
                event.preventDefault();
            }
        };
        /**
         * Reacts to the select key being pressed. Toggles the use of the registered item.
         *
         * @param thing   The triggering Character.
         * @param event   The original user-caused Event.
         * @todo Extend the use for any registered item, not just the bicycle.
         */
        FullScreenPokemon.prototype.keyDownSelect = function (thing, event) {
            if (thing.FSP.MenuGrapher.getActiveMenu()) {
                return;
            }
            thing.FSP.ModAttacher.fireEvent("onKeyDownSelect");
            var selectItem = thing.FSP.ItemsHolder.getItem("SelectItem");
            if (!selectItem) {
                return;
            }
            var itemSchema = thing.FSP.MathDecider.getConstant("items")[selectItem];
            if (!itemSchema.bagActivate(thing)) {
                thing.FSP.displayMessage(thing, itemSchema.error);
            }
            if (event && event.preventDefault) {
                event.preventDefault();
            }
        };
        /**
         * Reacts to the left key being lifted. The onKeyUpLeft mod event is fired.
         *
         * @param thing   The triggering Character.
         * @param event   The original user-caused Event.
         */
        FullScreenPokemon.prototype.keyUpLeft = function (thing, event) {
            thing.FSP.ModAttacher.fireEvent("onKeyUpLeft");
            if (thing.player) {
                thing.keys[3] = false;
                if (thing.nextDirection === 3) {
                    delete thing.nextDirection;
                }
            }
            if (event && event.preventDefault) {
                event.preventDefault();
            }
        };
        /**
         *
         * Reacts to the right key being lifted. The onKeyUpRight mod event is fired.
         *
         * @param thing   The triggering Character.
         * @param event   The original user-caused Event.
         */
        FullScreenPokemon.prototype.keyUpRight = function (thing, event) {
            thing.FSP.ModAttacher.fireEvent("onKeyUpRight");
            if (thing.player) {
                thing.keys[1] = false;
                if (thing.nextDirection === 1) {
                    delete thing.nextDirection;
                }
            }
            if (event && event.preventDefault) {
                event.preventDefault();
            }
        };
        /**
         * Reacts to the up key being lifted. The onKeyUpUp mod event is fired.
         *
         * @param thing   The triggering Character.
         * @param event   The original user-caused Event.
         */
        FullScreenPokemon.prototype.keyUpUp = function (thing, event) {
            thing.FSP.ModAttacher.fireEvent("onKeyUpUp");
            if (thing.player) {
                thing.keys[0] = false;
                if (thing.nextDirection === 0) {
                    delete thing.nextDirection;
                }
            }
            if (event && event.preventDefault) {
                event.preventDefault();
            }
        };
        /**
         *
         * Reacts to the down key being lifted. The onKeyUpDown mod event is fired.
         *
         * @param thing   The triggering Character.
         * @param event   The original user-caused Event.
         */
        FullScreenPokemon.prototype.keyUpDown = function (thing, event) {
            thing.FSP.ModAttacher.fireEvent("onKeyUpDown");
            if (thing.player) {
                thing.keys[2] = false;
                if (thing.nextDirection === 2) {
                    delete thing.nextDirection;
                }
            }
            if (event && event.preventDefault) {
                event.preventDefault();
            }
        };
        /**
         * Reacts to the A key being lifted. The onKeyUpA mod event is fired.
         *
         * @param thing   The triggering Character.
         * @param event   The original user-caused Event.
         */
        FullScreenPokemon.prototype.keyUpA = function (thing, event) {
            thing.FSP.ModAttacher.fireEvent("onKeyUpA");
            if (thing.player) {
                thing.keys.a = false;
            }
            if (event && event.preventDefault) {
                event.preventDefault();
            }
        };
        /**
         * Reacts to the B key being lifted. The onKeyUpB mod event is fired.
         *
         * @param thing   The triggering Character.
         * @param event   The original user-caused Event.
         */
        FullScreenPokemon.prototype.keyUpB = function (thing, event) {
            thing.FSP.ModAttacher.fireEvent("onKeyUpB");
            if (thing.player) {
                thing.keys.b = false;
            }
            if (event && event.preventDefault) {
                event.preventDefault();
            }
        };
        /**
         * Reacts to the pause key being lifted. The onKeyUpLeft mod event is fired.
         *
         * @param thing   The triggering Character.
         * @param event   The original user-caused Event.
         */
        FullScreenPokemon.prototype.keyUpPause = function (thing, event) {
            if (thing.FSP.GamesRunner.getPaused()) {
                thing.FSP.GamesRunner.play();
            }
            thing.FSP.ModAttacher.fireEvent("onKeyUpPause");
            if (event && event.preventDefault) {
                event.preventDefault();
            }
        };
        /**
         * Reacts to the context menu being activated. The pause menu is opened,
         * and the onMouseDownRight mod event is fired.
         *
         * @param thing   The triggering Character.
         * @param event   The original user-caused Event.
         */
        FullScreenPokemon.prototype.mouseDownRight = function (thing, event) {
            thing.FSP.togglePauseMenu(thing);
            thing.FSP.ModAttacher.fireEvent("onMouseDownRight");
            if (event && event.preventDefault) {
                event.preventDefault();
            }
        };
        /* Upkeep maintenance
        */
        /**
         * Generic maintenance Function for a group of Things. For each Thing, if
         * it isn't alive, it's removed from the group.
         *
         * @param FSP
         * @param things   A group of Things to maintain.
         */
        FullScreenPokemon.prototype.maintainGeneric = function (FSP, things) {
            for (var i = 0; i < things.length; i += 1) {
                if (!things[i].alive) {
                    FSP.arrayDeleteThing(things[i], things, i);
                    i -= 1;
                }
            }
        };
        /**
         * Maintenance for all active Characters. Walking, grass maintenance, alive
         * checking, and quadrant maintenance are performed.
         *
         * @param FSP
         * @param characters   The Characters group of Things.
         */
        FullScreenPokemon.prototype.maintainCharacters = function (FSP, characters) {
            var character, i;
            for (i = 0; i < characters.length; i += 1) {
                character = characters[i];
                FSP.shiftCharacter(character);
                if (character.shouldWalk && !FSP.MenuGrapher.getActiveMenu()) {
                    character.onWalkingStart(character, character.direction);
                    character.shouldWalk = false;
                }
                if (character.grass) {
                    FSP.maintainCharacterGrass(FSP, character, character.grass);
                }
                if (!character.alive && !character.outerOk) {
                    FSP.arrayDeleteThing(character, characters, i);
                    i -= 1;
                    continue;
                }
                FSP.QuadsKeeper.determineThingQuadrants(character);
                FSP.ThingHitter.checkHitsForThing(character);
            }
        };
        /**
         * Maintenance for a Character visually in grass. The shadow is updated to
         * move or be deleted as needed.
         *
         * @param FSP
         * @param thing   A Character in grass.
         * @param other   Grass that thing is in.
         */
        FullScreenPokemon.prototype.maintainCharacterGrass = function (FSP, thing, other) {
            // If thing is no longer in grass, delete the shadow and stop
            if (!thing.FSP.isThingWithinGrass(thing, other)) {
                thing.FSP.killNormal(thing.shadow);
                thing.canvas.height = thing.height * thing.FSP.unitsize;
                thing.FSP.PixelDrawer.setThingSprite(thing);
                delete thing.shadow;
                delete thing.grass;
                return;
            }
            // Keep the shadow in sync with thing in position and visuals.
            thing.FSP.setLeft(thing.shadow, thing.left);
            thing.FSP.setTop(thing.shadow, thing.top);
            if (thing.shadow.className !== thing.className) {
                thing.FSP.setClass(thing.shadow, thing.className);
            }
        };
        /**
         * Maintenance for a Player. The screen is scrolled according to the global
         * MapScreener.scrollability.
         *
         * @param FSP
         * @param player   An in-game Player Thing.
         */
        FullScreenPokemon.prototype.maintainPlayer = function (FSP, player) {
            if (!player || !player.alive) {
                return;
            }
            switch (FSP.MapScreener.scrollability) {
                case Scrollability.Horizontal:
                    FSP.scrollWindow(FSP.getHorizontalScrollAmount(FSP));
                    return;
                case Scrollability.Vertical:
                    FSP.scrollWindow(0, FSP.getVerticalScrollAmount(FSP));
                    return;
                case Scrollability.Both:
                    FSP.scrollWindow(FSP.getHorizontalScrollAmount(FSP), FSP.getVerticalScrollAmount(FSP));
                    return;
                default:
                    return;
            }
        };
        /**
         * Determines how much to scroll horizontally during upkeep based
         * on player xvel and horizontal bordering.
         *
         * @param FSP
         * @returns How far to scroll horizontally.
         */
        FullScreenPokemon.prototype.getHorizontalScrollAmount = function (FSP) {
            if (!FSP.player.xvel) {
                return 0;
            }
            if (FSP.player.xvel > 0) {
                return FSP.player.bordering[1] ? 0 : FSP.player.xvel;
            }
            else {
                return FSP.player.bordering[3] ? 0 : FSP.player.xvel;
            }
        };
        /**
         * Determines how much to scroll vertically during upkeep based
         * on player yvel and vertical bordering.
         *
         * @param FSP
         * @returns How far to scroll vertically.
         */
        FullScreenPokemon.prototype.getVerticalScrollAmount = function (FSP) {
            if (!FSP.player.yvel) {
                return 0;
            }
            if (FSP.player.yvel > 0) {
                return FSP.player.bordering[2] ? 0 : FSP.player.yvel;
            }
            else {
                return FSP.player.bordering[0] ? 0 : FSP.player.yvel;
            }
        };
        /**
         * Starts the Player cycling if the current Area allows it.
         *
         * @param thing   A Player to start cycling.
         * @param area   The current Area.
         * @returns Whether the properties were changed.
         */
        FullScreenPokemon.prototype.startCycling = function (thing) {
            var area = this.AreaSpawner.getArea();
            if (!area.allowCycling) {
                return false;
            }
            thing.cycling = true;
            thing.speedOld = thing.speed;
            thing.speed = this.MathDecider.compute("cycleSpeed", thing);
            thing.FSP.addClass(thing, "cycling");
            thing.FSP.displayMessage(thing, "%%%%%%%PLAYER%%%%%%% got on the bicycle!");
            return true;
        };
        /**
         * Stops the Player cycling.
         *
         * @param thing   A Player to stop cycling.
         */
        FullScreenPokemon.prototype.stopCycling = function (thing) {
            thing.cycling = false;
            thing.speed = thing.speedOld;
            thing.FSP.removeClass(thing, "cycling");
            thing.FSP.TimeHandler.cancelClassCycle(thing, "cycling");
            thing.FSP.displayMessage(thing, "%%%%%%%PLAYER%%%%%%% got off the bicycle.");
        };
        /**
         * Toggles the Player's cycling status.
         *
         * @param thing   A Player to start or stop cycling.
         * @returns Whether the Player started cycling.
         */
        FullScreenPokemon.prototype.toggleCycling = function (thing) {
            if (thing.cycling) {
                thing.FSP.stopCycling(thing);
                return true;
            }
            else {
                return thing.FSP.startCycling(thing);
            }
        };
        /* General animations
        */
        /**
         * Snaps a moving Thing to a predictable grid position.
         *
         * @param thing   A Thing to snap the position of.
         */
        FullScreenPokemon.prototype.animateSnapToGrid = function (thing) {
            var grid = thing.FSP.unitsize * 8, x = (thing.FSP.MapScreener.left + thing.left) / grid, y = (thing.FSP.MapScreener.top + thing.top) / grid;
            thing.FSP.setLeft(thing, Math.round(x) * grid - thing.FSP.MapScreener.left);
            thing.FSP.setTop(thing, Math.round(y) * grid - thing.FSP.MapScreener.top);
        };
        /**
         * Freezes a Character to start a dialog.
         *
         * @param thing   A Character to freeze.
         */
        FullScreenPokemon.prototype.animatePlayerDialogFreeze = function (thing) {
            thing.FSP.animateCharacterPreventWalking(thing);
            thing.FSP.TimeHandler.cancelClassCycle(thing, "walking");
            if (thing.walkingFlipping) {
                thing.FSP.TimeHandler.cancelEvent(thing.walkingFlipping);
            }
        };
        /**
         * Gradually changes a numeric attribute over time.
         *
         * @param thing   A Thing whose attribute is to change.
         * @param attribute   The name of the attribute to change.
         * @param change   How much to change the attribute each tick.
         * @param goal   A final value for the attribute to stop at.
         * @param speed   How many ticks between changes.
         * @param onCompletion   A callback for when the attribute reaches the goal.
         * @returns The in-progress TimeEvent.
         */
        FullScreenPokemon.prototype.animateFadeAttribute = function (thing, attribute, change, goal, speed, onCompletion) {
            thing[attribute] += change;
            if (change > 0) {
                if (thing[attribute] >= goal) {
                    thing[attribute] = goal;
                    if (typeof onCompletion === "function") {
                        onCompletion(thing);
                    }
                    return;
                }
            }
            else {
                if (thing[attribute] <= goal) {
                    thing[attribute] = goal;
                    if (typeof onCompletion === "function") {
                        onCompletion(thing);
                    }
                    return;
                }
            }
            return thing.FSP.TimeHandler.addEvent(thing.FSP.animateFadeAttribute, speed, thing, attribute, change, goal, speed, onCompletion);
        };
        /**
         * Slides a Thing across the screen horizontally over time.
         *
         * @param thing   A Thing to slide across the screen.
         * @param change   How far to move each tick.
         * @param goal   A midX location to stop sliding at.
         * @param speed   How many ticks between movements.
         * @param onCompletion   A callback for when the Thing reaches the goal.
         * @returns The in-progress TimeEvent.
         */
        FullScreenPokemon.prototype.animateSlideHorizontal = function (thing, change, goal, speed, onCompletion) {
            thing.FSP.shiftHoriz(thing, change);
            if (change > 0) {
                if (thing.FSP.getMidX(thing) >= goal) {
                    thing.FSP.setMidX(thing, goal);
                    if (onCompletion) {
                        onCompletion(thing);
                    }
                    return;
                }
            }
            else {
                if (thing.FSP.getMidX(thing) <= goal) {
                    thing.FSP.setMidX(thing, goal);
                    if (onCompletion) {
                        onCompletion(thing);
                    }
                    return;
                }
            }
            thing.FSP.TimeHandler.addEvent(thing.FSP.animateSlideHorizontal, speed, thing, change, goal, speed, onCompletion);
        };
        /**
         * Slides a Thing across the screen vertically over time.
         *
         * @param thing   A Thing to slide across the screen.
         * @param change   How far to move each tick.
         * @param goal   A midY location to stop sliding at.
         * @param speed   How many ticks between movements.
         * @param onCompletion   A callback for when the Thing reaches the goal.
         * @returns The in-progress TimeEvent.
         */
        FullScreenPokemon.prototype.animateSlideVertical = function (thing, change, goal, speed, onCompletion) {
            thing.FSP.shiftVert(thing, change);
            if (change > 0) {
                if (thing.FSP.getMidY(thing) >= goal) {
                    thing.FSP.setMidY(thing, goal);
                    if (onCompletion) {
                        onCompletion(thing);
                    }
                    return;
                }
            }
            else {
                if (thing.FSP.getMidY(thing) <= goal) {
                    thing.FSP.setMidY(thing, goal);
                    if (onCompletion) {
                        onCompletion(thing);
                    }
                    return;
                }
            }
            thing.FSP.TimeHandler.addEvent(thing.FSP.animateSlideVertical, speed, thing, change, goal, speed, onCompletion);
        };
        /**
         * Freezes a Character in grass and calls startBattle.
         *
         * @param thing   A Character about to start a battle.
         * @param grass   Grass the Character is walking in.
         */
        FullScreenPokemon.prototype.animateGrassBattleStart = function (thing, grass) {
            var grassMap = thing.FSP.AreaSpawner.getMap(grass.mapName), grassArea = grassMap.areas[grass.areaName], options = grassArea.wildPokemon.grass, chosen = thing.FSP.chooseRandomWildPokemon(thing.FSP, options), chosenPokemon = thing.FSP.createPokemon(chosen);
            thing.FSP.removeClass(thing, "walking");
            if (thing.shadow) {
                thing.FSP.removeClass(thing.shadow, "walking");
            }
            thing.FSP.animateCharacterPreventWalking(thing);
            thing.FSP.startBattle({
                "opponent": {
                    "name": chosen.title,
                    "actors": [chosenPokemon],
                    "category": "Wild",
                    "sprite": chosen.title.join("") + "Front"
                }
            });
        };
        /**
         * Freezes a Character and starts a battle with an enemy.
         *
         * @param thing   A Character about to start a battle with other.
         * @param other   An enemy about to battle thing.
         */
        FullScreenPokemon.prototype.animateTrainerBattleStart = function (thing, other) {
            var battleName = other.battleName || other.title, battleSprite = other.battleSprite || battleName;
            thing.FSP.startBattle({
                "opponent": {
                    "name": battleName.split(""),
                    "sprite": battleSprite + "Front",
                    "category": "Trainer",
                    "hasActors": true,
                    "reward": other.reward,
                    "actors": other.actors.map(thing.FSP.createPokemon.bind(thing.FSP))
                },
                "textStart": ["", " wants to fight!"],
                "textDefeat": other.textDefeat,
                "textAfterBattle": other.textAfterBattle,
                "giftAfterBattle": other.giftAfterBattle,
                "badge": other.badge,
                "textVictory": other.textVictory,
                "nextCutscene": other.nextCutscene
            });
        };
        /**
         * Creates and positions a set of four Things around a point.
         *
         * @param FSP
         * @param x   The horizontal value of the point.
         * @param y   The vertical value of the point.
         * @param title   A title for each Thing to create.
         * @param settings   Additional settings for each Thing.
         * @param groupType   Which group to move the Things into, if any.
         * @returns The four created Things.
         */
        FullScreenPokemon.prototype.animateThingCorners = function (FSP, x, y, title, settings, groupType) {
            var things = [], i;
            for (i = 0; i < 4; i += 1) {
                things.push(FSP.addThing([title, settings]));
            }
            if (groupType) {
                for (i = 0; i < things.length; i += 1) {
                    FSP.GroupHolder.switchMemberGroup(things[i], things[i].groupType, groupType);
                }
            }
            FSP.setLeft(things[0], x);
            FSP.setLeft(things[1], x);
            FSP.setRight(things[2], x);
            FSP.setRight(things[3], x);
            FSP.setBottom(things[0], y);
            FSP.setBottom(things[3], y);
            FSP.setTop(things[1], y);
            FSP.setTop(things[2], y);
            FSP.flipHoriz(things[0]);
            FSP.flipHoriz(things[1]);
            FSP.flipVert(things[1]);
            FSP.flipVert(things[2]);
            return things;
        };
        /**
         * Moves a set of four Things away from a point.
         *
         * @param things   The four Things to move.
         * @param amount   How far to move each Thing horizontally and vertically.
         */
        FullScreenPokemon.prototype.animateExpandCorners = function (things, amount) {
            var FSP = things[0].FSP;
            FSP.shiftHoriz(things[0], amount);
            FSP.shiftHoriz(things[1], amount);
            FSP.shiftHoriz(things[2], -amount);
            FSP.shiftHoriz(things[3], -amount);
            FSP.shiftVert(things[0], -amount);
            FSP.shiftVert(things[1], amount);
            FSP.shiftVert(things[2], amount);
            FSP.shiftVert(things[3], -amount);
        };
        /**
         * Creates a small smoke animation from a point.
         *
         * @param FSP
         * @param x   The horizontal location of the point.
         * @param y   The vertical location of the point.
         * @param callback   A callback for when the animation is done.
         */
        FullScreenPokemon.prototype.animateSmokeSmall = function (FSP, x, y, callback) {
            var things = FSP.animateThingCorners(FSP, x, y, "SmokeSmall", undefined, "Text");
            FSP.TimeHandler.addEvent(things.forEach.bind(things), 7, FSP.killNormal);
            FSP.TimeHandler.addEvent(FSP.animateSmokeMedium, 7, FSP, x, y, callback);
        };
        /**
         * Creates a medium-sized smoke animation from a point.
         *
         * @param FSP
         * @param x   The horizontal location of the point.
         * @param y   The vertical location of the point.
         * @param callback   A callback for when the animation is done.
         */
        FullScreenPokemon.prototype.animateSmokeMedium = function (FSP, x, y, callback) {
            var things = FSP.animateThingCorners(FSP, x, y, "SmokeMedium", undefined, "Text");
            FSP.TimeHandler.addEvent(FSP.animateExpandCorners, 7, things, FSP.unitsize);
            FSP.TimeHandler.addEvent(things.forEach.bind(things), 14, FSP.killNormal);
            FSP.TimeHandler.addEvent(FSP.animateSmokeLarge, 14, FSP, x, y, callback);
        };
        /**
         * Creates a large smoke animation from a point.
         *
         * @param FSP
         * @param x   The horizontal location of the point.
         * @param y   The vertical location of the point.
         * @param callback   A callback for when the animation is done.
         */
        FullScreenPokemon.prototype.animateSmokeLarge = function (FSP, x, y, callback) {
            var things = FSP.animateThingCorners(FSP, x, y, "SmokeLarge", undefined, "Text");
            FSP.animateExpandCorners(things, FSP.unitsize * 2.5);
            FSP.TimeHandler.addEvent(FSP.animateExpandCorners, 7, things, FSP.unitsize * 2);
            FSP.TimeHandler.addEvent(things.forEach.bind(things), 21, FSP.killNormal);
            if (callback) {
                FSP.TimeHandler.addEvent(callback, 21);
            }
        };
        /**
         * Animates an exclamation mark above a Thing.
         *
         * @param thing   A Thing to show the exclamation over.
         * @param timeout   How long to keep the exclamation (by default, 140).
         * @param callback   A callback for when the exclamation is removed.
         * @returns The exclamation Thing.
         */
        FullScreenPokemon.prototype.animateExclamation = function (thing, timeout, callback) {
            if (timeout === void 0) { timeout = 140; }
            var exclamation = thing.FSP.addThing("Exclamation");
            timeout = timeout || 140;
            thing.FSP.setMidXObj(exclamation, thing);
            thing.FSP.setBottom(exclamation, thing.top);
            thing.FSP.TimeHandler.addEvent(thing.FSP.killNormal, timeout, exclamation);
            if (callback) {
                thing.FSP.TimeHandler.addEvent(callback, timeout);
            }
            return exclamation;
        };
        /**
         * Fades the screen out to a solid color.
         *
         * @param FSP
         * @param settings   Settings for the animation.
         * @returns The solid color Thing.
         */
        FullScreenPokemon.prototype.animateFadeToColor = function (FSP, settings) {
            if (settings === void 0) { settings = {}; }
            var color = settings.color || "White", callback = settings.callback, change = settings.change || .33, speed = settings.speed || 4, blank = FSP.ObjectMaker.make(color + "Square", {
                "width": FSP.MapScreener.width,
                "height": FSP.MapScreener.height,
                "opacity": 0
            });
            FSP.addThing(blank);
            FSP.animateFadeAttribute(blank, "opacity", change, 1, speed, function () {
                FSP.killNormal(blank);
                if (callback) {
                    callback.call(FSP, FSP);
                }
            });
            return blank;
        };
        /**
         * Places a solid color over the screen and fades it out.
         *
         * @param FSP
         * @param settings   Settings for the animation.
         * @returns The solid color Thing.
         */
        FullScreenPokemon.prototype.animateFadeFromColor = function (FSP, settings) {
            if (settings === void 0) { settings = {}; }
            var color = settings.color || "White", callback = settings.callback, change = settings.change || .33, speed = settings.speed || 4, blank = FSP.ObjectMaker.make(color + "Square", {
                "width": FSP.MapScreener.width,
                "height": FSP.MapScreener.height,
                "opacity": 1
            }), args = arguments;
            FSP.addThing(blank);
            FSP.animateFadeAttribute(blank, "opacity", -change, 0, speed, function () {
                FSP.killNormal(blank);
                if (callback) {
                    callback.apply(this, args);
                }
            });
            return blank;
        };
        /**
         * Animates a "flicker" effect on a Thing by repeatedly toggling its hidden
         * flag for a little while.
         *
         * @param thing   A Thing to flicker.
         * @param cleartime   How long to wait to stop the effect (by default, 49).
         * @param interval   How many steps between hidden toggles (by default, 2).
         * @param callback   A Function to called on the Thing when done flickering.
         * @returns The flickering time event.
         */
        FullScreenPokemon.prototype.animateFlicker = function (thing, cleartime, interval, callback) {
            if (cleartime === void 0) { cleartime = 49; }
            if (interval === void 0) { interval = 2; }
            var timeTotal = ((cleartime * interval) | 0) + 1;
            thing.flickering = true;
            thing.FSP.TimeHandler.addEventInterval(function () {
                thing.hidden = !thing.hidden;
                if (!thing.hidden) {
                    thing.FSP.PixelDrawer.setThingSprite(thing);
                }
            }, interval | 0, cleartime | 0);
            return thing.FSP.TimeHandler.addEvent(function () {
                thing.flickering = thing.hidden = false;
                thing.FSP.PixelDrawer.setThingSprite(thing);
                if (callback) {
                    callback(thing);
                }
            }, timeTotal);
        };
        /**
         * Shakes all Things on the screen back and forth for a little bit.
         *
         *
         * @param FSP
         * @param dx   How far to shift horizontally (by default, 0).
         * @param dy   How far to shift horizontally (by default, 0).
         * @param cleartime   How long until the screen is done shaking.
         * @param interval   How many game upkeeps between movements.
         * @returns The shaking time event.
         */
        FullScreenPokemon.prototype.animateScreenShake = function (FSP, dx, dy, cleartime, interval, callback) {
            if (dx === void 0) { dx = 0; }
            if (dy === void 0) { dy = 0; }
            if (cleartime === void 0) { cleartime = 8; }
            if (interval === void 0) { interval = 8; }
            var intervalEnd = (interval / 2) | 0;
            FSP.TimeHandler.addEventInterval(function () {
                FSP.GroupHolder.callOnAll(FSP, FSP.shiftHoriz, dx);
                FSP.GroupHolder.callOnAll(FSP, FSP.shiftVert, dy);
            }, 1, cleartime * interval);
            return FSP.TimeHandler.addEvent(function () {
                dx *= -1;
                dy *= -1;
                FSP.TimeHandler.addEventInterval(function () {
                    dx *= -1;
                    dy *= -1;
                }, interval, cleartime);
                if (callback) {
                    FSP.TimeHandler.addEvent(callback, interval * cleartime, FSP);
                }
            }, intervalEnd);
        };
        /* Character movement animations
        */
        /**
         * Sets a Character's xvel and yvel based on its speed and direction, and marks
         * its destination endpoint.
         *
         * @param thing   A moving Character.
         * @param distance   How far the Character is moving.
         */
        FullScreenPokemon.prototype.animateCharacterSetDistanceVelocity = function (thing, distance) {
            thing.distance = distance;
            switch (thing.direction) {
                case 0:
                    thing.xvel = 0;
                    thing.yvel = -thing.speed;
                    thing.destination = thing.top - distance;
                    break;
                case 1:
                    thing.xvel = thing.speed;
                    thing.yvel = 0;
                    thing.destination = thing.right + distance;
                    break;
                case 2:
                    thing.xvel = 0;
                    thing.yvel = thing.speed;
                    thing.destination = thing.bottom + distance;
                    break;
                case 3:
                    thing.xvel = -thing.speed;
                    thing.yvel = 0;
                    thing.destination = thing.left - distance;
                    break;
                default:
                    throw new Error("Unknown direction: " + thing.direction + ".");
            }
        };
        /**
         * Starts a Character's walking cycle regardless of the direction.
         *
         * @param thing   A Character to start walking.
         * @param direction   What direction the Character should turn to face.
         * @param onStop   A queue of commands as alternating directions and distances.
         */
        FullScreenPokemon.prototype.animateCharacterStartWalkingCycle = function (thing, direction, onStop) {
            if (onStop.length === 0) {
                return;
            }
            // If the first queued command is a 0 distance, walking might be complete
            if (onStop[0] === 0) {
                // More commands indicates walking isn't done, and to continue turning/walking
                if (onStop.length > 1) {
                    if (typeof onStop[1] === "function") {
                        onStop[1](thing);
                        return;
                    }
                    thing.FSP.animateCharacterSetDirection(thing, FullScreenPokemon_1.DirectionAliases[onStop[1]]);
                    thing.FSP.animateCharacterStartWalkingCycle(thing, FullScreenPokemon_1.DirectionAliases[onStop[1]], onStop.slice(2));
                }
                return;
            }
            if (thing.follower) {
                thing.walkingCommands.push(direction);
            }
            thing.FSP.animateCharacterStartWalking(thing, direction, onStop);
            thing.FSP.shiftBoth(thing, -thing.xvel, -thing.yvel);
        };
        /**
         * Starts a Character walking in the given direction as part of a walking cycle.
         *
         * @param thing   The Character to start walking.
         * @param direction   What direction to walk in (by default, up).
         * @param onStop   A queue of commands as alternating directions and distances.
         */
        FullScreenPokemon.prototype.animateCharacterStartWalking = function (thing, direction, onStop) {
            if (direction === void 0) { direction = Direction.Top; }
            var repeats = thing.FSP.getCharacterWalkingInterval(thing), distance = repeats * thing.speed;
            thing.walking = true;
            thing.FSP.animateCharacterSetDirection(thing, direction);
            thing.FSP.animateCharacterSetDistanceVelocity(thing, distance);
            if (!thing.cycles || !thing.cycles.walking) {
                thing.FSP.TimeHandler.addClassCycle(thing, ["walking", "standing"], "walking", repeats / 2);
            }
            if (!thing.walkingFlipping) {
                thing.walkingFlipping = thing.FSP.TimeHandler.addEventInterval(thing.FSP.animateSwitchFlipOnDirection, repeats, Infinity, thing);
            }
            if (thing.sight) {
                thing.sightDetector.nocollide = true;
            }
            thing.FSP.TimeHandler.addEventInterval(thing.onWalkingStop, repeats, Infinity, thing, onStop);
            thing.FSP.shiftBoth(thing, thing.xvel, thing.yvel);
        };
        /**
         * Starts a roaming Character walking in a random direction, determined
         * by the allowed directions it may use (that aren't blocked).
         *
         * @param thing   A roaming Character.
         */
        FullScreenPokemon.prototype.animateCharacterStartWalkingRandom = function (thing) {
            var totalAllowed = 0, direction, i;
            for (i = 0; i < 4; i += 1) {
                if (!thing.bordering[i]) {
                    totalAllowed += 1;
                }
            }
            if (totalAllowed === 0) {
                return;
            }
            direction = thing.FSP.NumberMaker.randomInt(totalAllowed);
            for (i = 0; i <= direction; i += 1) {
                if (thing.bordering[i]) {
                    direction += 1;
                }
            }
            if (thing.roamingDirections.indexOf(direction) === -1) {
                thing.FSP.animateCharacterSetDirection(thing, direction);
            }
            else {
                thing.FSP.animateCharacterStartWalking(thing, direction);
            }
        };
        /**
         * Continues a Character's walking cycle after taking a step. If .turning
         * is provided, the Character turns. If a Player is provided, its keys
         * and .canKeyWalking are respected.
         *
         * @param thing   A Character mid-step.
         */
        FullScreenPokemon.prototype.animateCharacterRepeatWalking = function (thing) {
            if (typeof thing.turning !== "undefined") {
                if (!thing.player || !thing.keys[thing.turning]) {
                    thing.FSP.animateCharacterSetDirection(thing, thing.turning);
                    thing.turning = undefined;
                    return;
                }
                thing.turning = undefined;
            }
            if (thing.player) {
                thing.canKeyWalking = false;
            }
            thing.FSP.animateCharacterStartWalking(thing, thing.direction);
        };
        /**
         * Reacts to a Character finishing a step and either stops all walking or moves to
         * the next action in the onStop queue.
         *
         * @param thing   A Character finishing a walking step.
         * @param onStop   A queue of commands as alternating directions and distances.
         * @returns True, unless the next onStop is a Function to return the result of.
         */
        FullScreenPokemon.prototype.animateCharacterStopWalking = function (thing, onStop) {
            thing.xvel = 0;
            thing.yvel = 0;
            thing.walking = false;
            thing.FSP.removeClass(thing, "walking");
            thing.FSP.TimeHandler.cancelClassCycle(thing, "walking");
            if (thing.walkingFlipping) {
                thing.FSP.TimeHandler.cancelEvent(thing.walkingFlipping);
                thing.walkingFlipping = undefined;
            }
            thing.FSP.animateSnapToGrid(thing);
            if (thing.sight) {
                thing.sightDetector.nocollide = false;
                thing.FSP.animatePositionSightDetector(thing);
            }
            if (!onStop) {
                return true;
            }
            switch (onStop.constructor) {
                case Number:
                    thing.FSP.animateCharacterRepeatWalking(thing);
                    break;
                case Array:
                    if (onStop[0] > 0) {
                        onStop[0] = onStop[0] - 1;
                        thing.FSP.animateCharacterStartWalkingCycle(thing, thing.direction, onStop);
                    }
                    else if (onStop.length === 0) {
                        break;
                    }
                    else {
                        if (onStop[1] instanceof Function) {
                            return onStop[1](thing);
                        }
                        thing.FSP.animateCharacterStartWalkingCycle(thing, FullScreenPokemon_1.DirectionAliases[onStop[1]], onStop.slice(2));
                    }
                    break;
                case Function:
                    return onStop(thing);
                default:
                    throw new Error("Unknown onStop: " + onStop + ".");
            }
            return true;
        };
        /**
         * Animates a Player to stop walking, which is the same logic for a normal
         * Character as well as MenuGrapher and following checks.
         *
         * @param thing   A Player to stop walking.
         * @param onStop   A queue of commands as alternating directions and distances.
         * @returns True, unless the next onStop is a Function to return the result of.
         */
        FullScreenPokemon.prototype.animatePlayerStopWalking = function (thing, onStop) {
            if (thing.FSP.checkPlayerGrassBattle(thing)) {
                return false;
            }
            if (thing.following) {
                return thing.FSP.animateCharacterStopWalking(thing, onStop);
            }
            if (!thing.FSP.MenuGrapher.getActiveMenu()
                && thing.keys[thing.direction]) {
                thing.FSP.animateCharacterSetDistanceVelocity(thing, thing.distance);
                return false;
            }
            else {
                if (typeof thing.nextDirection !== "undefined") {
                    if (thing.nextDirection !== thing.direction && !thing.ledge) {
                        thing.FSP.setPlayerDirection(thing, thing.nextDirection);
                    }
                    delete thing.nextDirection;
                }
            }
            thing.canKeyWalking = true;
            return thing.FSP.animateCharacterStopWalking(thing, onStop);
        };
        /**
         * Animates a Character to no longer be able to walk.
         *
         * @param thing   A Character that shouldn't be able to walk.
         */
        FullScreenPokemon.prototype.animateCharacterPreventWalking = function (thing) {
            thing.shouldWalk = false;
            thing.xvel = thing.yvel = 0;
            if (thing.player) {
                thing.keys = thing.getKeys();
            }
            thing.FSP.MapScreener.blockInputs = true;
        };
        /**
         * Sets a Thing facing a particular direction.
         *
         * @param thing   An in-game Thing.
         * @param direction   A direction for thing to face.
         * @todo Add more logic here for better performance.
         */
        FullScreenPokemon.prototype.animateCharacterSetDirection = function (thing, direction) {
            thing.direction = direction;
            thing.FSP.unflipHoriz(thing);
            thing.FSP.removeClasses(thing, FullScreenPokemon_1.DirectionClasses[Direction.Top], FullScreenPokemon_1.DirectionClasses[Direction.Right], FullScreenPokemon_1.DirectionClasses[Direction.Bottom], FullScreenPokemon_1.DirectionClasses[Direction.Left]);
            thing.FSP.addClass(thing, FullScreenPokemon_1.DirectionClasses[direction]);
            if (direction === Direction.Right) {
                thing.FSP.flipHoriz(thing);
                thing.FSP.addClass(thing, FullScreenPokemon_1.DirectionClasses[Direction.Left]);
            }
        };
        /**
         * Sets a Thing facing a random direction.
         *
         * @param thing   An in-game Thing.
         */
        FullScreenPokemon.prototype.animateCharacterSetDirectionRandom = function (thing) {
            thing.FSP.animateCharacterSetDirection(thing, thing.FSP.NumberMaker.randomIntWithin(0, 3));
        };
        /**
         * Flips or unflips a Character if its direction is vertical.
         *
         * @param thing   A Character to flip or unflip.
         */
        FullScreenPokemon.prototype.animateSwitchFlipOnDirection = function (thing) {
            if (thing.direction % 2 !== 0) {
                return;
            }
            if (thing.flipHoriz) {
                thing.FSP.unflipHoriz(thing);
            }
            else {
                thing.FSP.flipHoriz(thing);
            }
        };
        /**
         * Positions a Character's detector in front of it as its sight.
         *
         * @param thing   A Character that should be able to see.
         */
        FullScreenPokemon.prototype.animatePositionSightDetector = function (thing) {
            var detector = thing.sightDetector, direction = thing.direction, sight = Number(thing.sight);
            if (detector.direction !== direction) {
                if (thing.direction % 2 === 0) {
                    thing.FSP.setWidth(detector, thing.width);
                    thing.FSP.setHeight(detector, sight * 8);
                }
                else {
                    thing.FSP.setWidth(detector, sight * 8);
                    thing.FSP.setHeight(detector, thing.height);
                }
                detector.direction = direction;
            }
            switch (direction) {
                case 0:
                    thing.FSP.setBottom(detector, thing.top);
                    thing.FSP.setMidXObj(detector, thing);
                    break;
                case 1:
                    thing.FSP.setLeft(detector, thing.right);
                    thing.FSP.setMidYObj(detector, thing);
                    break;
                case 2:
                    thing.FSP.setTop(detector, thing.bottom);
                    thing.FSP.setMidXObj(detector, thing);
                    break;
                case 3:
                    thing.FSP.setRight(detector, thing.left);
                    thing.FSP.setMidYObj(detector, thing);
                    break;
                default:
                    throw new Error("Unknown direction: " + direction + ".");
            }
        };
        /**
         * Animates the various logic pieces for finishing a dialog, such as pushes,
         * gifts, options, and battle starting or disabling.
         *
         * @param thing   A Player that's finished talking to other.
         * @param other   A Character that thing has finished talking to.
         */
        FullScreenPokemon.prototype.animateCharacterDialogFinish = function (thing, other) {
            var onStop;
            if (other.pushSteps) {
                onStop = other.pushSteps;
            }
            thing.talking = false;
            other.talking = false;
            thing.canKeyWalking = true;
            if (other.directionPreferred) {
                thing.FSP.animateCharacterSetDirection(other, other.directionPreferred);
            }
            if (other.transport) {
                other.active = true;
                thing.FSP.activateTransporter(thing, other);
                return;
            }
            if (typeof other.pushDirection !== "undefined") {
                thing.FSP.animateCharacterStartWalkingCycle(thing, other.pushDirection, onStop);
            }
            if (other.gift) {
                thing.FSP.MenuGrapher.createMenu("GeneralText", {
                    "deleteOnFinish": true
                });
                thing.FSP.MenuGrapher.addMenuDialog("GeneralText", "%%%%%%%PLAYER%%%%%%% got " + other.gift.toUpperCase() + "!", thing.FSP.animateCharacterDialogFinish.bind(thing.FSP, thing, other));
                thing.FSP.MenuGrapher.setActiveMenu("GeneralText");
                thing.FSP.addItemToBag(thing.FSP, other.gift);
                other.gift = undefined;
                thing.FSP.StateHolder.addChange(other.id, "gift", undefined);
                return;
            }
            if (other.dialogNext) {
                other.dialog = other.dialogNext;
                other.dialogNext = undefined;
                thing.FSP.StateHolder.addChange(other.id, "dialog", other.dialog);
                thing.FSP.StateHolder.addChange(other.id, "dialogNext", undefined);
            }
            if (other.dialogOptions) {
                thing.FSP.animateCharacterDialogOptions(thing, other, other.dialogOptions);
            }
            else if (other.trainer) {
                thing.FSP.animateTrainerBattleStart(thing, other);
            }
            if (other.trainer) {
                other.trainer = false;
                thing.FSP.StateHolder.addChange(other.id, "trainer", false);
                if (other.sight) {
                    other.sight = undefined;
                    thing.FSP.StateHolder.addChange(other.id, "sight", undefined);
                }
            }
        };
        /**
         * Displays a yes/no options menu for after a dialog has completed.
         *
         *
         * @param thing   A Player that's finished talking to other.
         * @param other   A Character that thing has finished talking to.
         * @param dialog   The dialog settings that just finished.
         */
        FullScreenPokemon.prototype.animateCharacterDialogOptions = function (thing, other, dialog) {
            var options = dialog.options, generateCallback = function (dialog) {
                var callback, words;
                if (!dialog) {
                    return undefined;
                }
                if (dialog.constructor === Object && dialog.options) {
                    words = dialog.words;
                    callback = thing.FSP.animateCharacterDialogOptions.bind(thing.FSP, thing, other, dialog);
                }
                else {
                    words = dialog.words || dialog;
                    if (dialog.cutscene) {
                        callback = thing.FSP.ScenePlayer.bindCutscene(dialog.cutscene, {
                            "player": thing,
                            "tirggerer": other
                        });
                    }
                }
                return function () {
                    thing.FSP.MenuGrapher.deleteMenu("Yes/No");
                    thing.FSP.MenuGrapher.createMenu("GeneralText", {});
                    thing.FSP.MenuGrapher.addMenuDialog("GeneralText", words, callback);
                    thing.FSP.MenuGrapher.setActiveMenu("GeneralText");
                };
            };
            console.warn("DialogOptions assumes type = Yes/No for now...");
            thing.FSP.MenuGrapher.createMenu("Yes/No", {
                "position": {
                    "offset": {
                        "left": 28
                    }
                }
            });
            thing.FSP.MenuGrapher.addMenuList("Yes/No", {
                "options": [
                    {
                        "text": "YES",
                        "callback": generateCallback(options.Yes)
                    }, {
                        "text": "NO",
                        "callback": generateCallback(options.No)
                    }]
            });
            thing.FSP.MenuGrapher.setActiveMenu("Yes/No");
        };
        /**
         * Starts a Character walking behind another Character. The leader is given a
         * .walkingCommands queue of recent steps that the follower will mimic.
         *
         * @param thing   The following Character.
         * @param other   The leading Character.
         */
        FullScreenPokemon.prototype.animateCharacterFollow = function (thing, other) {
            var direction = thing.FSP.getDirectionBordering(thing, other);
            thing.nocollide = true;
            if (thing.player) {
                thing.allowDirectionAsKeys = true;
            }
            thing.following = other;
            other.follower = thing;
            thing.speedOld = thing.speed;
            thing.speed = other.speed;
            other.walkingCommands = [direction];
            thing.FSP.animateCharacterSetDirection(thing, direction);
            switch (direction) {
                case 0:
                    thing.FSP.setTop(thing, other.bottom);
                    break;
                case 1:
                    thing.FSP.setRight(thing, other.left);
                    break;
                case 2:
                    thing.FSP.setBottom(thing, other.top);
                    break;
                case 3:
                    thing.FSP.setLeft(thing, other.right);
                    break;
                default:
                    break;
            }
            // Manually start the walking process without giving a 0 onStop,
            // so that it continues smoothly in the walking interval
            thing.FSP.animateCharacterStartWalking(thing, direction);
            other.walkingCommands.shift();
            thing.followingLoop = thing.FSP.TimeHandler.addEventInterval(thing.FSP.animateCharacterFollowContinue, thing.FSP.getCharacterWalkingInterval(thing), Infinity, thing, other);
        };
        /**
         * Continuation helper for a following cycle. The next walking command is
         * played, if it exists.
         *
         * @param thing   The following Character.
         * @param other   The leading Character.
         */
        FullScreenPokemon.prototype.animateCharacterFollowContinue = function (thing, other) {
            if (other.walkingCommands.length === 0) {
                return;
            }
            var direction = other.walkingCommands.shift();
            thing.FSP.animateCharacterStartWalking(thing, direction, 0);
        };
        /**
         * Animates a Character to stop having a follower.
         *
         * @param thing   The leading Character.
         * @returns True, to stop TimeHandlr cycles.
         */
        FullScreenPokemon.prototype.animateCharacterFollowStop = function (thing) {
            var other = thing.following;
            if (!other) {
                return true;
            }
            thing.nocollide = false;
            delete thing.following;
            delete other.follower;
            thing.FSP.animateCharacterStopWalking(thing);
            thing.FSP.TimeHandler.cancelEvent(thing.followingLoop);
            return true;
        };
        /**
         * Determines how rapidly a Character should walk, as a function of
         * unitsize and its speed.
         *
         * @param thing   A walking Character.
         * @returns How rapidly thing should walk.
         */
        FullScreenPokemon.prototype.getCharacterWalkingInterval = function (thing) {
            return Math.round(8 * thing.FSP.unitsize / thing.speed);
        };
        /**
         * Animates a Character to hop over a ledge.
         *
         * @param thing   A walking Character.
         * @param other   A ledge for thing to hop over.
         */
        FullScreenPokemon.prototype.animateCharacterHopLedge = function (thing, other) {
            var shadow = thing.FSP.addThing("Shadow"), dy = -thing.FSP.unitsize, speed = 2, steps = 14, changed = 0;
            thing.shadow = shadow;
            thing.ledge = other;
            // Center the shadow below the Thing
            thing.FSP.setMidXObj(shadow, thing);
            thing.FSP.setBottom(shadow, thing.bottom);
            // Continuously ensure The Thing still moves off the ledge if not walking
            thing.FSP.TimeHandler.addEventInterval(function () {
                if (thing.walking) {
                    return false;
                }
                thing.FSP.animateCharacterSetDistanceVelocity(thing, thing.distance);
                return true;
            }, 1, steps * speed - 1);
            // Keep the shadow below the Thing, and move the Thing's offsetY
            thing.FSP.TimeHandler.addEventInterval(function () {
                thing.FSP.setBottom(shadow, thing.bottom);
                if (changed % speed === 0) {
                    thing.offsetY += dy;
                }
                changed += 1;
            }, 1, steps * speed);
            // Inverse the Thing's offsetY changes halfway through the hop
            thing.FSP.TimeHandler.addEvent(function () {
                dy *= -1;
            }, speed * (steps / 2) | 0);
            // Delete the shadow after the jump is done
            thing.FSP.TimeHandler.addEvent(function () {
                delete thing.ledge;
                thing.FSP.killNormal(shadow);
                if (!thing.walking) {
                    thing.FSP.animateCharacterStopWalking(thing);
                }
            }, steps * speed);
        };
        /* Collision detection
        */
        /**
         * Function generator for the generic canThingCollide checker. This is used
         * repeatedly by ThingHittr to generate separately optimized Functions for
         * different Thing types.
         *
         * @returns A Function that generates a canThingCollide checker.
         */
        FullScreenPokemon.prototype.generateCanThingCollide = function () {
            /**
             * Generic checker for canCollide. This just returns if the Thing is alive.
             *
             * @param thing
             * @returns Whether the thing can collide.
             */
            return function canThingCollide(thing) {
                return thing.alive;
            };
        };
        /**
         * Function generator for the generic isCharacterTouchingCharacter checker.
         * This is used repeatedly by ThingHittr to generate separately optimized
         * Functions for different Thing types.
         *
         * @returns A Function that generates isCharacterTouchingCharacter.
         */
        FullScreenPokemon.prototype.generateIsCharacterTouchingCharacter = function () {
            /**
             * Generic checker for whether two characters are touching each other.
             * This checks to see if either has the nocollide flag, or if they're
             * overlapping, respecting tolerances.
             *
             * @param thing
             * @param other
             * @returns Whether thing is touching other.
             */
            return function isCharacterTouchingCharacter(thing, other) {
                // if (other.xvel || other.yvel) {
                //     // check destination...
                // }
                return (!thing.nocollide && !other.nocollide
                    && thing.right >= (other.left + other.tolLeft)
                    && thing.left <= (other.right - other.tolRight)
                    && thing.bottom >= (other.top + other.tolTop)
                    && thing.top <= (other.bottom - other.tolBottom));
            };
        };
        /**
         * Function generator for the generic isCharacterTouchingSolid checker. This
         * is used repeatedly by ThingHittr to generate separately optimized
         * Functions for different Thing types.
         *
         * @returns A Function that generates isCharacterTouchingSolid.
         */
        FullScreenPokemon.prototype.generateIsCharacterTouchingSolid = function () {
            /**
             * Generic checker for whether a character is touching a solid. The
             * hidden, collideHidden, and nocollidesolid flags are most relevant.
             *
             * @param thing
             * @param other
             * @returns Whether thing is touching other.
             */
            return function isCharacterTouchingSolid(thing, other) {
                return (!thing.nocollide && !other.nocollide
                    && thing.right >= (other.left + other.tolLeft)
                    && thing.left <= (other.right - other.tolRight)
                    && thing.bottom >= (other.top + other.tolTop)
                    && thing.top <= (other.bottom - other.tolBottom));
            };
        };
        /**
         * Function generator for the generic hitCharacterThing callback. This is
         * used repeatedly by ThingHittr to generate separately optimized Functions
         * for different Thing types.
         *
         * @returns A Function that generates hitCharacterThing.
         */
        FullScreenPokemon.prototype.generateHitCharacterThing = function () {
            /**
             * Generic callback for when a Character touches a Thing. Other may have a
             * .collide to override with, but normally this just sets thing's position.
             *
             * @param thing
             * @param other
             * @returns Whether thing is hitting other.
             */
            return function hitCharacterThing(thing, other) {
                // If either Thing is the player, it should be the first
                if (other.player && !thing.player) {
                    _a = [other, thing], thing = _a[0], other = _a[1];
                }
                // The other's collide may return true to cancel overlapping checks
                if (other.collide && other.collide(thing, other)) {
                    return;
                }
                // Both the thing and other should know they're bordering each other
                // If other is a large solid, this will be irreleveant, so it's ok
                // that multiple borderings will be replaced by the most recent
                switch (thing.FSP.getDirectionBordering(thing, other)) {
                    case Direction.Top:
                        if (thing.left !== other.right - other.tolRight && thing.right !== other.left + other.tolLeft) {
                            thing.FSP.setThingBordering(thing, other, Direction.Top);
                            thing.FSP.setThingBordering(other, thing, Direction.Bottom);
                            thing.FSP.setTop(thing, other.bottom - other.tolBottom);
                        }
                        break;
                    case Direction.Right:
                        if (thing.top !== other.bottom - other.tolBottom && thing.bottom !== other.top + other.tolTop) {
                            thing.FSP.setThingBordering(thing, other, Direction.Right);
                            thing.FSP.setThingBordering(other, thing, Direction.Left);
                            thing.FSP.setRight(thing, other.left + other.tolLeft);
                        }
                        break;
                    case Direction.Bottom:
                        if (thing.left !== other.right - other.tolRight && thing.right !== other.left + other.tolLeft) {
                            thing.FSP.setThingBordering(thing, other, Direction.Bottom);
                            thing.FSP.setThingBordering(other, thing, Direction.Top);
                            thing.FSP.setBottom(thing, other.top + other.tolTop);
                        }
                        break;
                    case Direction.Left:
                        if (thing.top !== other.bottom - other.tolBottom && thing.bottom !== other.top + other.tolTop) {
                            thing.FSP.setThingBordering(thing, other, Direction.Left);
                            thing.FSP.setThingBordering(other, thing, Direction.Right);
                            thing.FSP.setLeft(thing, other.right - other.tolRight);
                        }
                        break;
                    default:
                        break;
                }
                var _a;
            };
        };
        /**
         * Marks other as being a border of thing in the given direction, respecting borderPrimary.
         *
         * @param thing   A Thing whose borders are being checked.
         * @param other   A new border for thing.
         * @param direction   The direction border being changed.
         */
        FullScreenPokemon.prototype.setThingBordering = function (thing, other, direction) {
            if (thing.bordering[direction] && thing.bordering[direction].borderPrimary && !other.borderPrimary) {
                return;
            }
            thing.bordering[direction] = other;
        };
        /**
         * Collision callback for a Character and a CollisionDetector. Only Players may
         * trigger the detector, which has to be active to do anything.
         *
         * @param thing   A Character triggering other.
         * @param other   A Detector triggered by thing.
         * @returns Whether to override normal positioning logic in hitCharacterThing.
         */
        FullScreenPokemon.prototype.collideCollisionDetector = function (thing, other) {
            if (!thing.player) {
                return false;
            }
            if (other.active) {
                if ((!other.requireOverlap && !thing.walking)
                    || thing.FSP.isThingWithinOther(thing, other)) {
                    if (typeof other.requireDirection !== "undefined"
                        && !thing.keys[other.requireDirection]
                        && !thing.allowDirectionAsKeys
                        && thing.direction !== other.requireDirection) {
                        return false;
                    }
                    if (other.singleUse) {
                        other.active = false;
                    }
                    other.activate(thing, other);
                }
                return true;
            }
            // If the thing is moving towards the triggerer, it's now active
            if (thing.direction === thing.FSP.getDirectionBordering(thing, other)) {
                other.active = true;
                return true;
            }
        };
        /**
         * Collision callback for a Player and a dialog-containing Character. The
         * dialog is started if it exists, as with a cutscene from other.
         *
         * @param thing   A Player triggering other.
         * @param other   A Character with dialog triggered by thing.
         */
        FullScreenPokemon.prototype.collideCharacterDialog = function (thing, other) {
            var dialog = other.dialog, direction;
            if (other.cutscene) {
                thing.FSP.ScenePlayer.startCutscene(other.cutscene, {
                    "thing": thing,
                    "triggerer": other
                });
            }
            if (!dialog) {
                return;
            }
            direction = thing.FSP.getDirectionBetween(other, thing);
            if (other.dialogDirections) {
                dialog = dialog[direction];
                if (!dialog) {
                    return;
                }
            }
            thing.talking = true;
            other.talking = true;
            thing.canKeyWalking = false;
            if (!thing.FSP.MenuGrapher.getActiveMenu()) {
                thing.FSP.MenuGrapher.createMenu("GeneralText", {
                    "deleteOnFinish": !other.dialogOptions
                });
                thing.FSP.MenuGrapher.setActiveMenu("GeneralText");
                thing.FSP.MenuGrapher.addMenuDialog("GeneralText", dialog, thing.FSP.animateCharacterDialogFinish.bind(thing.FSP, thing, other));
            }
            if (other.switchDirectionOnDialog) {
                thing.FSP.animateCharacterSetDirection(other, direction);
            }
        };
        /**
         * Collision callback for a Player and a Pokeball it's interacting with.
         *
         * @param thing   A Player interacting with other.
         * @param other   A Pokeball being interacted with by thing.
         */
        FullScreenPokemon.prototype.collidePokeball = function (thing, other) {
            switch (other.action) {
                case "item":
                    thing.FSP.MenuGrapher.createMenu("GeneralText");
                    thing.FSP.MenuGrapher.addMenuDialog("GeneralText", [
                        "%%%%%%%PLAYER%%%%%%% found " + other.item + "!"
                    ], function () {
                        thing.FSP.MenuGrapher.deleteActiveMenu();
                        thing.FSP.killNormal(other);
                        thing.FSP.StateHolder.addChange(other.id, "alive", false);
                    });
                    thing.FSP.MenuGrapher.setActiveMenu("GeneralText");
                    thing.FSP.addItemToBag(thing.FSP, other.item, other.amount);
                    break;
                case "cutscene":
                    thing.FSP.ScenePlayer.startCutscene(other.cutscene, {
                        "player": thing,
                        "triggerer": other
                    });
                    if (other.routine) {
                        thing.FSP.ScenePlayer.playRoutine(other.routine);
                    }
                    break;
                case "pokedex":
                    thing.FSP.openPokedexListing(other.pokemon);
                    break;
                case "dialog":
                    thing.FSP.MenuGrapher.createMenu("GeneralText");
                    thing.FSP.MenuGrapher.addMenuDialog("GeneralText", other.dialog);
                    thing.FSP.MenuGrapher.setActiveMenu("GeneralText");
                    break;
                case "yes/no":
                    thing.FSP.MenuGrapher.createMenu("Yes/No", {
                        "killOnB": ["GeneralText"]
                    });
                    thing.FSP.MenuGrapher.addMenuList("Yes/No", {
                        "options": [
                            {
                                "text": "YES",
                                "callback": console.log.bind(console, "What do, yes?")
                            }, {
                                "text": "NO",
                                "callback": console.log.bind(console, "What do, no?")
                            }]
                    });
                    thing.FSP.MenuGrapher.setActiveMenu("Yes/No");
                    break;
                default:
                    throw new Error("Unknown Pokeball action: " + other.action + ".");
            }
        };
        /**
         * Marks a Character as being visually within grass.
         *
         * @param thing   A Character within grass.
         * @param other   The specific Grass that thing is within.
         */
        FullScreenPokemon.prototype.collideCharacterGrass = function (thing, other) {
            if (thing.grass || !thing.FSP.isThingWithinGrass(thing, other)) {
                return true;
            }
            thing.grass = other;
            thing.heightOld = thing.height;
            // Todo: Find a better way than manually setting canvas height?
            thing.canvas.height = thing.heightGrass * thing.FSP.unitsize;
            thing.FSP.PixelDrawer.setThingSprite(thing);
            thing.shadow = thing.FSP.ObjectMaker.make(thing.title, {
                "nocollide": true,
                "id": thing.id + " shadow"
            });
            if (thing.shadow.className !== thing.className) {
                thing.FSP.setClass(thing.shadow, thing.className);
            }
            thing.FSP.addThing(thing.shadow, thing.left, thing.top);
            // Todo: is the arrayToEnd call necessary?
            thing.FSP.GroupHolder.switchMemberGroup(thing.shadow, thing.shadow.groupType, "Terrain");
            thing.FSP.arrayToEnd(thing.shadow, thing.FSP.GroupHolder.getGroup("Terrain"));
            return true;
        };
        /**
         * Collision callback for a Character and a Ledge. If possible, the Character
         * is animated to start hopping over the Ledge.
         *
         * @param thing   A Character walking to other.
         * @param other   A Ledge walked to by thing.
         */
        FullScreenPokemon.prototype.collideLedge = function (thing, other) {
            if (thing.ledge || !thing.walking) {
                return true;
            }
            if (thing.direction !== other.direction) {
                return false;
            }
            if (thing.direction % 2 === 0) {
                if (thing.left === other.right || thing.right === other.left) {
                    return true;
                }
            }
            else {
                if (thing.top === other.bottom || thing.bottom === other.top) {
                    return true;
                }
            }
            thing.FSP.animateCharacterHopLedge(thing, other);
            return true;
        };
        /* Death
        */
        /**
         * Standard Function to kill a Thing, which means marking it as dead and
         * clearing its numquads, resting, movement, and cycles. It will later be
         * removed by its maintain* Function.
         *
         * @param thing   A Thing to kill.
         */
        FullScreenPokemon.prototype.killNormal = function (thing) {
            if (!thing) {
                return;
            }
            thing.nocollide = thing.hidden = thing.dead = true;
            thing.alive = false;
            thing.numquads = 0;
            thing.movement = undefined;
            if (thing.FSP) {
                thing.FSP.TimeHandler.cancelAllCycles(thing);
                thing.FSP.ModAttacher.fireEvent("onKillNormal", thing);
                if (thing.id) {
                    delete thing.FSP.MapScreener.thingsById[thing.id];
                }
            }
        };
        /* Activations
        */
        /**
         * Activates a Detector to trigger a cutscene and/or routine.
         *
         * @param thing   A Player triggering other.
         * @param other   A Detector triggered by thing.
         */
        FullScreenPokemon.prototype.activateCutsceneTriggerer = function (thing, other) {
            if (!other.alive || thing.collidedTrigger === other) {
                return;
            }
            thing.collidedTrigger = other;
            thing.FSP.animatePlayerDialogFreeze(thing);
            if (!other.keepAlive) {
                other.alive = false;
                if (other.id.indexOf("Anonymous") !== -1) {
                    console.warn("Deleting anonymous CutsceneTriggerer:", other.id);
                }
                thing.FSP.StateHolder.addChange(other.id, "alive", false);
                thing.FSP.killNormal(other);
            }
            if (other.cutscene) {
                thing.FSP.ScenePlayer.startCutscene(other.cutscene, {
                    "player": thing,
                    "triggerer": other
                });
            }
            if (other.routine) {
                thing.FSP.ScenePlayer.playRoutine(other.routine);
            }
        };
        /**
         * Activates a Detector to play an audio theme.
         *
         * @param thing   A Player triggering other.
         * @param other   A Detector triggered by thing.
         */
        FullScreenPokemon.prototype.activateThemePlayer = function (thing, other) {
            if (!thing.player || thing.FSP.AudioPlayer.getThemeName() === other.theme) {
                return;
            }
            thing.FSP.AudioPlayer.playTheme(other.theme);
        };
        /**
         * Activates a Detector to play a cutscene, and potentially a dialog.
         *
         * @param thing   A Player triggering other.
         * @param other   A Detector triggered by thing.
         */
        FullScreenPokemon.prototype.activateCutsceneResponder = function (thing, other) {
            if (!thing.player || !other.alive) {
                return;
            }
            if (other.dialog) {
                thing.FSP.activateMenuTriggerer(thing, other);
                return;
            }
            thing.FSP.ScenePlayer.startCutscene(other.cutscene, {
                "player": thing,
                "triggerer": other
            });
        };
        /**
         * Activates a Detector to open a menu, and potentially a dialog.
         *
         * @param thing   A Character triggering other.
         * @param other   A Detector triggered by thing.
         */
        FullScreenPokemon.prototype.activateMenuTriggerer = function (thing, other) {
            if (!other.alive || thing.collidedTrigger === other) {
                return;
            }
            var name = other.menu || "GeneralText", dialog = other.dialog;
            thing.collidedTrigger = other;
            thing.FSP.animateCharacterPreventWalking(thing);
            if (!other.keepAlive) {
                thing.FSP.killNormal(other);
            }
            if (!thing.FSP.MenuGrapher.getMenu(name)) {
                thing.FSP.MenuGrapher.createMenu(name, other.menuAttributes);
            }
            if (dialog) {
                thing.FSP.MenuGrapher.addMenuDialog(name, dialog, function () {
                    var onStop;
                    if (other.pushSteps) {
                        onStop = other.pushSteps.slice();
                    }
                    thing.FSP.MenuGrapher.deleteMenu("GeneralText");
                    if (typeof other.pushDirection !== "undefined") {
                        onStop.push(function () {
                            thing.FSP.MapScreener.blockInputs = false;
                            delete thing.collidedTrigger;
                        });
                        thing.FSP.animateCharacterStartWalkingCycle(thing, other.pushDirection, onStop);
                    }
                    else {
                        thing.FSP.MapScreener.blockInputs = false;
                        delete thing.collidedTrigger;
                    }
                });
            }
            thing.FSP.MenuGrapher.setActiveMenu(name);
        };
        /**
         * Activates a Character's sight detector for when another Character walks
         * into it.
         *
         * @param thing   A Character triggering other.
         * @param other   A sight detector being triggered by thing.
         */
        FullScreenPokemon.prototype.activateSightDetector = function (thing, other) {
            if (other.viewer.talking) {
                return;
            }
            other.viewer.talking = true;
            other.active = false;
            thing.FSP.MapScreener.blockInputs = true;
            thing.FSP.ScenePlayer.startCutscene("TrainerSpotted", {
                "player": thing,
                "sightDetector": other,
                "triggerer": other.viewer
            });
        };
        /**
         * Activation callback for level transports (any Thing with a .transport
         * attribute). Depending on the transport, either the map or location are
         * shifted to it.
         *
         * @param thing   A Character attempting to enter other.
         * @param other   A transporter being entered by thing.
         */
        FullScreenPokemon.prototype.activateTransporter = function (thing, other) {
            if (!thing.player || !other.active) {
                return;
            }
            if (typeof other.transport === "undefined") {
                throw new Error("No transport given to activateTransporter");
            }
            var transport = other.transport, callback, args;
            if (transport.constructor === String) {
                callback = thing.FSP.setLocation.bind(thing.FSP);
                args = [transport];
            }
            else if (typeof transport.map !== "undefined") {
                callback = thing.FSP.setMap.bind(thing.FSP);
                args = [transport.map, transport.location];
            }
            else if (typeof transport.location !== "undefined") {
                callback = thing.FSP.setLocation.bind(thing.FSP);
                args = [transport.location];
            }
            else {
                throw new Error("Unknown transport type:" + transport);
            }
            other.active = false;
            thing.FSP.animateFadeToColor(thing.FSP, {
                "color": "Black",
                "callback": callback.apply.bind(callback, thing.FSP, args)
            });
        };
        /**
         * Activation trigger for a gym statue. If the Player is looking up at it,
         * it speaks the status of the gym leader.
         *
         * @param thing   A Player activating other.
         * @param other   A gym statue being activated by thing.
         */
        FullScreenPokemon.prototype.activateGymStatue = function (thing, other) {
            if (thing.direction !== 0) {
                return;
            }
            var gym = other.gym, leader = other.leader, dialog = [
                gym.toUpperCase()
                    + " \n %%%%%%%POKEMON%%%%%%% GYM \n LEADER: "
                    + leader.toUpperCase(),
                "WINNING TRAINERS: %%%%%%%RIVAL%%%%%%%"
            ];
            if (thing.FSP.ItemsHolder.getItem("badges")[leader]) {
                dialog[1] += " \n %%%%%%%PLAYER%%%%%%%";
            }
            thing.FSP.MenuGrapher.createMenu("GeneralText");
            thing.FSP.MenuGrapher.addMenuDialog("GeneralText", dialog);
            thing.FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /* Physics
        */
        /**
         * Determines the bordering direction from one Thing to another.
         *
         * @param thing   The source Thing.
         * @param other   The destination Thing.
         * @returns The direction from thing to other.
         */
        FullScreenPokemon.prototype.getDirectionBordering = function (thing, other) {
            if (Math.abs((thing.top) - (other.bottom - other.tolBottom)) < thing.FSP.unitsize) {
                return Direction.Top;
            }
            if (Math.abs(thing.right - other.left) < thing.FSP.unitsize) {
                return Direction.Right;
            }
            if (Math.abs(thing.bottom - other.top) < thing.FSP.unitsize) {
                return Direction.Bottom;
            }
            if (Math.abs(thing.left - other.right) < thing.FSP.unitsize) {
                return Direction.Left;
            }
            return undefined;
        };
        /**
         * Determines the direction from one Thing to another.
         *
         * @param thing   The source Thing.
         * @param other   The destination Thing.
         * @returns The direction from thing to other.
         * @remarks Like getDirectionBordering, but for cases where the two Things
         *          aren't necessarily touching.
         */
        FullScreenPokemon.prototype.getDirectionBetween = function (thing, other) {
            var directionBordering = thing.FSP.getDirectionBordering(thing, other);
            if (typeof directionBordering !== "undefined") {
                return directionBordering;
            }
            if (thing.top > other.bottom + thing.FSP.unitsize) {
                return Direction.Top;
            }
            if (thing.right < other.left - thing.FSP.unitsize) {
                return Direction.Right;
            }
            if (thing.bottom < other.top - thing.FSP.unitsize) {
                return Direction.Bottom;
            }
            if (thing.left > other.right + thing.FSP.unitsize) {
                return Direction.Left;
            }
            return undefined;
        };
        /**
         * Checks whether one Thing is overlapping another.
         *
         * @param thing   An in-game Thing.
         * @param other   An in-game Thing.
         * @returns Whether thing and other are overlapping.
         */
        FullScreenPokemon.prototype.isThingWithinOther = function (thing, other) {
            return (thing.top >= other.top - thing.FSP.unitsize
                && thing.right <= other.right + thing.FSP.unitsize
                && thing.bottom <= other.bottom + thing.FSP.unitsize
                && thing.left >= other.left - thing.FSP.unitsize);
        };
        /**
         * Determines whether a Character is visually within grass.
         *
         * @param thing   An in-game Character.
         * @param other   Grass that thing might be in.
         * @returns Whether thing is visually within other.
         */
        FullScreenPokemon.prototype.isThingWithinGrass = function (thing, other) {
            if (thing.right <= other.left) {
                return false;
            }
            if (thing.left >= other.right) {
                return false;
            }
            if (other.top > (thing.top + thing.heightGrass * thing.FSP.unitsize)) {
                return false;
            }
            if (other.bottom < (thing.top + thing.heightGrass * thing.FSP.unitsize)) {
                return false;
            }
            return true;
        };
        /**
         * Shifts a Character according to its xvel and yvel.
         *
         * @param thing   A Character to shift.
         */
        FullScreenPokemon.prototype.shiftCharacter = function (thing) {
            if (thing.xvel !== 0) {
                thing.bordering[1] = thing.bordering[3] = undefined;
            }
            else if (thing.yvel !== 0) {
                thing.bordering[0] = thing.bordering[2] = undefined;
            }
            else {
                return;
            }
            thing.FSP.shiftBoth(thing, thing.xvel, thing.yvel);
        };
        /**
         * Sets a Player looking in a direction and updates MapScreener.
         *
         * @param thing   An in-game Player.
         * @param direction   A direction for thing to look at.
         */
        FullScreenPokemon.prototype.setPlayerDirection = function (thing, direction) {
            thing.direction = direction;
            thing.FSP.MapScreener.playerDirection = direction;
            thing.shouldWalk = true;
        };
        /* Spawning
        */
        /**
         * Spawning callback for Characters. Sight and roaming are accounted for.
         *
         * @param thing   A newly placed Character.
         */
        FullScreenPokemon.prototype.spawnCharacter = function (thing) {
            if (thing.sight) {
                thing.sightDetector = thing.FSP.addThing([
                    "SightDetector",
                    {
                        "direction": thing.direction,
                        "width": thing.sight * 8
                    }
                ]);
                thing.sightDetector.viewer = thing;
                thing.FSP.animatePositionSightDetector(thing);
            }
            if (thing.roaming) {
                thing.FSP.TimeHandler.addEvent(thing.FSP.activateCharacterRoaming, thing.FSP.NumberMaker.randomInt(70), thing);
            }
        };
        /**
         * Starts a Character roaming in random directions.
         *
         * @param thing   A Character to start roaming.
         * @returns Whether the time cycle should stop (thing is dead).
         */
        FullScreenPokemon.prototype.activateCharacterRoaming = function (thing) {
            if (!thing.alive) {
                return true;
            }
            thing.FSP.TimeHandler.addEvent(thing.FSP.activateCharacterRoaming, 70 + thing.FSP.NumberMaker.randomInt(210), thing);
            if (!thing.talking && !thing.FSP.MenuGrapher.getActiveMenu()) {
                thing.FSP.animateCharacterStartWalkingRandom(thing);
            }
            return false;
        };
        /**
         * Activates a Spawner by calling its .activate.
         *
         * @param thing   A newly placed Spawner.
         */
        FullScreenPokemon.prototype.activateSpawner = function (thing) {
            thing.activate(thing);
        };
        /**
         * Activates a WindowDetector by immediately starting its cycle of
         * checking whether it's in-frame to activate.
         *
         * @param thing   A newly placed WindowDetector.
         */
        FullScreenPokemon.prototype.spawnWindowDetector = function (thing) {
            if (!thing.FSP.checkWindowDetector(thing)) {
                thing.FSP.TimeHandler.addEventInterval(thing.FSP.checkWindowDetector, 7, Infinity, thing);
            }
        };
        /**
         * Checks if a WindowDetector is within frame, and activates it if so.
         *
         * @param thing   An in-game WindowDetector.
         */
        FullScreenPokemon.prototype.checkWindowDetector = function (thing) {
            if (thing.bottom < 0
                || thing.left > thing.FSP.MapScreener.width
                || thing.top > thing.FSP.MapScreener.height
                || thing.right < 0) {
                return false;
            }
            thing.activate(thing);
            thing.FSP.killNormal(thing);
            return true;
        };
        /**
         * Activates an AreaSpawner. If it's for a different Area than the current,
         * that area is spawned in the appropriate direction.
         *
         * @param thing   An AreaSpawner to activate.
         */
        FullScreenPokemon.prototype.spawnAreaSpawner = function (thing) {
            var map = thing.FSP.AreaSpawner.getMap(thing.map), area = map.areas[thing.area];
            if (area === thing.FSP.AreaSpawner.getArea()) {
                thing.FSP.killNormal(thing);
                return;
            }
            if (area.spawnedBy
                && area.spawnedBy === thing.FSP.AreaSpawner.getArea().spawnedBy) {
                thing.FSP.killNormal(thing);
                return;
            }
            area.spawnedBy = thing.FSP.AreaSpawner.getArea().spawnedBy;
            thing.FSP.activateAreaSpawner(thing, area);
        };
        /**
         * Runs an AreaSpawner to place its Area's Things in the map.
         *
         * @param thing   An in-game AreaSpawner.
         * @param area   The Area associated with thing.
         */
        FullScreenPokemon.prototype.activateAreaSpawner = function (thing, area) {
            var direction = thing.direction, creation = area.creation, FSP = thing.FSP, MapsCreator = FSP.MapsCreator, AreaSpawner = FSP.AreaSpawner, QuadsKeeper = FSP.QuadsKeeper, areaCurrent = AreaSpawner.getArea(), mapCurrent = AreaSpawner.getMap(), prethingsCurrent = AreaSpawner.getPreThings(), left = thing.left + thing.FSP.MapScreener.left, top = thing.top + thing.FSP.MapScreener.top, x, y, command, i;
            switch (direction) {
                case 0:
                    top -= area.height * thing.FSP.unitsize;
                    break;
                case 1:
                    left += thing.width * thing.FSP.unitsize;
                    break;
                case 2:
                    top += thing.height * thing.FSP.unitsize;
                    break;
                case 3:
                    left -= area.width * thing.FSP.unitsize;
                    break;
                default:
                    throw new Error("Unknown direction: " + direction + ".");
            }
            x = left / FSP.unitsize + (thing.offsetX || 0);
            y = top / FSP.unitsize + (thing.offsetY || 0);
            FSP.expandMapBoundariesForArea(FSP, area, x, y);
            for (i = 0; i < creation.length; i += 1) {
                // A copy of the command must be used, so as to not modify the original 
                command = FSP.proliferate({
                    "noBoundaryStretch": true,
                    "areaName": area.name,
                    "mapName": area.map.name
                }, creation[i]);
                if (!command.x) {
                    command.x = x;
                }
                else {
                    command.x += x;
                }
                if (!command.y) {
                    command.y = y;
                }
                else {
                    command.y += y;
                }
                // Having an entrance might conflict with previously set Locations
                if (command.hasOwnProperty("entrance")) {
                    delete command.entrance;
                }
                MapsCreator.analyzePreSwitch(command, prethingsCurrent, areaCurrent, mapCurrent);
            }
            AreaSpawner.spawnArea(FullScreenPokemon_1.DirectionSpawns[direction], QuadsKeeper.top / FSP.unitsize, QuadsKeeper.right / FSP.unitsize, QuadsKeeper.bottom / FSP.unitsize, QuadsKeeper.left / FSP.unitsize);
            area.spawned = true;
            FSP.killNormal(thing);
        };
        /**
         * Expands the MapScreener boundaries for a newly added Area.
         *
         * @param FSP
         * @param area   The newly added Area.
         * @param x   The x-location of the expansion.
         * @param y   The y-location of the expansion.
         * @todo For now, this assumes any Area with an added Area is outdoors (which
         *       hasn't been shown to be incorrect yet).
         */
        FullScreenPokemon.prototype.expandMapBoundariesForArea = function (FSP, area, dx, dy) {
            FSP.MapScreener.scrollability = Scrollability.Both;
        };
        /* Pokedex storage
        */
        /**
         * Adds a Pokemon by title to the Pokedex.
         *
         * @param FSP
         * @param titleRaw   The raw title of the Pokemon.
         * @param status   Whether the Pokemon has been seen and caught.
         */
        FullScreenPokemon.prototype.addPokemonToPokedex = function (FSP, titleRaw, status) {
            var pokedex = FSP.ItemsHolder.getItem("Pokedex"), title = titleRaw.join(""), information = pokedex[title], caught = status === PokedexListingStatus.Caught, seen = caught || (status === PokedexListingStatus.Seen);
            if (information) {
                // Skip potentially expensive storage operations if they're unnecessary
                if (information.caught || (information.seen && status >= PokedexListingStatus.Seen)) {
                    return;
                }
                information.caught = information.caught || (status >= PokedexListingStatus.Caught);
                information.seen = information.seen || (status >= PokedexListingStatus.Seen);
            }
            else {
                pokedex[title] = information = {
                    caught: caught,
                    seen: seen,
                    title: titleRaw
                };
            }
            FSP.ItemsHolder.setItem("Pokedex", pokedex);
        };
        /**
         * Retrieves known Pokedex listings in ascending order. Unknown Pokemon are
         * replaced with `null`.
         *
         * @param FSP
         * @returns Pokedex listings in ascending order.
         */
        FullScreenPokemon.prototype.getPokedexListingsOrdered = function (FSP) {
            var pokedex = FSP.ItemsHolder.getItem("Pokedex"), pokemon = FSP.MathDecider.getConstant("pokemon"), titlesSorted = Object.keys(pokedex)
                .sort(function (a, b) {
                return pokemon[a].number - pokemon[b].number;
            }), ordered = [], i, j;
            if (!titlesSorted.length) {
                return [];
            }
            for (i = 0; i < pokemon[titlesSorted[0]].number - 1; i += 1) {
                ordered.push(null);
            }
            for (i = 0; i < titlesSorted.length - 1; i += 1) {
                ordered.push(pokedex[titlesSorted[i]]);
                for (j = pokemon[titlesSorted[i]].number - 1; j < pokemon[titlesSorted[i + 1]].number - 2; j += 1) {
                    ordered.push(null);
                }
            }
            ordered.push(pokedex[titlesSorted[i]]);
            return ordered;
        };
        /* Menus
        */
        /**
         * Opens the Pause menu.
         */
        FullScreenPokemon.prototype.openPauseMenu = function () {
            var options = [
                {
                    "text": "%%%%%%%POKEMON%%%%%%%",
                    "callback": this.openPokemonMenu.bind(this, {})
                }, {
                    "text": "ITEM",
                    "callback": this.openItemsMenu.bind(this)
                }, {
                    "text": "%%%%%%%PLAYER%%%%%%%",
                    "callback": this.openPlayerMenu.bind(this)
                }, {
                    "text": "SAVE",
                    "callback": this.openSaveMenu.bind(this)
                }, {
                    "text": "OPTION"
                }, {
                    "text": "Exit",
                    "callback": this.closePauseMenu.bind(this)
                }];
            // The Pokedex option is only shown if the Player has one
            if (this.ItemsHolder.getItem("hasPokedex") === true) {
                options.unshift({
                    "text": "%%%%%%%POKEDEX%%%%%%%",
                    "callback": this.openPokedexMenu.bind(this)
                });
            }
            this.MenuGrapher.createMenu("Pause");
            this.MenuGrapher.addMenuList("Pause", {
                "options": options
            });
            this.MenuGrapher.setActiveMenu("Pause");
        };
        /**
         * Closes the Pause menu.
         */
        FullScreenPokemon.prototype.closePauseMenu = function () {
            this.MenuGrapher.deleteMenu("Pause");
        };
        /**
         * Toggles whether the Pause menu is open. If there is an active menu, A
         * Start key trigger is registered in the MenuGraphr instead.
         *
         * @param FSP
         */
        FullScreenPokemon.prototype.togglePauseMenu = function (thing) {
            var FSP = thing.FSP;
            if (FSP.MenuGrapher.getActiveMenu()) {
                FSP.MenuGrapher.registerStart();
                return;
            }
            var cutsceneSettings = FSP.ScenePlayer.getCutsceneSettings();
            if (cutsceneSettings && cutsceneSettings.disablePauseMenu) {
                return;
            }
            FSP.MenuGrapher.getMenu("Pause")
                ? FSP.closePauseMenu()
                : FSP.openPauseMenu();
        };
        /**
         * Opens the Pokedex menu.
         */
        FullScreenPokemon.prototype.openPokedexMenu = function () {
            var _this = this;
            var listings = this.getPokedexListingsOrdered(this), currentListing;
            this.MenuGrapher.createMenu("Pokedex");
            this.MenuGrapher.addMenuList("Pokedex", {
                "options": listings.map(function (listing, i) {
                    var characters = _this.makeDigit(i + 1, 3, 0).split(""), output = {
                        "text": characters,
                        "callback": function () {
                            currentListing = listing;
                            _this.MenuGrapher.setActiveMenu("PokedexOptions");
                        }
                    };
                    characters.push({
                        "command": true,
                        "y": 4
                    });
                    if (listing) {
                        if (listing.caught) {
                            characters.push({
                                "command": true,
                                "x": -4,
                                "y": 1
                            });
                            characters.push("Ball");
                            characters.push({
                                "command": true,
                                "y": -1
                            });
                        }
                        characters.push.apply(characters, listing.title);
                    }
                    else {
                        characters.push.apply(characters, "----------".split(""));
                    }
                    characters.push({
                        "command": true,
                        "y": -4
                    });
                    return output;
                })
            });
            this.MenuGrapher.setActiveMenu("Pokedex");
            this.MenuGrapher.createMenu("PokedexOptions");
            this.MenuGrapher.addMenuList("PokedexOptions", {
                "options": [
                    {
                        "text": "DATA",
                        "callback": function () {
                            _this.openPokedexListing(currentListing.title, _this.MenuGrapher.setActiveMenu.bind(_this.MenuGrapher, "PokedexOptions"));
                        }
                    }, {
                        "text": "CRY"
                    }, {
                        "text": "AREA",
                        "callback": function () {
                            _this.openTownMapMenu({
                                "backMenu": "PokedexOptions"
                            });
                            _this.showTownMapPokemonLocations(currentListing.title);
                        }
                    }, {
                        "text": "QUIT",
                        "callback": this.MenuGrapher.registerB
                    }
                ]
            });
        };
        /**
         * Opens the context menu within the Pokedex menu for the selected Pokemon.
         *
         * @param settings   Settings for the selected Pokemon, including its HM moves.
         */
        FullScreenPokemon.prototype.openPokemonMenuContext = function (settings) {
            var _this = this;
            var moves = settings.pokemon.moves, options = [], move, i;
            for (i = 0; i < moves.length; i += 1) {
                move = this.MathDecider.getConstant("moves")[moves[i].title];
                if (move.partyActivate) {
                    options.push({
                        "text": moves[i].title.toUpperCase(),
                        "callback": function () {
                            move.partyActivate(_this.player, settings.pokemon);
                        }
                    });
                }
            }
            options.push({
                "text": "STATS",
                "callback": this.openPokemonMenuStats.bind(this, settings.pokemon)
            }, {
                "text": "SWITCH",
                "callback": settings.onSwitch
            }, {
                "text": "CANCEL",
                "callback": this.MenuGrapher.registerB
            });
            this.MenuGrapher.createMenu("PokemonMenuContext", {
                "backMenu": "Pokemon"
            });
            this.MenuGrapher.addMenuList("PokemonMenuContext", {
                "options": options
            });
            this.MenuGrapher.setActiveMenu("PokemonMenuContext");
        };
        /**
         * Opens a statistics menu for a Pokemon.
         *
         * @param pokemon   A Pokemon to show statistics of.
         */
        FullScreenPokemon.prototype.openPokemonMenuStats = function (pokemon) {
            var schemas = this.MathDecider.getConstant("pokemon"), schema = schemas[pokemon.title.join("")], barWidth = 25, health = this.MathDecider.compute("widthHealthBar", barWidth, pokemon.HP, pokemon.HPNormal);
            this.MenuGrapher.createMenu("PokemonMenuStats", {
                "backMenu": "PokemonMenuContext",
                "callback": this.openPokemonMenuStatsSecondary.bind(this, pokemon),
                "container": "Pokemon"
            });
            this.openPokemonLevelUpStats({
                "pokemon": pokemon,
                "container": "PokemonMenuStats",
                "size": {
                    "width": 40,
                    "height": 40
                },
                "position": {
                    "vertical": "bottom",
                    "horizontal": "left",
                    "offset": {
                        "left": 3,
                        "top": -3
                    }
                },
                "textXOffset": 4
            });
            this.MenuGrapher.addMenuDialog("PokemonMenuStatsTitle", [pokemon.nickname]);
            this.MenuGrapher.addMenuDialog("PokemonMenuStatsLevel", pokemon.level.toString());
            this.MenuGrapher.addMenuDialog("PokemonMenuStatsHP", pokemon.HP + "/ " + pokemon.HPNormal);
            this.MenuGrapher.addMenuDialog("PokemonMenuStatsNumber", this.makeDigit(schema.number, 3, 0));
            this.MenuGrapher.addMenuDialog("PokemonMenuStatsStatus", "OK");
            this.MenuGrapher.addMenuDialog("PokemonMenuStatsType1", pokemon.types[0]);
            if (pokemon.types.length >= 2) {
                this.MenuGrapher.createMenu("PokemonMenuStatsType2");
                this.MenuGrapher.addMenuDialog("PokemonMenuStatsType2", pokemon.types[1]);
            }
            this.MenuGrapher.addMenuDialog("PokemonMenuStatsID", "31425");
            this.MenuGrapher.addMenuDialog("PokemonMenuStatsOT", [
                "%%%%%%%PLAYER%%%%%%%"
            ]);
            this.MenuGrapher.createMenuThing("PokemonMenuStatsHPBar", {
                "type": "thing",
                "thing": "LightGraySquare",
                "position": {
                    "horizontal": "left",
                    "offset": {
                        "top": 0.5,
                        "left": 8.5
                    }
                },
                "args": {
                    "width": Math.max(health, 1),
                    "height": 1,
                    "hidden": health === 0
                }
            });
            this.MenuGrapher.createMenuThing("PokemonMenuStats", {
                "type": "thing",
                "thing": pokemon.title.join("") + "Front",
                "args": {
                    "flipHoriz": true
                },
                "position": {
                    "vertical": "bottom",
                    "offset": {
                        "left": 9,
                        "top": -48
                    }
                }
            });
            this.MenuGrapher.setActiveMenu("PokemonMenuStats");
        };
        /**
         * Opens the LevelUpStats menu for a Pokemon to view its statistics.
         *
         * @param settings   Settings to open the menu.
         */
        FullScreenPokemon.prototype.openPokemonLevelUpStats = function (settings) {
            var pokemon = settings.pokemon, statistics = this.MathDecider.getConstant("statisticNamesDisplayed"), numStatistics = statistics.length, textXOffset = settings.textXOffset || 8, top, left, i;
            // A copy of statistics is used to not modify the original constant
            statistics = [].slice.call(statistics);
            for (i = 0; i < numStatistics; i += 1) {
                statistics.push(this.makeDigit(pokemon[statistics[i] + "Normal"], 3, "\t"));
                statistics[i] = statistics[i].toUpperCase();
            }
            this.MenuGrapher.createMenu("LevelUpStats", {
                "container": settings.container,
                "size": settings.size,
                "position": settings.position || {
                    "horizontal": "center",
                    "vertical": "center"
                },
                "callback": this.MenuGrapher.deleteMenu.bind(this.MenuGrapher, "LevelUpStats"),
                "onMenuDelete": settings.onMenuDelete,
                "childrenSchemas": statistics.map(function (text, i) {
                    if (i < numStatistics) {
                        top = i * 8 + 4;
                        left = textXOffset;
                    }
                    else {
                        top = (i - numStatistics + 1) * 8;
                        left = textXOffset + 20;
                    }
                    return {
                        "type": "text",
                        "words": [text],
                        "position": {
                            "offset": {
                                "top": top - .5,
                                "left": left
                            }
                        }
                    };
                })
            });
        };
        /**
         * Open the secondary statistics menu from the LevelUpStats menu.
         *
         * @param pokemon   The Pokemon to open the menu for.
         */
        FullScreenPokemon.prototype.openPokemonMenuStatsSecondary = function (pokemon) {
            var _this = this;
            var options = pokemon.moves.map(function (move) {
                var characters = [" "], output = {
                    "text": characters
                };
                characters.push({
                    "command": true,
                    "x": 40,
                    "y": 4
                });
                characters.push({
                    "command": true,
                    "y": .5
                });
                characters.push("PP", " ");
                characters.push({
                    "command": true,
                    "y": -.5
                });
                characters.push.apply(characters, _this.makeDigit(move.remaining, 2, " ").split(""));
                characters.push("/");
                characters.push.apply(characters, _this.makeDigit(_this.MathDecider.getConstant("moves")[move.title].PP, 2, " ").split(""));
                characters.push({
                    "command": true,
                    "x": -75,
                    "y": -4
                });
                // TODO: Moves should always be uppercase...
                characters.push.apply(characters, move.title.toUpperCase().split(""));
                return output;
            }), i;
            // Fill any remaining options with "-" and "--" for move and PP, respectively
            for (i = options.length; i < 4; i += 1) {
                options.push({
                    "text": [
                        "-",
                        {
                            "command": true,
                            "x": 40,
                            "y": 4
                        },
                        "-",
                        "-"
                    ]
                });
            }
            this.MenuGrapher.createMenu("PokemonMenuStatsExperience");
            this.MenuGrapher.addMenuDialog("PokemonMenuStatsExperience", this.makeDigit(pokemon.experience.current, 10, "\t"));
            this.MenuGrapher.addMenuDialog("PokemonMenuStatsExperienceFrom", this.makeDigit(pokemon.experience.remaining, 3, "\t"));
            this.MenuGrapher.addMenuDialog("PokemonMenuStatsExperienceNext", pokemon.level === 99 ? "" : (pokemon.level + 1).toString());
            this.MenuGrapher.createMenu("PokemonMenuStatsMoves");
            this.MenuGrapher.addMenuList("PokemonMenuStatsMoves", {
                "options": options
            });
            this.MenuGrapher.getMenu("PokemonMenuStats").callback = this.MenuGrapher.deleteMenu.bind(this.MenuGrapher);
        };
        /**
         * Opens a Pokedex listing for a Pokemon.
         *
         * @param title   The title of the Pokemon to open the listing for.
         * @param callback   A callback for when the menu is closed.
         */
        FullScreenPokemon.prototype.openPokedexListing = function (title, callback, menuSettings) {
            var _this = this;
            var pokemon = this.MathDecider.getConstant("pokemon")[title.join("")], height = pokemon.height, feet = [].slice.call(height[0]).reverse().join(""), inches = [].slice.call(height[1]).reverse().join(""), onCompletion = function (FSP) {
                FSP.MenuGrapher.deleteMenu("PokedexListing");
                if (callback) {
                    callback();
                }
            };
            this.MenuGrapher.createMenu("PokedexListing", menuSettings);
            this.MenuGrapher.createMenuThing("PokedexListingSprite", {
                "thing": title.join("") + "Front",
                "type": "thing",
                "args": {
                    "flipHoriz": true
                }
            });
            this.MenuGrapher.addMenuDialog("PokedexListingName", [[title]]);
            this.MenuGrapher.addMenuDialog("PokedexListingLabel", pokemon.label);
            this.MenuGrapher.addMenuDialog("PokedexListingHeightFeet", feet);
            this.MenuGrapher.addMenuDialog("PokedexListingHeightInches", inches);
            this.MenuGrapher.addMenuDialog("PokedexListingWeight", pokemon.weight.toString());
            this.MenuGrapher.addMenuDialog("PokedexListingNumber", this.makeDigit(pokemon.number, 3, "0"));
            this.MenuGrapher.addMenuDialog("PokedexListingInfo", pokemon.info[0], function () {
                if (pokemon.info.length < 2) {
                    onCompletion(_this);
                    return;
                }
                _this.MenuGrapher.createMenu("PokedexListingInfo");
                _this.MenuGrapher.addMenuDialog("PokedexListingInfo", pokemon.info[1], onCompletion(_this));
                _this.MenuGrapher.setActiveMenu("PokedexListingInfo");
            });
            this.MenuGrapher.setActiveMenu("PokedexListingInfo");
        };
        /**
         * Opens a Pokemon menu for the Pokemon in the player's party.
         *
         * @param settings   Custom attributes to apply to the menu.
         */
        FullScreenPokemon.prototype.openPokemonMenu = function (settings) {
            var _this = this;
            var listings = this.ItemsHolder.getItem("PokemonInParty"), references = this.MathDecider.getConstant("pokemon");
            if (!listings || !listings.length) {
                return;
            }
            this.MenuGrapher.createMenu("Pokemon", settings);
            this.MenuGrapher.addMenuList("Pokemon", {
                "options": listings.map(function (listing, i) {
                    var sprite = references[listing.title.join("")].sprite + "Pokemon", barWidth = 25, health = _this.MathDecider.compute("widthHealthBar", barWidth, listing.HP, listing.HPNormal);
                    return {
                        "text": listing.title,
                        "callback": _this.openPokemonMenuContext.bind(_this, {
                            "pokemon": listing
                        }),
                        "things": [
                            {
                                "thing": sprite,
                                "position": {
                                    "offset": {
                                        "left": 7.5,
                                        "top": .5
                                    }
                                }
                            },
                            {
                                "thing": "CharLevel",
                                "position": {
                                    "offset": {
                                        "left": 56,
                                        "top": 1.5
                                    }
                                }
                            },
                            {
                                "thing": "CharHP",
                                "position": {
                                    "offset": {
                                        "left": 20,
                                        "top": 5.5
                                    }
                                }
                            },
                            {
                                "thing": "HPBar",
                                "args": {
                                    "width": barWidth
                                },
                                "position": {
                                    "offset": {
                                        "left": 27,
                                        "top": 5.5
                                    }
                                }
                            },
                            {
                                "thing": "LightGraySquare",
                                "args": {
                                    "width": Math.max(health, 1),
                                    "height": 1,
                                    "hidden": health === 0
                                },
                                "position": {
                                    "offset": {
                                        "left": 27.5,
                                        "top": 6
                                    }
                                }
                            }],
                        "textsFloating": [
                            {
                                "text": String(listing.level),
                                "x": 44.25,
                                "y": 0
                            },
                            {
                                "text": listing.HP + "/ " + listing.HPNormal,
                                "x": 43.75,
                                "y": 4
                            }]
                    };
                })
            });
            this.MenuGrapher.setActiveMenu("Pokemon");
        };
        /**
         * Opens the Items menu for the items in the player's inventory.
         *
         * @param settings   Custom attributes to apply to the menu, as well as items
         *                   to optionally override the player's inventory.
         */
        FullScreenPokemon.prototype.openItemsMenu = function (settings) {
            var _this = this;
            var items = settings.items || this.ItemsHolder.getItem("items");
            this.MenuGrapher.createMenu("Items", settings);
            this.MenuGrapher.addMenuList("Items", {
                "options": items.map(function (schema) {
                    return {
                        "text": schema.item,
                        "textsFloating": [
                            {
                                "text": [["Times"]],
                                "x": 32,
                                "y": 4.5
                            }, {
                                "text": _this.makeDigit(schema.amount, 2, " "),
                                "x": 36.5,
                                "y": 4
                            }
                        ]
                    };
                })
            });
            this.MenuGrapher.setActiveMenu("Items");
            console.warn("Once math.js contains item info, react to non-stackable items...");
        };
        /**
         * Opens the Player menu.
         */
        FullScreenPokemon.prototype.openPlayerMenu = function () {
            this.MenuGrapher.createMenu("Player", {
                "callback": this.MenuGrapher.registerB.bind(this.MenuGrapher)
            });
            this.MenuGrapher.setActiveMenu("Player");
        };
        /**
         * Opens the Save menu.
         */
        FullScreenPokemon.prototype.openSaveMenu = function () {
            this.MenuGrapher.createMenu("Save");
            this.MenuGrapher.createMenu("GeneralText");
            this.MenuGrapher.addMenuDialog("GeneralText", "Would you like to SAVE the game?");
            this.MenuGrapher.createMenu("Yes/No", {
                "backMenu": "Pause",
                "killOnB": ["GeneralText", "Save"]
            });
            this.MenuGrapher.addMenuList("Yes/No", {
                "options": [
                    {
                        "text": "YES",
                        "callback": this.downloadSaveGame.bind(this)
                    }, {
                        "text": "NO",
                        "callback": this.MenuGrapher.registerB
                    }]
            });
            this.MenuGrapher.setActiveMenu("Yes/No");
        };
        /**
         * Opens the Keyboard menu and binds it to some required callbacks.
         *
         * @param settings   Settings to apply to the menu and for callbacks.
         */
        FullScreenPokemon.prototype.openKeyboardMenu = function (settings) {
            if (settings === void 0) { settings = {}; }
            var value = [
                settings.value || ["_", "_", "_", "_", "_", "_", "_"]
            ], onKeyPress = this.addKeyboardMenuValue.bind(this), onBPress = this.removeKeyboardMenuValue.bind(this), onComplete = (settings.callback || onKeyPress).bind(this), lowercase = settings.lowercase, letters = lowercase
                ? FullScreenPokemon.keysLowercase
                : FullScreenPokemon.keysUppercase, options = letters.map(function (letter) {
                return {
                    "text": [letter],
                    "value": letter,
                    "callback": letter !== "ED"
                        ? onKeyPress
                        : onComplete
                };
            }), menuResults;
            this.MenuGrapher.createMenu("Keyboard", {
                "settings": settings,
                "onKeyPress": onKeyPress,
                "onComplete": onComplete,
                "ignoreB": false
            });
            menuResults = this.MenuGrapher.getMenu("KeyboardResult");
            this.MenuGrapher.addMenuDialog("KeyboardTitle", [[
                    settings.title || "",
                ]]);
            this.MenuGrapher.addMenuDialog("KeyboardResult", value);
            this.MenuGrapher.addMenuList("KeyboardKeys", {
                "options": options,
                "selectedIndex": settings.selectedIndex,
                "bottom": {
                    "text": lowercase ? "UPPER CASE" : "lower case",
                    "callback": this.switchKeyboardCase.bind(this),
                    "position": {
                        "top": 40,
                        "left": 0
                    }
                }
            });
            this.MenuGrapher.getMenu("KeyboardKeys").onBPress = onBPress;
            this.MenuGrapher.setActiveMenu("KeyboardKeys");
            menuResults.displayedValue = value.slice()[0];
            menuResults.completeValue = settings.completeValue || [];
            menuResults.selectedChild = settings.selectedChild || 0;
            menuResults.blinker = this.addThing("CharMDash", menuResults.children[menuResults.selectedChild].left, menuResults.children[menuResults.selectedChild].top);
            menuResults.children.push(menuResults.blinker);
            menuResults.children[menuResults.selectedChild].hidden = true;
        };
        /**
         * Adds a value to the keyboard menu from the currently selected item.
         */
        FullScreenPokemon.prototype.addKeyboardMenuValue = function () {
            var menuKeys = this.MenuGrapher.getMenu("KeyboardKeys"), menuResult = this.MenuGrapher.getMenu("KeyboardResult"), child = menuResult.children[menuResult.selectedChild], selected = this.MenuGrapher.getMenuSelectedOption("KeyboardKeys");
            if (!child) {
                return;
            }
            this.killNormal(child);
            menuResult.children[menuResult.selectedChild] = this.addThing(selected.title, child.left, child.top);
            menuResult.displayedValue[menuResult.selectedChild] = selected.text[0];
            menuResult.completeValue.push(selected.value);
            menuResult.selectedChild += 1;
            if (menuResult.selectedChild < menuResult.children.length - 1) {
                child = menuResult.children[menuResult.selectedChild];
                child.hidden = true;
            }
            else {
                menuResult.blinker.hidden = true;
                this.MenuGrapher.setSelectedIndex("KeyboardKeys", menuKeys.gridColumns - 1, menuKeys.gridRows - 2); // assume there's a bottom option
            }
            this.setLeft(menuResult.blinker, child.left);
            this.setTop(menuResult.blinker, child.top);
        };
        /**
         * Removes the rightmost keyboard menu value.
         */
        FullScreenPokemon.prototype.removeKeyboardMenuValue = function () {
            var menuResult = this.MenuGrapher.getMenu("KeyboardResult"), child = menuResult.children[menuResult.selectedChild - 1];
            if (menuResult.selectedChild <= 0) {
                return;
            }
            menuResult.selectedChild -= 1;
            menuResult.completeValue = menuResult.completeValue.slice(0, menuResult.completeValue.length - 1);
            menuResult.displayedValue[menuResult.selectedChild] = "_";
            this.killNormal(child);
            child = menuResult.children[menuResult.selectedChild];
            menuResult.children[menuResult.selectedChild + 1] = this.addThing("CharUnderscore", child.right, child.top);
            this.setLeft(menuResult.blinker, child.left);
            this.setTop(menuResult.blinker, child.top);
        };
        /**
         * Switches the keyboard menu's case.
         */
        FullScreenPokemon.prototype.switchKeyboardCase = function () {
            var keyboard = this.MenuGrapher.getMenu("Keyboard"), keyboardKeys = this.MenuGrapher.getMenu("KeyboardKeys"), keyboardResult = this.MenuGrapher.getMenu("KeyboardResult"), settings = keyboard.settings;
            settings.lowercase = !settings.lowercase;
            settings.value = keyboardResult.displayedValue;
            settings.selectedChild = keyboardResult.selectedChild;
            settings.displayedValue = keyboardResult.displayedValue;
            settings.completeValue = keyboardResult.completeValue;
            settings.selectedIndex = keyboardKeys.selectedIndex;
            this.openKeyboardMenu(settings);
        };
        /**
         * Opens the Town Map menu.
         *
         * @param settings   Custom attributes to apply to the menu.
         */
        FullScreenPokemon.prototype.openTownMapMenu = function (settings) {
            var playerPosition = this.MathDecider.getConstant("townMapLocations")["Pallet Town"], playerSize = this.ObjectMaker.getFullPropertiesOf("Player");
            this.MenuGrapher.createMenu("Town Map", settings);
            this.MenuGrapher.createMenuThing("Town Map Inside", {
                "type": "thing",
                "thing": "Player",
                "args": {
                    "nocollide": true
                },
                "position": {
                    "offset": {
                        "left": playerPosition[0] - (playerSize.width / 2),
                        "top": playerPosition[1] - (playerSize.height / 2)
                    }
                }
            });
            this.MenuGrapher.setActiveMenu("Town Map");
        };
        /**
         * Shows allowed flying locations on the Town Map menu.
         */
        FullScreenPokemon.prototype.showTownMapFlyLocations = function () {
            console.warn("Map fly locations not implemented.");
        };
        /**
         * Shows a Pokemon's nest locations on the Town Map menu.
         *
         * @param title   The title of the Pokemon to show nest locations of.
         */
        FullScreenPokemon.prototype.showTownMapPokemonLocations = function (title) {
            var dialog = [].slice.call(title);
            dialog.push.apply(dialog, "'s NEST".split(""));
            this.MenuGrapher.addMenuDialog("Town Map", [dialog]);
            console.warn("Pokemon map locations not implemented.");
        };
        /* Battles
        */
        /**
         * Starts a Pokemon battle.
         *
         * @param battleInfo   Settings for the battle.
         */
        FullScreenPokemon.prototype.startBattle = function (battleInfo) {
            var animations = battleInfo.animations || [
                // "LineSpiral", "Flash"
                "Flash"
            ], animation = this.NumberMaker.randomArrayMember(animations), player = battleInfo.player;
            if (!player) {
                battleInfo.player = player = {};
            }
            player.name = player.name || "%%%%%%%PLAYER%%%%%%%";
            player.sprite = player.sprite || "PlayerBack";
            player.category = player.category || "Trainer";
            player.actors = player.actors || this.ItemsHolder.getItem("PokemonInParty");
            player.hasActors = typeof player.hasActors === "undefined"
                ? true : player.hasActors;
            this.AudioPlayer.playTheme(battleInfo.theme || "Battle Trainer");
            this["cutsceneBattleTransition" + animation](this, {
                "battleInfo": battleInfo,
                "callback": this.BattleMover.startBattle.bind(this.BattleMover, battleInfo)
            });
            this.moveBattleKeptThingsToText(this, battleInfo);
        };
        /**
         * Collects all unique Things that should be kept on top of battle intro animations.
         *
         * @param FSP
         * @param thingsRaw   Titles of and/or references to Things that should be kept.
         * @returns The unique Things that will be kept.
         */
        FullScreenPokemon.prototype.collectBattleKeptThings = function (FSP, thingsRaw) {
            var things = [FSP.player], used = (_a = {},
                _a[FSP.player.title] = FSP.player,
                _a
            ), thing, i;
            for (i = 0; i < thingsRaw.length; i += 1) {
                thing = thingsRaw[i].constructor === String
                    ? FSP.getThingById(thingsRaw[i])
                    : thingsRaw[i];
                if (!used[thing.title]) {
                    used[thing.title] = thing;
                    things.push(thing);
                }
            }
            return things;
            var _a;
        };
        /**
         * Moves all kept Things in a battle to the Text group for animations.
         *
         * @param FSP
         * @param batleInfo    In-game state and settings for an ongoing battle.
         */
        FullScreenPokemon.prototype.moveBattleKeptThingsToText = function (FSP, battleInfo) {
            var keptThings = battleInfo.keptThings, i;
            if (!keptThings) {
                return;
            }
            for (i = 0; i < keptThings.length; i += 1) {
                FSP.GroupHolder.switchMemberGroup(keptThings[i], keptThings[i].groupType, "Text");
            }
        };
        /**
         * Moves all kept Things in a battle back to their original groups.
         *
         * @param FSP
         * @param batleInfo    In-game state and settings for an ongoing battle.
         */
        FullScreenPokemon.prototype.moveBattleKeptThingsBack = function (FSP, battleInfo) {
            var keptThings = battleInfo.keptThings, i;
            if (!keptThings) {
                return;
            }
            for (i = 0; i < keptThings.length; i += 1) {
                FSP.GroupHolder.switchMemberGroup(keptThings[i], "Text", keptThings[i].groupType);
            }
        };
        /**
         * Creates a new Pokemon from a schema, using the newPokemon equation.
         *
         * @param schema   A description of the Pokemon.
         * @returns A newly created Pokemon.
         */
        FullScreenPokemon.prototype.createPokemon = function (schema) {
            var level = typeof schema.levels !== "undefined"
                ? this.NumberMaker.randomArrayMember(schema.levels)
                : schema.level, pokemon = this.MathDecider.compute("newPokemon", schema.title, level);
            return pokemon;
        };
        /**
         * Heals a Pokemon back to full health.
         *
         * @param pokemon   An in-game Pokemon to heal.
         */
        FullScreenPokemon.prototype.healPokemon = function (pokemon) {
            var moves = this.MathDecider.getConstant("moves"), statisticNames = this.MathDecider.getConstant("statisticNames"), i;
            for (i = 0; i < statisticNames.length; i += 1) {
                pokemon[statisticNames[i]] = pokemon[statisticNames[i] + "Normal"];
            }
            for (i = 0; i < pokemon.moves.length; i += 1) {
                pokemon.moves[i].remaining = moves[pokemon.moves[i].title].PP;
            }
            pokemon.status = "";
        };
        /**
         * Starts grass battle if a Player is in grass, using the doesGrassEncounterHappen
         * equation.
         *
         * @param thing   An in-game Player.
         */
        FullScreenPokemon.prototype.checkPlayerGrassBattle = function (thing) {
            if (!thing.grass || thing.FSP.MenuGrapher.getActiveMenu()) {
                return;
            }
            if (!thing.FSP.ThingHitter.checkHitForThings(thing, thing.grass)) {
                delete thing.grass;
                return;
            }
            if (!thing.FSP.MathDecider.compute("doesGrassEncounterHappen", thing.grass)) {
                return;
            }
            thing.keys = thing.getKeys();
            thing.FSP.animateGrassBattleStart(thing, thing.grass);
        };
        /**
         * Chooses a random wild Pokemon schema from the given ones.
         *
         * @param FSP
         * @param options   Potential Pokemon schemas to choose from.
         * @returns One of the potential Pokemon schemas at random.
         */
        FullScreenPokemon.prototype.chooseRandomWildPokemon = function (FSP, options) {
            var choice = FSP.NumberMaker.random(), sum = 0, i;
            for (i = 0; i < options.length; i += 1) {
                sum += options[i].rate;
                if (sum >= choice) {
                    return options[i];
                }
            }
        };
        /**
         * Adds Ball and BallEmpty Things to a menu representing inventory Pokemon.
         *
         * @param FSP
         * @param menu   A menu to add the Things to.
         * @param battler   Information on the Pokemon to add balls for.
         */
        FullScreenPokemon.prototype.addBattleDisplayPokeballs = function (FSP, menu, battler, opposite) {
            var text = [], i;
            for (i = 0; i < battler.actors.length; i += 1) {
                text.push(["Ball"]);
            }
            for (; i < 6; i += 1) {
                text.push(["BallEmpty"]);
            }
            if (opposite) {
                text.reverse();
            }
            FSP.MenuGrapher.addMenuDialog(menu.name, [text]);
        };
        /**
         * Adds a Pokemon's health display to its appropriate menu.
         *
         * @param FSP
         * @param battlerName   Which battler to add the display for, as "player"
         *                      or "opponent".
         */
        FullScreenPokemon.prototype.addBattleDisplayPokemonHealth = function (FSP, battlerName) {
            var battleInfo = FSP.BattleMover.getBattleInfo(), pokemon = battleInfo[battlerName].selectedActor, menu = [
                "Battle",
                battlerName[0].toUpperCase(),
                battlerName.slice(1),
                "Health"
            ].join("");
            FSP.MenuGrapher.createMenu(menu);
            FSP.MenuGrapher.createMenu(menu + "Title");
            FSP.MenuGrapher.createMenu(menu + "Level");
            FSP.MenuGrapher.createMenu(menu + "Amount");
            FSP.setBattleDisplayPokemonHealthBar(FSP, battlerName, pokemon.HP, pokemon.HPNormal);
            FSP.MenuGrapher.addMenuDialog(menu + "Title", [[pokemon.nickname]]);
            FSP.MenuGrapher.addMenuDialog(menu + "Level", String(pokemon.level));
        };
        /**
         * Adds a health bar to a battle display, with an appropriate width.
         *
         * @param FSP
         * @param battlerName   Which battler to add the display for, as "player"
         *                      or "opponent".
         * @param hp   How much health the battler's Pokemon currently has.
         * @param hp   The battler's Pokemon's normal maximum health.
         */
        FullScreenPokemon.prototype.setBattleDisplayPokemonHealthBar = function (FSP, battlerName, hp, hpNormal) {
            var nameUpper = battlerName[0].toUpperCase() + battlerName.slice(1), menuNumbers = "Battle" + nameUpper + "HealthNumbers", bar = FSP.getThingById("HPBarFill" + nameUpper), barWidth = FSP.MathDecider.compute("widthHealthBar", 25, hp, hpNormal), healthDialog = FSP.makeDigit(hp, 3, "\t") + "/" + FSP.makeDigit(hpNormal, 3, "\t");
            if (FSP.MenuGrapher.getMenu(menuNumbers)) {
                FSP.MenuGrapher.getMenu(menuNumbers).children.forEach(FSP.killNormal.bind(FSP));
                FSP.MenuGrapher.addMenuDialog(menuNumbers, healthDialog);
            }
            FSP.setWidth(bar, barWidth);
            bar.hidden = barWidth === 0;
        };
        /**
         * Animates a Pokemon's health bar to increase or decrease its width.
         *
         * @param FSP
         * @param battlerName   Which battler to add the display for, as "player"
         *                      or "opponent".
         * @param hpStart   The battler's Pokemon's starting health.
         * @param hpEnd   The battler's Pokemon's ending health.
         * @param hpNormal   The battler's Pokemon's normal maximum health.
         * @param callback   A callback for when the bar is done resizing.
         */
        FullScreenPokemon.prototype.animateBattleDisplayPokemonHealthBar = function (FSP, battlerName, hpStart, hpEnd, hpNormal, callback) {
            var direction = hpStart > hpEnd ? -1 : 1, hpNew = Math.round(hpStart + direction);
            FSP.setBattleDisplayPokemonHealthBar(FSP, battlerName, hpNew, hpNormal);
            if (hpNew === hpEnd) {
                if (callback) {
                    callback();
                }
                return;
            }
            FSP.TimeHandler.addEvent(FSP.animateBattleDisplayPokemonHealthBar, 2, FSP, battlerName, hpNew, hpEnd, hpNormal, callback);
        };
        /* Cutscenes
        */
        /**
         * Cutscene for starting a battle with a spiral.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneBattleTransitionLineSpiral = function (FSP, settings) {
            var unitsize = FSP.unitsize, divisor = settings.divisor || 15, screenWidth = FSP.MapScreener.width, screenHeight = FSP.MapScreener.height, width = Math.ceil(screenWidth / divisor), height = Math.ceil(screenHeight / divisor), numTimes = 0, direction = 2, things = [], thing, difference, destination;
            function addLineSpiralThing() {
                if (numTimes >= ((divisor / 2) | 0)) {
                    if (settings.callback) {
                        settings.callback();
                        things.forEach(FSP.killNormal);
                    }
                    return;
                }
                switch (thing.direction) {
                    case 0:
                        thing = FSP.ObjectMaker.make("BlackSquare", {
                            "width": width / unitsize,
                            "height": screenHeight / unitsize
                        });
                        FSP.addThing(thing, screenWidth - ((numTimes + 1) * width), screenHeight - ((numTimes + 1) * divisor));
                        difference = -height;
                        destination = numTimes * height;
                        break;
                    case 1:
                        thing = FSP.ObjectMaker.make("BlackSquare", {
                            "width": screenWidth / unitsize,
                            "height": height / unitsize
                        });
                        FSP.addThing(thing, numTimes * divisor - screenWidth, screenHeight - (numTimes + 1) * height);
                        difference = width;
                        destination = screenWidth - numTimes * width;
                        break;
                    case 2:
                        thing = FSP.ObjectMaker.make("BlackSquare", {
                            "width": width / unitsize,
                            "height": screenHeight / unitsize
                        });
                        FSP.addThing(thing, numTimes * width, numTimes * height - screenHeight);
                        difference = height;
                        destination = screenHeight - numTimes * height;
                        break;
                    case 3:
                        thing = FSP.ObjectMaker.make("BlackSquare", {
                            "width": screenWidth / unitsize,
                            "height": height / unitsize
                        });
                        FSP.addThing(thing, screenWidth - numTimes * divisor, numTimes * height);
                        difference = -width;
                        destination = numTimes * width;
                        break;
                    default:
                        throw new Error("Unknown direction: " + direction + ".");
                }
                things.push(thing);
                FSP.moveBattleKeptThingsToText(FSP, settings.battleInfo);
                FSP.TimeHandler.addEventInterval(function () {
                    if (direction % 2 === 1) {
                        FSP.shiftHoriz(thing, difference);
                    }
                    else {
                        FSP.shiftVert(thing, difference);
                    }
                    if (direction === 1 || direction === 2) {
                        if (thing[FullScreenPokemon_1.DirectionAliases[direction]] < destination) {
                            return false;
                        }
                    }
                    else {
                        if (thing[FullScreenPokemon_1.DirectionAliases[direction]] > destination) {
                            return false;
                        }
                    }
                    direction = (direction + 3) % 4;
                    if (direction === 2) {
                        numTimes += 1;
                    }
                    addLineSpiralThing();
                    FSP.moveBattleKeptThingsToText(FSP, settings);
                    return true;
                }, 1, Infinity);
            }
            addLineSpiralThing();
        };
        /**
         * Cutscene for starting a battle with a series of flashes.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         * @remarks Three [black, white] flashes, then the spiral
         */
        FullScreenPokemon.prototype.cutsceneBattleTransitionFlash = function (FSP, settings) {
            var flashes = settings.flashes || 6, flashColors = settings.flashColors || ["Black", "White"], callback = settings.callback, change = settings.change || .33, speed = settings.speed || 1, completed = 0, color, repeater = function () {
                if (completed >= flashes) {
                    if (callback) {
                        callback();
                    }
                    return;
                }
                color = flashColors[completed % flashColors.length];
                completed += 1;
                FSP.animateFadeToColor(FSP, {
                    "color": color,
                    "change": change,
                    "speed": speed,
                    "callback": FSP.animateFadeFromColor.bind(FSP, FSP, {
                        "color": color,
                        "change": change,
                        "speed": speed,
                        "callback": repeater
                    })
                });
                FSP.moveBattleKeptThingsToText(FSP, settings.battleInfo);
            };
            repeater();
        };
        /**
         * Cutscene for starting a battle with a twist.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         *
         * I think the way to do this would be to treat each quarter of the screen
         * as one section. Divide each section into 10 parts. On each interval
         * increase the maximum the parts can be, while each part is a fraction of
         * the maximum, rounded to a large amount to appear pixellated (perhaps,
         * unitsize * 32?).
         */
        FullScreenPokemon.prototype.cutsceneBattleTransitionTwist = function (FSP, settings) {
            throw new Error("Not yet implemented.");
        };
        /**
         * Cutscene for starting a battle with a flash, then a twist..
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneBattleTransitionFlashTwist = function (FSP, settings) {
            FSP.cutsceneBattleTransitionFlash(FSP, {
                "callback": FSP.cutsceneBattleTransitionTwist.bind(FSP, FSP, settings)
            });
        };
        /**
         * Cutscene for starting a battle. Players slide in, then the openingText
         * cutscene is called.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene
         */
        FullScreenPokemon.prototype.cutsceneBattleEntrance = function (FSP, settings) {
            var things = settings.things, battleInfo = settings.battleInfo, player = things.player, opponent = things.opponent, menu = FSP.MenuGrapher.getMenu("BattleDisplayInitial"), playerX, opponentX, playerGoal, opponentGoal, timeout = 70;
            battleInfo.player.selectedIndex = 0;
            battleInfo.player.selectedActor = battleInfo.player.actors[0];
            battleInfo.opponent.selectedIndex = 0;
            battleInfo.opponent.selectedActor = battleInfo.opponent.actors[0];
            player.opacity = 0;
            opponent.opacity = 0;
            FSP.setLeft(player, menu.right + player.width * FSP.unitsize);
            FSP.setRight(opponent, menu.left);
            FSP.setTop(opponent, menu.top);
            // They should be visible halfway through (2 * (1 / timeout))
            FSP.animateFadeAttribute(player, "opacity", 2 / timeout, 1, 1);
            FSP.animateFadeAttribute(opponent, "opacity", 2 / timeout, 1, 1);
            playerX = FSP.getMidX(player);
            opponentX = FSP.getMidX(opponent);
            playerGoal = menu.left + player.width * FSP.unitsize / 2;
            opponentGoal = menu.right - opponent.width * FSP.unitsize / 2;
            FSP.animateSlideHorizontal(player, (playerGoal - playerX) / timeout, playerGoal, 1);
            FSP.animateSlideHorizontal(opponent, (opponentGoal - opponentX) / timeout, opponentGoal, 1);
            FSP.addPokemonToPokedex(FSP, battleInfo.opponent.actors[0].title, PokedexListingStatus.Seen);
            FSP.TimeHandler.addEvent(FSP.ScenePlayer.bindRoutine("OpeningText"), timeout);
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for the opening text and base menus in a battle. Afer this,
         * the EnemyIntro or PlayerIntro cutscene is triggered.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene
         */
        FullScreenPokemon.prototype.cutsceneBattleOpeningText = function (FSP, settings) {
            var battleInfo = settings.battleInfo, textStart = battleInfo.textStart, nextRoutine, callback;
            if (settings.battleInfo.opponent.hasActors) {
                nextRoutine = "EnemyIntro";
            }
            else {
                nextRoutine = "PlayerIntro";
            }
            if (battleInfo.automaticMenus) {
                callback = FSP.TimeHandler.addEvent.bind(FSP.TimeHandler, FSP.ScenePlayer.playRoutine.bind(FSP.ScenePlayer), 70, nextRoutine);
            }
            else {
                callback = FSP.ScenePlayer.bindRoutine(nextRoutine);
            }
            FSP.MenuGrapher.createMenu("BattlePlayerHealth");
            FSP.addBattleDisplayPokeballs(FSP, FSP.MenuGrapher.getMenu("BattlePlayerHealth"), battleInfo.player);
            if (battleInfo.opponent.hasActors) {
                FSP.MenuGrapher.createMenu("BattleOpponentHealth");
                FSP.addBattleDisplayPokeballs(FSP, FSP.MenuGrapher.getMenu("BattleOpponentHealth"), battleInfo.player, true);
            }
            else {
                FSP.addBattleDisplayPokemonHealth(FSP, "opponent");
            }
            FSP.MenuGrapher.createMenu("GeneralText", {
                "finishAutomatically": battleInfo.automaticMenus
            });
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                [
                    textStart[0], battleInfo.opponent.name, textStart[1]
                ]
            ], callback);
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for an enemy's intro in a battle. They enter, and either send
         * out a Pokemon or let the player intro.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene
         */
        FullScreenPokemon.prototype.cutsceneBattleEnemyIntro = function (FSP, settings) {
            var things = settings.things, opponent = things.opponent, menu = FSP.MenuGrapher.getMenu("GeneralText"), opponentX = FSP.getMidX(opponent), opponentGoal = menu.right + opponent.width * FSP.unitsize / 2, battleInfo = settings.battleInfo, callback = battleInfo.opponent.hasActors
                ? "OpponentSendOut"
                : "PlayerIntro", timeout = 49;
            FSP.animateSlideHorizontal(opponent, (opponentGoal - opponentX) / timeout, opponentGoal, 1);
            FSP.TimeHandler.addEvent(FSP.animateFadeAttribute, (timeout / 2) | 0, opponent, "opacity", -2 / timeout, 0, 1);
            FSP.MenuGrapher.deleteMenu("BattleOpponentHealth");
            FSP.MenuGrapher.createMenu("GeneralText", {
                "finishAutomatically": true
            });
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                [
                    battleInfo.textOpponentSendOut[0],
                    battleInfo.opponent.name,
                    battleInfo.textOpponentSendOut[1],
                    battleInfo.opponent.actors[0].nickname,
                    battleInfo.textOpponentSendOut[2]
                ]
            ]);
            FSP.MenuGrapher.setActiveMenu("GeneralText");
            FSP.TimeHandler.addEvent(FSP.ScenePlayer.bindRoutine(callback, {
                "nextRoutine": "PlayerIntro"
            }), timeout);
        };
        /**
         * Cutscene for a player's intro into battle. Afterwards, the ShowPlayerMenu
         * cutscene is triggered.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene
         */
        FullScreenPokemon.prototype.cutsceneBattlePlayerIntro = function (FSP, settings) {
            var things = settings.things, player = things.player, menu = FSP.MenuGrapher.getMenu("GeneralText"), playerX = FSP.getMidX(player), playerGoal = menu.left - player.width * FSP.unitsize / 2, battleInfo = settings.battleInfo, timeout = 24;
            FSP.MenuGrapher.deleteMenu("BattlePlayerHealth");
            if (!battleInfo.player.hasActors) {
                FSP.ScenePlayer.playRoutine("ShowPlayerMenu");
                return;
            }
            FSP.animateSlideHorizontal(player, (playerGoal - playerX) / timeout, playerGoal, 1);
            FSP.TimeHandler.addEvent(FSP.animateFadeAttribute, (timeout / 2) | 0, player, "opacity", -2 / timeout, 0, 1);
            FSP.MenuGrapher.createMenu("GeneralText", {
                "finishAutomatically": true
            });
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                [
                    battleInfo.textPlayerSendOut[0],
                    battleInfo.player.actors[0].nickname,
                    battleInfo.textPlayerSendOut[1]
                ]
            ]);
            FSP.MenuGrapher.setActiveMenu("GeneralText");
            FSP.TimeHandler.addEvent(FSP.ScenePlayer.bindRoutine("PlayerSendOut", {
                "nextRoutine": "ShowPlayerMenu"
            }), timeout);
        };
        /**
         * Cutscene for showing the player menu. The user may now interact with
         * the menu for controlling their side of the battle.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene
         */
        FullScreenPokemon.prototype.cutsceneBattleShowPlayerMenu = function (FSP, settings) {
            FSP.MenuGrapher.deleteMenu("Yes/No");
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.BattleMover.showPlayerMenu();
            if (settings.battleInfo.onShowPlayerMenu) {
                settings.battleInfo.onShowPlayerMenu(FSP);
            }
        };
        /**
         * Cutscene for the opponent starting to send out a Pokemon. A smoke effect
         * plays, then the OpponentSendOutAppear cutscene triggers.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene
         * @param args   Settings to pass to the OpponentSendOut cutscene.
         */
        FullScreenPokemon.prototype.cutsceneBattleOpponentSendOut = function (FSP, settings, args) {
            var menu = settings.things.menu, left = menu.right - FSP.unitsize * 8, top = menu.top + FSP.unitsize * 32;
            console.warn("Should reset *Normal statistics for opponent Pokemon.");
            settings.opponentLeft = left;
            settings.opponentTop = top;
            FSP.MenuGrapher.setActiveMenu(undefined);
            FSP.animateSmokeSmall(FSP, left, top, FSP.ScenePlayer.bindRoutine("OpponentSendOutAppear", args));
        };
        /**
         * Cutscene for the opponent's Pokemon appearing. The .nextRoutine from args
         * is played.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene
         * @param args   Settings to pass to the next routine.
         */
        FullScreenPokemon.prototype.cutsceneBattleOpponentSendOutAppear = function (FSP, settings, args) {
            var opponentInfo = settings.battleInfo.opponent, pokemonInfo = opponentInfo.actors[opponentInfo.selectedIndex], pokemon = FSP.BattleMover.setThing("opponent", pokemonInfo.title.join("") + "Front");
            console.log("Should make the zoom-in animation for appearing Pokemon...", pokemon);
            FSP.addBattleDisplayPokemonHealth(FSP, "opponent");
            FSP.addPokemonToPokedex(FSP, pokemonInfo.title, PokedexListingStatus.Seen);
            FSP.ScenePlayer.playRoutine(args.nextRoutine);
        };
        /**
         * Cutscene for the player starting to send out a Pokemon. A smoke effect
         * plays, then the PlayerSendOutAppear cutscene triggers.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene
         * @param args   Settings to pass to the PlayerSendOut cutscene.
         */
        FullScreenPokemon.prototype.cutsceneBattlePlayerSendOut = function (FSP, settings, args) {
            var menu = settings.things.menu, left = menu.left + FSP.unitsize * 8, top = menu.bottom - FSP.unitsize * 8;
            console.warn("Should reset *Normal statistics for player Pokemon.");
            settings.playerLeft = left;
            settings.playerTop = top;
            FSP.MenuGrapher.setActiveMenu(undefined);
            FSP.animateSmokeSmall(FSP, left, top, FSP.ScenePlayer.bindRoutine("PlayerSendOutAppear", args));
        };
        /**
         * Cutscene for the player's Pokemon appearing. The .nextRoutine from args
         * is played.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene
         * @param args   Settings to pass to the next routine.
         */
        FullScreenPokemon.prototype.cutsceneBattlePlayerSendOutAppear = function (FSP, settings, args) {
            var playerInfo = settings.battleInfo.player, pokemonInfo = playerInfo.selectedActor, pokemon = FSP.BattleMover.setThing("player", pokemonInfo.title.join("") + "Back");
            console.log("Should make the zoom-in animation for appearing Pokemon...", pokemon);
            FSP.addBattleDisplayPokemonHealth(FSP, "player");
            FSP.MenuGrapher.createMenu("BattlePlayerHealthNumbers");
            FSP.setBattleDisplayPokemonHealthBar(FSP, "Player", pokemonInfo.HP, pokemonInfo.HPNormal);
            FSP.ScenePlayer.playRoutine(args.nextRoutine);
        };
        /**
         * Cutscene for the player attempting to switch a Pokemon with itself.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneBattlePlayerSwitchesSamePokemon = function (FSP, settings) {
            FSP.MenuGrapher.createMenu("GeneralText", {
                "backMenu": "PokemonMenuContext"
            });
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                settings.battleInfo.player.selectedActor.nickname, " is already out!"
            ]);
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for the player to start a Pokemon move. After the announcement text,
         * the MovePlayerAnimate cutscene is played.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         * @param args   Settings for the routine.
         */
        FullScreenPokemon.prototype.cutsceneBattleMovePlayer = function (FSP, settings, args) {
            var player = settings.battleInfo.player, playerActor = player.selectedActor, opponent = settings.battleInfo.opponent, opponentActor = opponent.selectedActor, choice = args.choicePlayer;
            args.damage = FSP.MathDecider.compute("damage", choice, playerActor, opponentActor);
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                [
                    playerActor.nickname, " used ", choice + "!"
                ]
            ], FSP.ScenePlayer.bindRoutine("MovePlayerAnimate", args));
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for animating the player's chosen move.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         * @param args   Settings for the routine.
         */
        FullScreenPokemon.prototype.cutsceneBattleMovePlayerAnimate = function (FPS, settings, args) {
            var choice = args.choicePlayer, move = FPS.MathDecider.getConstant("moves")[choice];
            console.log("Should do something with", move);
            args.attackerName = "player";
            args.defenderName = "opponent";
            args.callback = function () {
                var callback;
                args.movePlayerDone = true;
                if (args.moveOpponentDone) {
                    callback = function () {
                        args.movePlayerDone = false;
                        args.moveOpponentDone = false;
                        FPS.MenuGrapher.createMenu("GeneralText");
                        FPS.BattleMover.showPlayerMenu();
                    };
                }
                else {
                    callback = FPS.TimeHandler.addEvent.bind(FPS.TimeHandler, FPS.ScenePlayer.bindRoutine("MoveOpponent", args), 7);
                }
                FPS.ScenePlayer.playRoutine("Damage", {
                    "battlerName": "opponent",
                    "damage": args.damage,
                    "callback": callback
                });
            };
            // @todo: When all moves have been implemented, this will be simplified.
            if (!FPS.ScenePlayer.getOtherRoutine("Attack" + choice)) {
                console.warn(choice + " attack animation not implemented...");
                args.callback();
            }
            else {
                FPS.ScenePlayer.playRoutine("Attack" + choice.replace(" ", ""), args);
            }
        };
        /**
         * Cutscene for the opponent to start a Pokemon move. After the announcement text,
         * the MoveOpponentAnimate cutscene is played.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         * @param args   Settings for the routine.
         */
        FullScreenPokemon.prototype.cutsceneBattleMoveOpponent = function (FSP, settings, args) {
            var opponent = settings.battleInfo.opponent, opponentActor = opponent.selectedActor, player = settings.battleInfo.player, playerActor = player.selectedActor, choice = args.choiceOpponent;
            args.damage = FSP.MathDecider.compute("damage", choice, opponentActor, playerActor);
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                [
                    opponent.selectedActor.nickname, " used ", choice + "!"
                ]
            ], FSP.ScenePlayer.bindRoutine("MoveOpponentAnimate", args));
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for animating an opponent's chosen move.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         * @param args   Settings for the routine.
         */
        FullScreenPokemon.prototype.cutsceneBattleMoveOpponentAnimate = function (FSP, settings, args) {
            var choice = args.choiceOpponent, move = FSP.MathDecider.getConstant("moves")[choice];
            console.log("Should do something with", move);
            args.attackerName = "opponent";
            args.defenderName = "player";
            args.callback = function () {
                var callback;
                args.moveOpponentDone = true;
                if (args.movePlayerDone) {
                    callback = function () {
                        args.movePlayerDone = false;
                        args.moveOpponentDone = false;
                        FSP.MenuGrapher.createMenu("GeneralText");
                        FSP.BattleMover.showPlayerMenu();
                    };
                }
                else {
                    callback = FSP.TimeHandler.addEvent.bind(FSP.TimeHandler, FSP.ScenePlayer.bindRoutine("MovePlayer", args), 7);
                }
                FSP.ScenePlayer.playRoutine("Damage", {
                    "battlerName": "player",
                    "damage": args.damage,
                    "callback": callback
                });
            };
            // @todo: When all moves have been implemented, this will be simplified.
            if (!FSP.ScenePlayer.getOtherRoutine("Attack" + choice)) {
                console.warn(choice + " attack animation not implemented...");
                args.callback();
            }
            else {
                FSP.ScenePlayer.playRoutine("Attack" + choice.replace(" ", ""), args);
            }
        };
        /**
         * Cutscene for applying and animating damage in battle.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         * @param args   Settings for the routine.
         */
        FullScreenPokemon.prototype.cutsceneBattleDamage = function (FSP, settings, args) {
            var battlerName = args.battlerName, damage = args.damage, battleInfo = FSP.BattleMover.getBattleInfo(), battler = battleInfo[battlerName], actor = battler.selectedActor, hpStart = actor.HP, hpEnd = Math.max(hpStart - damage, 0), callback = hpEnd === 0
                ? FSP.TimeHandler.addEvent.bind(FSP.TimeHandler, FSP.ScenePlayer.bindRoutine("PokemonFaints", {
                    "battlerName": battlerName
                }), 49)
                : args.callback;
            if (damage !== 0) {
                FSP.animateBattleDisplayPokemonHealthBar(FSP, battlerName, hpStart, hpEnd, actor.HPNormal, callback);
                actor.HP = hpEnd;
            }
            else {
                callback(FSP);
            }
        };
        /**
         * Cutscene for a Pokemon fainting in battle.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         * @param args   Settings for the routine.
         */
        FullScreenPokemon.prototype.cutsceneBattlePokemonFaints = function (FSP, settings, args) {
            var battlerName = args.battlerName, battleInfo = FSP.BattleMover.getBattleInfo(), actor = battleInfo[battlerName].selectedActor, thing = settings.things[battlerName], blank = FSP.ObjectMaker.make("WhiteSquare", {
                "width": thing.width * thing.scale,
                "height": thing.height * thing.scale
            }), texts = FSP.GroupHolder.getGroup("Text"), background = FSP.BattleMover.getBackgroundThing(), backgroundIndex = texts.indexOf(background), nextRoutine = battlerName === "player"
                ? "AfterPlayerPokemonFaints" : "AfterOpponentPokemonFaints";
            FSP.addThing(blank, thing.left, thing.top + thing.height * thing.scale * thing.FSP.unitsize);
            FSP.arrayToIndex(blank, texts, backgroundIndex + 1);
            FSP.arrayToIndex(thing, texts, backgroundIndex + 1);
            FSP.animateSlideVertical(thing, FSP.unitsize * 2, FSP.getMidY(thing) + thing.height * thing.scale * FSP.unitsize, 1, function () {
                FSP.killNormal(thing);
                FSP.killNormal(blank);
                FSP.MenuGrapher.createMenu("GeneralText");
                FSP.MenuGrapher.addMenuDialog("GeneralText", [
                    [
                        actor.nickname, " fainted!"
                    ]
                ], FSP.ScenePlayer.bindRoutine(nextRoutine, args));
                FSP.MenuGrapher.setActiveMenu("GeneralText");
            });
        };
        /**
         * Cutscene for choosing what to do after a Pokemon faints in battle.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneBattleAfterPlayerPokemonFaints = function (FSP, settings) {
            var battleInfo = FSP.BattleMover.getBattleInfo(), actorAvailable = FSP.checkArrayMembersIndex(battleInfo.player.actors, "HP");
            if (actorAvailable) {
                FSP.ScenePlayer.playRoutine("PlayerChoosesPokemon");
            }
            else {
                FSP.ScenePlayer.playRoutine("Defeat");
            }
        };
        /**
         * Cutscene for after an opponent's Pokemon faints in battle.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneBattleAfterOpponentPokemonFaints = function (FSP, settings) {
            var battleInfo = settings.battleInfo, opponent = battleInfo.opponent, actorAvailable = FSP.checkArrayMembersIndex(opponent.actors, "HP"), experienceGained = FSP.MathDecider.compute("experienceGained", battleInfo.player, battleInfo.opponent), callback;
            if (actorAvailable) {
                callback = FSP.ScenePlayer.bindRoutine("OpponentSwitchesPokemon");
            }
            else {
                callback = FSP.ScenePlayer.bindRoutine("Victory");
            }
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                [
                    battleInfo.player.selectedActor.nickname,
                    " gained ",
                    experienceGained.toString(),
                    " EXP. points!"
                ]
            ], FSP.ScenePlayer.bindRoutine("ExperienceGain", {
                "experienceGained": experienceGained,
                "callback": callback
            }));
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for an opponent switching Pokemon in battle.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneBattleOpponentSwitchesPokemon = function (FSP, settings) {
            var battleInfo = settings.battleInfo, opponent = battleInfo.opponent, nicknameExclaim = opponent.selectedActor.nickname.slice();
            nicknameExclaim.push("!");
            FSP.BattleMover.switchActor("opponent", opponent.selectedIndex + 1);
            opponent.selectedIndex += 1;
            opponent.selectedActor = opponent.actors[opponent.selectedIndex];
            FSP.MenuGrapher.createMenu("GeneralText", {
                "deleteOnFinish": false
            });
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                opponent.name,
                "is about to use",
                nicknameExclaim,
                "Will %%%%%%%PLAYER%%%%%%% change %%%%%%%POKEMON%%%%%%%?"
            ], function () {
                FSP.MenuGrapher.createMenu("Yes/No");
                FSP.MenuGrapher.addMenuList("Yes/No", {
                    "options": [
                        {
                            "text": "Yes",
                            "callback": FSP.ScenePlayer.bindRoutine("PlayerSwitchesPokemon", {
                                "nextRoutine": "OpponentSendOut"
                            })
                        }, {
                            "text": "No",
                            "callback": FSP.ScenePlayer.bindRoutine("OpponentSendOut", {
                                "nextRoutine": "ShowPlayerMenu"
                            })
                        }]
                });
                FSP.MenuGrapher.setActiveMenu("Yes/No");
            });
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for a player's Pokemon gaining experience in battle.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         * @param args   Settings for the routine.
         */
        FullScreenPokemon.prototype.cutsceneBattleExperienceGain = function (FSP, settings, args) {
            var battleInfo = settings.battleInfo, gains = args.experienceGained, actor = battleInfo.player.selectedActor, experience = actor.experience;
            console.warn("Experience gain is hardcoded to the current actor...");
            experience.current += gains;
            experience.remaining -= gains;
            if (experience.remaining < 0) {
                gains -= experience.remaining;
                FSP.ScenePlayer.playRoutine("LevelUp", {
                    "experienceGained": gains,
                    "callback": args.callback
                });
            }
            else {
                args.callback();
            }
        };
        /**
         * Cutscene for a player's Pokemon leveling up in battle.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         * @param args   Settings for the routine.
         */
        FullScreenPokemon.prototype.cutsceneBattleLevelUp = function (FSP, settings, args) {
            var battleInfo = settings.battleInfo, 
            // gains: number = args.experienceGained,
            actor = battleInfo.player.selectedActor;
            actor.level += 1;
            actor.experience = FSP.MathDecider.compute("newPokemonExperience", actor.title, actor.level);
            console.warn("Leveling up does not yet increase stats...");
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                [
                    actor.nickname,
                    " grew to level ",
                    actor.level.toString(),
                    "!"
                ]
            ], FSP.ScenePlayer.bindRoutine("LevelUpStats", args));
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for displaying a Pokemon's statistics in battle.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         * @param args   Settings for the routine.
         */
        FullScreenPokemon.prototype.cutsceneBattleLevelUpStats = function (FSP, settings, args) {
            FSP.openPokemonLevelUpStats({
                "container": "BattleDisplayInitial",
                "position": {
                    "horizontal": "right",
                    "vertical": "bottom",
                    "offset": {
                        "left": 4
                    }
                },
                "pokemon": settings.battleInfo.player.selectedActor,
                "onMenuDelete": args.callback
            });
            FSP.MenuGrapher.setActiveMenu("LevelUpStats");
            console.warn("For stones, LevelUpStats should be taken out of battles.");
        };
        /**
         * Cutscene for a player choosing a Pokemon (creating the menu for it).
         *
         * @param FSP
         */
        FullScreenPokemon.prototype.cutsceneBattlePlayerChoosesPokemon = function (FSP) {
            FSP.MenuGrapher.createMenu("Pokemon", {
                "position": {
                    "vertical": "center",
                    "offset": {
                        "left": 0
                    }
                }
            });
        };
        /**
         * Cutscene for failing to run from a trainer battle.
         *
         * @param FSP
         */
        FullScreenPokemon.prototype.cutsceneBattleExitFail = function (FSP) {
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", "No! There's no running from a trainer battle!", FSP.ScenePlayer.bindRoutine("BattleExitFailReturn"));
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for returning to a battle after failing to exit.
         *
         * @param FSP
         */
        FullScreenPokemon.prototype.cutsceneBattleExitFailReturn = function (FSP) {
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.BattleMover.showPlayerMenu();
        };
        /**
         * Cutscene for becoming victorious in battle.
         *
         * @param FSP
         */
        FullScreenPokemon.prototype.cutsceneBattleVictory = function (FSP) {
            var battleInfo = FSP.BattleMover.getBattleInfo(), opponent = battleInfo.opponent;
            if (FSP.MapScreener.theme) {
                FSP.AudioPlayer.playTheme(FSP.MapScreener.theme);
            }
            if (!opponent.hasActors) {
                FSP.BattleMover.closeBattle(function () {
                    FSP.animateFadeFromColor(FSP, {
                        "color": "White"
                    });
                });
                return;
            }
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                [
                    "%%%%%%%PLAYER%%%%%%% defeated ",
                    opponent.name,
                    "!"
                ]
            ], FSP.ScenePlayer.bindRoutine("VictorySpeech"));
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for the opponent responding to the player's victory.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneBattleVictorySpeech = function (FSP, settings) {
            var battleInfo = settings.battleInfo, menu = FSP.MenuGrapher.getMenu("BattleDisplayInitial"), opponent = FSP.BattleMover.setThing("opponent", battleInfo.opponent.sprite), timeout = 35, opponentX, opponentGoal;
            opponent.opacity = 0;
            FSP.setTop(opponent, menu.top);
            FSP.setLeft(opponent, menu.right);
            opponentX = FSP.getMidX(opponent);
            opponentGoal = menu.right - opponent.width * FSP.unitsize / 2;
            FSP.animateFadeAttribute(opponent, "opacity", 4 / timeout, 1, 1);
            FSP.animateSlideHorizontal(opponent, (opponentGoal - opponentX) / timeout, opponentGoal, 1, function () {
                FSP.MenuGrapher.createMenu("GeneralText");
                FSP.MenuGrapher.addMenuDialog("GeneralText", battleInfo.textVictory, FSP.ScenePlayer.bindRoutine("VictoryWinnings"));
                FSP.MenuGrapher.setActiveMenu("GeneralText");
            });
        };
        /**
         * Cutscene for receiving cash for defeating an opponent.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene
         */
        FullScreenPokemon.prototype.cutsceneBattleVictoryWinnings = function (FSP, settings) {
            var battleInfo = settings.battleInfo, reward = battleInfo.opponent.reward, animationSettings = {
                "color": "White"
            }, callback = function () {
                FSP.BattleMover.closeBattle(function () {
                    FSP.animateFadeFromColor(FSP, animationSettings);
                });
            };
            if (battleInfo.giftAfterBattle) {
                FSP.addItemToBag(FSP, battleInfo.giftAfterBattle, battleInfo.giftAfterBattleAmount || 1);
            }
            if (battleInfo.badge) {
                FSP.ItemsHolder.getItem("badges")[battleInfo.badge] = true;
            }
            if (battleInfo.textAfterBattle) {
                animationSettings.callback = function () {
                    FSP.MenuGrapher.createMenu("GeneralText");
                    FSP.MenuGrapher.addMenuDialog("GeneralText", battleInfo.textAfterBattle);
                    FSP.MenuGrapher.setActiveMenu("GeneralText");
                };
            }
            if (!reward) {
                callback();
                return;
            }
            FSP.ItemsHolder.increase("money", reward);
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                "%%%%%%%PLAYER%%%%%%% got $" + reward + " for winning!"
            ], callback);
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for the player being defeated in battle.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneBattleDefeat = function (FSP, settings) {
            var battleInfo = settings.battleInfo, message = ["%%%%%%%PLAYER%%%%%%% is out of useable %%%%%%%POKEMON%%%%%%%!"], callback;
            if (!battleInfo.noBlackout) {
                message.push("%%%%%%%PLAYER%%%%%%% blacked out!");
                callback = function () {
                    var transport = FSP.ItemsHolder.getItem("lastPokecenter");
                    FSP.BattleMover.closeBattle();
                    FSP.setMap(transport.map, transport.location);
                    FSP.ItemsHolder.getItem("PokemonInParty").forEach(FSP.healPokemon.bind(FSP));
                };
            }
            else {
                callback = function () {
                    FSP.BattleMover.closeBattle();
                };
            }
            if (FSP.MapScreener.theme) {
                FSP.AudioPlayer.playTheme(FSP.MapScreener.theme);
            }
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", message, FSP.animateFadeToColor.bind(FSP, FSP, {
                "color": "Black",
                "callback": function () {
                    callback();
                }
            }));
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene a battle completely finishing.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneBattleComplete = function (FSP, settings) {
            FSP.MapScreener.blockInputs = false;
            FSP.moveBattleKeptThingsBack(FSP, settings.battleInfo);
            FSP.ItemsHolder.setItem("PokemonInParty", settings.battleInfo.player.actors);
        };
        /**
         * Cutscene for changing a statistic in battle.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneBattleChangeStatistic = function (FSP, settings, args) {
            var battleInfo = settings.battleInfo, defenderName = args.defenderName, defender = battleInfo[defenderName].selectedActor, defenderLabel = defenderName === "opponent"
                ? "Enemy " : "", statistic = args.statistic, amount = args.amount, amountLabel;
            defender[statistic] -= amount;
            switch (amount) {
                case 2:
                    amountLabel = "sharply rose";
                    break;
                case 1:
                    amountLabel = "rose";
                    break;
                case -1:
                    amountLabel = "fell";
                    break;
                case -2:
                    amountLabel = "sharply fell";
                    break;
                default:
                    break;
            }
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                [
                    defenderLabel,
                    defender.nickname,
                    "'s ",
                    statistic.toUpperCase(),
                    " " + amountLabel + "!"
                ]
            ], args.callback);
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /* Battle attack animations
        */
        /**
         * Cutscene for a Growl attack in battle.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         * @param args   Settings for the routine.
         */
        FullScreenPokemon.prototype.cutsceneBattleAttackGrowl = function (FSP, settings, args) {
            var battleInfo = settings.battleInfo, attackerName = args.attackerName, defenderName = args.defenderName, attacker = FSP.BattleMover.getThing(attackerName), defender = FSP.BattleMover.getThing(defenderName), direction = attackerName === "player" ? 1 : -1, notes = [
                FSP.ObjectMaker.make("Note"),
                FSP.ObjectMaker.make("Note")
            ];
            console.log("Should do something with", notes, direction, defender, attacker, battleInfo);
            FSP.ScenePlayer.playRoutine("ChangeStatistic", FSP.proliferate({
                "callback": args.callback,
                "defenderName": defenderName,
                "statistic": "Attack",
                "amount": -1
            }, args));
        };
        /**
         * Cutscene for a Tackle attack in battle.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         * @param args   Settings for the routine.
         */
        FullScreenPokemon.prototype.cutsceneBattleAttackTackle = function (FSP, settings, args) {
            var attackerName = args.attackerName, defenderName = args.defenderName, attacker = FSP.BattleMover.getThing(attackerName), defender = FSP.BattleMover.getThing(defenderName), direction = attackerName === "player" ? 1 : -1, xvel = 7 * direction, dt = 7, movement = FSP.TimeHandler.addEventInterval(function () {
                FSP.shiftHoriz(attacker, xvel);
            }, 1, Infinity);
            FSP.TimeHandler.addEvent(function () {
                xvel *= -1;
            }, dt);
            FSP.TimeHandler.addEvent(FSP.TimeHandler.cancelEvent, dt * 2 - 1, movement);
            if (attackerName === "player") {
                FSP.TimeHandler.addEvent(FSP.animateFlicker, dt * 2, defender, 14, 5, args.callback);
            }
            else {
                FSP.TimeHandler.addEvent(FSP.animateScreenShake, dt * 2, FSP, 0, undefined, undefined, undefined, FSP.animateFlicker.bind(FSP, defender, 14, 5, args.callback));
            }
        };
        /**
         * Cutscene for a Tail Whip attack in battle.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         * @param args   Settings for the routine.
         */
        FullScreenPokemon.prototype.cutsceneBattleAttackTailWhip = function (FSP, settings, args) {
            var attackerName = args.attackerName, defenderName = args.defenderName, attacker = FSP.BattleMover.getThing(attackerName), direction = attackerName === "player" ? 1 : -1, dt = 11, dx = FSP.unitsize * 4;
            FSP.shiftHoriz(attacker, dx * direction);
            FSP.TimeHandler.addEvent(FSP.shiftHoriz, dt, attacker, -dx * direction);
            FSP.TimeHandler.addEvent(FSP.shiftHoriz, dt * 2, attacker, dx * direction);
            FSP.TimeHandler.addEvent(FSP.shiftHoriz, dt * 3, attacker, -dx * direction);
            FSP.TimeHandler.addEvent(FSP.animateScreenShake, (dt * 3.5) | 0, FSP, 3, 0, 6, undefined, FSP.ScenePlayer.bindRoutine("ChangeStatistic", {
                "callback": args.callback,
                "defenderName": defenderName,
                "statistic": "Defense",
                "amount": -1
            }));
        };
        /* Outdoor cutscenes
        */
        /**
         * Cutscene for when a trainer is encountered for battle.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneTrainerSpottedExclamation = function (FSP, settings) {
            FSP.animateCharacterPreventWalking(FSP.player);
            FSP.animateExclamation(settings.triggerer, 70, FSP.ScenePlayer.bindRoutine("Approach"));
        };
        /**
         * Cutscene for when a trainer approaches the player after being encountered.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneTrainerSpottedApproach = function (FSP, settings) {
            var player = settings.player, triggerer = settings.triggerer, direction = triggerer.direction, directionName = Direction[direction].toLowerCase(), locationTriggerer = triggerer[directionName], locationPlayer = player[FullScreenPokemon_1.DirectionOpposites[directionName]], distance = Math.abs(locationTriggerer - locationPlayer), blocks = Math.max(0, distance / FSP.unitsize / 8);
            if (blocks) {
                FSP.animateCharacterStartWalking(triggerer, direction, [
                    blocks,
                    FSP.ScenePlayer.bindRoutine("Dialog")
                ]);
            }
            else {
                FSP.ScenePlayer.playRoutine("Dialog");
            }
        };
        /**
         * Cutscene for a trainer introduction after the player is approached.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneTrainerSpottedDialog = function (FSP, settings) {
            FSP.collideCharacterDialog(settings.player, settings.triggerer);
            FSP.MapScreener.blockInputs = false;
        };
        /**
         * Cutscene for a nurse's welcome at the Pokemon Center.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutscenePokeCenterWelcome = function (FSP, settings) {
            settings.nurse = FSP.getThingById(settings.nurseId || "Nurse");
            settings.machine = FSP.getThingById(settings.machineId || "HealingMachine");
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                "Welcome to our %%%%%%%POKEMON%%%%%%% CENTER!",
                "We heal your %%%%%%%POKEMON%%%%%%% back to perfect health!",
                "Shall we heal your %%%%%%%POKEMON%%%%%%%?"
            ], FSP.ScenePlayer.bindRoutine("Choose"));
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for choosing whether or not to heal Pokemon.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutscenePokeCenterChoose = function (FSP, settings) {
            FSP.MenuGrapher.createMenu("Heal/Cancel");
            FSP.MenuGrapher.addMenuList("Heal/Cancel", {
                "options": [
                    {
                        "text": "HEAL",
                        "callback": FSP.ScenePlayer.bindRoutine("ChooseHeal")
                    },
                    {
                        "text": "CANCEL",
                        "callback": FSP.ScenePlayer.bindRoutine("ChooseCancel")
                    }
                ]
            });
            FSP.MenuGrapher.setActiveMenu("Heal/Cancel");
        };
        /**
         * Cutscene for choosing to heal Pokemon.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutscenePokeCenterChooseHeal = function (FSP, settings) {
            FSP.MenuGrapher.deleteMenu("Heal/Cancel");
            FSP.MenuGrapher.createMenu("GeneralText", {
                "ignoreA": true,
                "finishAutomatically": true
            });
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                "Ok. We'll need your %%%%%%%POKEMON%%%%%%%."
            ], FSP.ScenePlayer.bindRoutine("Healing"));
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for placing Pokeballs into the healing machine.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutscenePokeCenterHealing = function (FSP, settings) {
            var party = FSP.ItemsHolder.getItem("PokemonInParty"), balls = [], dt = 35, left = settings.machine.left + 5 * FSP.unitsize, top = settings.machine.top + 7 * FSP.unitsize, i = 0;
            settings.balls = balls;
            FSP.animateCharacterSetDirection(settings.nurse, 3);
            FSP.TimeHandler.addEventInterval(function () {
                balls.push(FSP.addThing("HealingMachineBall", left + (i % 2) * 3 * FSP.unitsize, top + Math.floor(i / 2) * 2.5 * FSP.unitsize));
                i += 1;
            }, dt, party.length);
            FSP.TimeHandler.addEvent(FSP.ScenePlayer.playRoutine.bind(FSP.ScenePlayer), dt * (party.length + 1), "HealingAction", {
                "balls": balls
            });
        };
        /**
         * Cutscene for Pokemon being healed in the healing machine.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         * @param args   Settings for the routine.
         */
        FullScreenPokemon.prototype.cutscenePokeCenterHealingAction = function (FSP, settings, args) {
            var balls = args.balls, numFlashes = 8, i = 0, changer, j;
            FSP.TimeHandler.addEventInterval(function () {
                changer = i % 2 === 0
                    ? FSP.addClass
                    : FSP.removeClass;
                for (j = 0; j < balls.length; j += 1) {
                    changer(balls[j], "lit");
                }
                changer(settings.machine, "lit");
                i += 1;
            }, 21, numFlashes);
            FSP.TimeHandler.addEvent(FSP.ScenePlayer.playRoutine.bind(FSP.ScenePlayer), (numFlashes + 2) * 21, "HealingComplete", {
                "balls": balls
            });
        };
        /**
         * Cutscene for when the Pokemon have finished healing.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         * @param args Settings for the routine.
         */
        FullScreenPokemon.prototype.cutscenePokeCenterHealingComplete = function (FSP, settings, args) {
            var balls = args.balls, party = FSP.ItemsHolder.getItem("PokemonInParty");
            balls.forEach(FSP.killNormal.bind(FSP));
            party.forEach(FSP.healPokemon.bind(FSP));
            FSP.animateCharacterSetDirection(settings.nurse, 2);
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                "Thank you! \n Your %%%%%%%POKEMON%%%%%%% are fighting fit!",
                "We hope to see you again!"
            ], function () {
                FSP.MenuGrapher.deleteMenu("GeneralText");
                FSP.ScenePlayer.stopCutscene();
            });
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for choosing not to heal Pokemon.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutscenePokeCenterChooseCancel = function (FSP, settings) {
            FSP.MenuGrapher.deleteMenu("Heal/Cancel");
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                "We hope to see you again!"
            ], function () {
                FSP.MenuGrapher.deleteMenu("GeneralText");
                FSP.ScenePlayer.stopCutscene();
            });
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for speaking to a PokeMart cashier.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutscenePokeMartGreeting = function (FSP, settings) {
            FSP.MenuGrapher.createMenu("GeneralText", {
                "finishAutomatically": true,
                "ignoreA": true,
                "ignoreB": true
            });
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                "Hi there! \n May I help you?"
            ], FSP.ScenePlayer.bindRoutine("Options"));
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene showing the PokeMart action options.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutscenePokeMartOptions = function (FSP, settings) {
            FSP.MenuGrapher.createMenu("Money");
            FSP.MenuGrapher.createMenu("Buy/Sell", {
                "killOnB": ["Money", "GeneralText"],
                "onMenuDelete": FSP.ScenePlayer.bindRoutine("Exit")
            });
            FSP.MenuGrapher.addMenuList("Buy/Sell", {
                "options": [{
                        "text": "BUY",
                        "callback": FSP.ScenePlayer.bindRoutine("BuyMenu")
                    }, {
                        "text": "SELL",
                        "callback": undefined
                    }, {
                        "text": "QUIT",
                        "callback": FSP.MenuGrapher.registerB
                    }]
            });
            FSP.MenuGrapher.setActiveMenu("Buy/Sell");
        };
        /**
         * Cutscene for the PokeMart item menu.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         *
         * @todo Add constants for all items, for display names
         */
        FullScreenPokemon.prototype.cutscenePokeMartBuyMenu = function (FSP, settings) {
            var options = settings.triggerer.items.map(function (reference) {
                var text = reference.item.toUpperCase(), cost = reference.cost;
                return {
                    "text": text,
                    "textsFloating": [{
                            "text": "$" + cost,
                            "x": 42 - String(cost).length * 3.5,
                            "y": 4
                        }],
                    "callback": FSP.ScenePlayer.bindRoutine("SelectAmount", {
                        "reference": reference,
                        "amount": 1,
                        "cost": cost
                    }),
                    "reference": reference
                };
            });
            options.push({
                "text": "CANCEL",
                "callback": FSP.MenuGrapher.registerB
            });
            FSP.MenuGrapher.createMenu("GeneralText", {
                "finishAutomatically": true
            });
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                "Take your time."
            ], function () {
                FSP.MenuGrapher.createMenu("ShopItems", {
                    "backMenu": "Buy/Sell"
                });
                FSP.MenuGrapher.addMenuList("ShopItems", {
                    "options": options
                });
                FSP.MenuGrapher.setActiveMenu("ShopItems");
            });
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for selecting the amount of an item the player wishes to buy.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         * @param args   Settings for the routine.
         */
        FullScreenPokemon.prototype.cutscenePokeMartSelectAmount = function (FSP, settings, args) {
            var reference = args.reference, amount = args.amount, cost = args.cost, costTotal = cost * amount, text = FSP.makeDigit(amount, 2) + FSP.makeDigit("$" + costTotal, 8, " ");
            FSP.MenuGrapher.createMenu("ShopItemsAmount", {
                "childrenSchemas": [
                    {
                        "type": "text",
                        "words": ["Times"],
                        "position": {
                            "offset": {
                                "left": 4,
                                "top": 4.25
                            }
                        }
                    },
                    {
                        "type": "text",
                        "words": [text],
                        "position": {
                            "offset": {
                                "left": 8,
                                "top": 3.75
                            }
                        }
                    }],
                "onUp": FSP.ScenePlayer.bindRoutine("SelectAmount", {
                    "amount": (amount === 99) ? 1 : amount + 1,
                    "cost": cost,
                    "reference": reference
                }),
                "onDown": FSP.ScenePlayer.bindRoutine("SelectAmount", {
                    "amount": (amount === 1) ? 99 : amount - 1,
                    "cost": cost,
                    "reference": reference
                }),
                "callback": FSP.ScenePlayer.bindRoutine("ConfirmPurchase", args)
            });
            FSP.MenuGrapher.setActiveMenu("ShopItemsAmount");
        };
        /**
         * Cutscene for confirming a PokeMart purchase.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         * @param args   Settings for the routine.
         */
        FullScreenPokemon.prototype.cutscenePokeMartConfirmPurchase = function (FSP, settings, args) {
            var reference = args.reference, cost = args.cost, amount = args.amount, costTotal = args.costTotal = cost * amount;
            FSP.MenuGrapher.createMenu("GeneralText", {
                "finishAutomatically": true
            });
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                reference.item.toUpperCase() + "? \n That will be $" + costTotal + ". OK?"
            ], function () {
                FSP.MenuGrapher.createMenu("Yes/No", {
                    "position": {
                        "horizontal": "right",
                        "vertical": "bottom",
                        "offset": {
                            "top": 0,
                            "left": 0
                        }
                    },
                    "onMenuDelete": FSP.ScenePlayer.bindRoutine("CancelPurchase"),
                    "container": "ShopItemsAmount"
                });
                FSP.MenuGrapher.addMenuList("Yes/No", {
                    "options": [
                        {
                            "text": "YES",
                            "callback": FSP.ScenePlayer.bindRoutine("TryPurchase", args)
                        }, {
                            "text": "NO",
                            "callback": FSP.ScenePlayer.bindRoutine("CancelPurchase")
                        }]
                });
                FSP.MenuGrapher.setActiveMenu("Yes/No");
            });
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for canceling a PokeMart purchase.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         *
         * @todo Why is the BuyMenu text appearing twice?
         */
        FullScreenPokemon.prototype.cutscenePokeMartCancelPurchase = function (FSP, settings) {
            FSP.ScenePlayer.playRoutine("BuyMenu");
        };
        /**
         * Cutscene for carrying out a PokeMart transaction. Can either confirm or deny
         * the purchase based on the player's total money.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         * @param args  Settings for the routine.
         */
        FullScreenPokemon.prototype.cutscenePokeMartTryPurchase = function (FSP, settings, args) {
            var costTotal = args.costTotal;
            if (FSP.ItemsHolder.getItem("money") < costTotal) {
                FSP.ScenePlayer.playRoutine("FailPurchase", args);
                return;
            }
            FSP.ItemsHolder.decrease("money", args.costTotal);
            FSP.MenuGrapher.createMenu("Money");
            FSP.ItemsHolder.getItem("items").push({
                "item": args.reference.item,
                "amount": args.amount
            });
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                "Here you are! \n Thank you!"
            ], FSP.ScenePlayer.bindRoutine("ContinueShopping"));
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for when the player does not have enough money for the
         * PokeMart purchase.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutscenePokeMartFailPurchase = function (FSP, settings) {
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                "You don't have enough money."
            ], FSP.ScenePlayer.bindRoutine("ContinueShopping"));
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for asking if the player wants to continue shopping.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutscenePokeMartContinueShopping = function (FSP, settings) {
            if (FSP.MenuGrapher.getMenu("Yes/No")) {
                delete FSP.MenuGrapher.getMenu("Yes/No").onMenuDelete;
            }
            FSP.MenuGrapher.deleteMenu("ShopItems");
            FSP.MenuGrapher.deleteMenu("ShopItemsAmount");
            FSP.MenuGrapher.deleteMenu("Yes/No");
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                "Is there anything else I can do?"
            ]);
            FSP.MenuGrapher.setActiveMenu("Buy/Sell");
        };
        /**
         * Cutscene for the player choosing to stop shopping.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutscenePokeMartExit = function (FSP, settings) {
            FSP.ScenePlayer.stopCutscene();
            FSP.MenuGrapher.deleteMenu("Buy/Sell");
            FSP.MenuGrapher.deleteMenu("Money");
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                "Thank you!"
            ], FSP.MenuGrapher.deleteActiveMenu);
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for the beginning of the game introduction.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneIntroFadeIn = function (FSP, settings) {
            var oak = FSP.ObjectMaker.make("OakPortrait", {
                "opacity": 0
            });
            settings.oak = oak;
            console.warn("Cannot find Introduction audio theme!");
            // FSP.AudioPlayer.playTheme("Introduction");
            FSP.ModAttacher.fireEvent("onIntroFadeIn", oak);
            FSP.setMap("Blank", "White");
            FSP.MenuGrapher.deleteActiveMenu();
            FSP.addThing(oak);
            FSP.setMidX(oak, FSP.MapScreener.middleX | 0);
            FSP.setMidY(oak, FSP.MapScreener.middleY | 0);
            FSP.TimeHandler.addEvent(FSP.animateFadeAttribute, 70, oak, "opacity", .15, 1, 14, FSP.ScenePlayer.bindRoutine("FirstDialog"));
        };
        /**
         * Cutscene for Oak's introduction.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneIntroFirstDialog = function (FSP, settings) {
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                "Hello there! \n Welcome to the world of %%%%%%%POKEMON%%%%%%%!",
                "My name is OAK! People call me the %%%%%%%POKEMON%%%%%%% PROF!"
            ], FSP.ScenePlayer.bindRoutine("FirstDialogFade"));
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for Oak's introduction exit.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneIntroFirstDialogFade = function (FSP, settings) {
            var blank = FSP.ObjectMaker.make("WhiteSquare", {
                "width": FSP.MapScreener.width,
                "height": FSP.MapScreener.height,
                "opacity": 0
            });
            FSP.addThing(blank, 0, 0);
            FSP.TimeHandler.addEvent(FSP.animateFadeAttribute, 35, blank, "opacity", .15, 1, 7, FSP.ScenePlayer.bindRoutine("PokemonExpo"));
        };
        /**
         * Cutscene for transitioning Nidorino onto the screen.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneIntroPokemonExpo = function (FSP, settings) {
            var pokemon = FSP.ObjectMaker.make("NIDORINOFront", {
                "flipHoriz": true,
                "opacity": .01
            });
            FSP.GroupHolder.applyOnAll(FSP, FSP.killNormal);
            FSP.addThing(pokemon, (FSP.MapScreener.middleX + 24 * FSP.unitsize) | 0, 0);
            FSP.setMidY(pokemon, FSP.MapScreener.middleY);
            FSP.animateFadeAttribute(pokemon, "opacity", .15, 1, 3);
            FSP.animateSlideHorizontal(pokemon, -FSP.unitsize * 2, FSP.MapScreener.middleX | 0, 1, FSP.ScenePlayer.bindRoutine("PokemonExplanation"));
        };
        /**
         * Cutscene for showing an explanation of the Pokemon world.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneIntroPokemonExplanation = function (FSP, settings) {
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                "This world is inhabited by creatures called %%%%%%%POKEMON%%%%%%%!",
                "For some people, %%%%%%%POKEMON%%%%%%% are pets. Others use them for fights.",
                "Myself...",
                "I study %%%%%%%POKEMON%%%%%%% as a profession."
            ], FSP.ScenePlayer.bindRoutine("PlayerAppear"));
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene showing the player.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneIntroPlayerAppear = function (FSP, settings) {
            var middleX = FSP.MapScreener.middleX | 0, player = FSP.ObjectMaker.make("PlayerPortrait", {
                "flipHoriz": true,
                "opacity": .01
            });
            settings.player = player;
            FSP.GroupHolder.applyOnAll(FSP, FSP.killNormal);
            FSP.addThing(player, FSP.MapScreener.middleX + 24 * FSP.unitsize, 0);
            FSP.setMidY(player, FSP.MapScreener.middleY);
            FSP.animateFadeAttribute(player, "opacity", .15, 1, 3);
            FSP.animateSlideHorizontal(player, -FSP.unitsize * 2, middleX - player.width * FSP.unitsize / 2, 1, FSP.ScenePlayer.bindRoutine("PlayerName"));
        };
        /**
         * Cutscene asking the player to enter his/her name.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneIntroPlayerName = function (FSP, settings) {
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                "First, what is your name?"
            ], FSP.ScenePlayer.bindRoutine("PlayerSlide"));
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for sliding the player over to show the naming options.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneIntroPlayerSlide = function (FSP, settings) {
            FSP.animateSlideHorizontal(settings.player, FSP.unitsize, (FSP.MapScreener.middleX + 16 * FSP.unitsize) | 0, 1, FSP.ScenePlayer.bindRoutine("PlayerNameOptions"));
        };
        /**
         * Cutscene for showing the player naming option menu.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneIntroPlayerNameOptions = function (FSP, settings) {
            var fromMenu = FSP.ScenePlayer.bindRoutine("PlayerNameFromMenu"), fromKeyboard = FSP.ScenePlayer.bindRoutine("PlayerNameFromKeyboard");
            FSP.MenuGrapher.createMenu("NameOptions");
            FSP.MenuGrapher.addMenuList("NameOptions", {
                "options": [
                    {
                        "text": "NEW NAME".split(""),
                        "callback": FSP.openKeyboardMenu.bind(FSP, {
                            "title": "YOUR NAME?",
                            "callback": fromKeyboard
                        })
                    }, {
                        "text": "BLUE".split(""),
                        "callback": fromMenu
                    }, {
                        "text": "GARY".split(""),
                        "callback": fromMenu
                    }, {
                        "text": "JOHN".split(""),
                        "callback": fromMenu
                    }]
            });
            FSP.MenuGrapher.setActiveMenu("NameOptions");
        };
        /**
         * Cutscene for the player selecting Blue, Gary, or John.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneIntroPlayerNameFromMenu = function (FSP, settings) {
            settings.name = FSP.MenuGrapher.getMenuSelectedOption("NameOptions").text;
            FSP.MenuGrapher.deleteMenu("NameOptions");
            FSP.animateSlideHorizontal(settings.player, -FSP.unitsize, FSP.MapScreener.middleX | 0, 1, FSP.ScenePlayer.bindRoutine("PlayerNameConfirm"));
        };
        /**
         * Cutscene for the player choosing to customize a new name.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneIntroPlayerNameFromKeyboard = function (FSP, settings) {
            settings.name = FSP.MenuGrapher.getMenu("KeyboardResult").completeValue;
            FSP.MenuGrapher.deleteMenu("Keyboard");
            FSP.MenuGrapher.deleteMenu("NameOptions");
            FSP.animateSlideHorizontal(settings.player, -FSP.unitsize, FSP.MapScreener.middleX | 0, 1, FSP.ScenePlayer.bindRoutine("PlayerNameConfirm"));
        };
        /**
         * Cutscene confirming the player's name.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneIntroPlayerNameConfirm = function (FSP, settings) {
            FSP.ItemsHolder.setItem("name", settings.name);
            FSP.MenuGrapher.createMenu("GeneralText", {
                "finishAutomatically": true
            });
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                [
                    "Right! So your name is ".split(""),
                    settings.name,
                    "!".split("")
                ]
            ], FSP.ScenePlayer.bindRoutine("PlayerNameComplete"));
        };
        /**
         * Cutscene fading the player out.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneIntroPlayerNameComplete = function (FSP, settings) {
            var blank = FSP.ObjectMaker.make("WhiteSquare", {
                "width": FSP.MapScreener.width,
                "height": FSP.MapScreener.height,
                "opacity": 0
            });
            FSP.addThing(blank, 0, 0);
            FSP.TimeHandler.addEvent(FSP.animateFadeAttribute, 35, blank, "opacity", .2, 1, 7, FSP.ScenePlayer.bindRoutine("RivalAppear"));
        };
        /**
         * Cutscene for showing the rival.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneIntroRivalAppear = function (FSP, settings) {
            var rival = FSP.ObjectMaker.make("RivalPortrait", {
                "opacity": 0
            });
            settings.rival = rival;
            FSP.GroupHolder.applyOnAll(FSP, FSP.killNormal);
            FSP.addThing(rival, 0, 0);
            FSP.setMidX(rival, FSP.MapScreener.middleX | 0);
            FSP.setMidY(rival, FSP.MapScreener.middleY | 0);
            FSP.animateFadeAttribute(rival, "opacity", .1, 1, 1, FSP.ScenePlayer.bindRoutine("RivalName"));
        };
        /**
         * Cutscene introducing the rival.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneIntroRivalName = function (FSP, settings) {
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                "This is my grand-son. He's been your rival since you were a baby.",
                "...Erm, what is his name again?"
            ], FSP.ScenePlayer.bindRoutine("RivalSlide"));
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for sliding the rival over to show the rival naming options.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneIntroRivalSlide = function (FSP, settings) {
            FSP.animateSlideHorizontal(settings.rival, FSP.unitsize, (FSP.MapScreener.middleX + 16 * FSP.unitsize) | 0, 1, FSP.ScenePlayer.bindRoutine("RivalNameOptions"));
        };
        /**
         * Cutscene for showing the rival naming option menu.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneIntroRivalNameOptions = function (FSP, settings) {
            var fromMenu = FSP.ScenePlayer.bindRoutine("RivalNameFromMenu"), fromKeyboard = FSP.ScenePlayer.bindRoutine("RivalNameFromKeyboard");
            FSP.MenuGrapher.createMenu("NameOptions");
            FSP.MenuGrapher.addMenuList("NameOptions", {
                "options": [
                    {
                        "text": "NEW NAME",
                        "callback": FSP.openKeyboardMenu.bind(FSP, {
                            "title": "RIVAL's NAME?",
                            "callback": fromKeyboard
                        })
                    }, {
                        "text": "RED".split(""),
                        "callback": fromMenu
                    }, {
                        "text": "ASH".split(""),
                        "callback": fromMenu
                    }, {
                        "text": "JACK".split(""),
                        "callback": fromMenu
                    }]
            });
            FSP.MenuGrapher.setActiveMenu("NameOptions");
        };
        /**
         * Cutscene for choosing to name the rival Red, Ash, or Jack.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneIntroRivalNameFromMenu = function (FSP, settings) {
            settings.name = FSP.MenuGrapher.getMenuSelectedOption("NameOptions").text;
            FSP.MenuGrapher.deleteMenu("NameOptions");
            FSP.animateSlideHorizontal(settings.rival, -FSP.unitsize, FSP.MapScreener.middleX | 0, 1, FSP.ScenePlayer.bindRoutine("RivalNameConfirm"));
        };
        /**
         * Cutscene for choosing to customize the rival's name.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneIntroRivalNameFromKeyboard = function (FSP, settings) {
            settings.name = FSP.MenuGrapher.getMenu("KeyboardResult").completeValue;
            FSP.MenuGrapher.deleteMenu("Keyboard");
            FSP.MenuGrapher.deleteMenu("NameOptions");
            FSP.animateSlideHorizontal(settings.rival, -FSP.unitsize, FSP.MapScreener.middleX | 0, 1, FSP.ScenePlayer.bindRoutine("RivalNameConfirm"));
        };
        /**
         * Cutscene for confirming the rival's name.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneIntroRivalNameConfirm = function (FSP, settings) {
            FSP.ItemsHolder.setItem("nameRival", settings.name);
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                [
                    "That's right! I remember now! His name is ", settings.name, "!"
                ]
            ], FSP.ScenePlayer.bindRoutine("RivalNameComplete"));
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene fading the rival out.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneIntroRivalNameComplete = function (FSP, settings) {
            var blank = FSP.ObjectMaker.make("WhiteSquare", {
                "width": FSP.MapScreener.width,
                "height": FSP.MapScreener.height,
                "opacity": 0
            });
            FSP.addThing(blank, 0, 0);
            FSP.TimeHandler.addEvent(FSP.animateFadeAttribute, 35, blank, "opacity", .2, 1, 7, FSP.ScenePlayer.bindRoutine("LastDialogAppear"));
        };
        /**
         * Cutscene for fading the player in.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneIntroLastDialogAppear = function (FSP, settings) {
            var portrait = FSP.ObjectMaker.make("PlayerPortrait", {
                "flipHoriz": true,
                "opacity": 0
            });
            settings.portrait = portrait;
            FSP.GroupHolder.applyOnAll(FSP, FSP.killNormal);
            FSP.addThing(portrait, 0, 0);
            FSP.setMidX(portrait, FSP.MapScreener.middleX | 0);
            FSP.setMidY(portrait, FSP.MapScreener.middleY | 0);
            FSP.animateFadeAttribute(portrait, "opacity", .1, 1, 1, FSP.ScenePlayer.bindRoutine("LastDialog"));
        };
        /**
         * Cutscene for the last part of the introduction.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneIntroLastDialog = function (FSP, settings) {
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                "%%%%%%%PLAYER%%%%%%%!",
                "Your very own %%%%%%%POKEMON%%%%%%% legend is about to unfold!",
                "A world of dreams and adventures with %%%%%%%POKEMON%%%%%%% awaits! Let's go!"
            ], FSP.ScenePlayer.bindRoutine("ShrinkPlayer"));
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for shrinking the player.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneIntroShrinkPlayer = function (FSP, settings) {
            var silhouetteLarge = FSP.ObjectMaker.make("PlayerSilhouetteLarge"), silhouetteSmall = FSP.ObjectMaker.make("PlayerSilhouetteSmall"), player = FSP.ObjectMaker.make("Player"), timeDelay = 49;
            FSP.TimeHandler.addEvent(FSP.addThing, timeDelay, silhouetteLarge);
            FSP.TimeHandler.addEvent(FSP.setMidObj, timeDelay, silhouetteLarge, settings.portrait);
            FSP.TimeHandler.addEvent(FSP.killNormal, timeDelay, settings.portrait);
            FSP.TimeHandler.addEvent(FSP.addThing, timeDelay * 2, silhouetteSmall);
            FSP.TimeHandler.addEvent(FSP.setMidObj, timeDelay * 2, silhouetteSmall, silhouetteLarge);
            FSP.TimeHandler.addEvent(FSP.killNormal, timeDelay * 2, silhouetteLarge);
            FSP.TimeHandler.addEvent(FSP.addThing, timeDelay * 3, player);
            FSP.TimeHandler.addEvent(FSP.setMidObj, timeDelay * 3, player, silhouetteSmall);
            FSP.TimeHandler.addEvent(FSP.killNormal, timeDelay * 3, silhouetteSmall);
            FSP.TimeHandler.addEvent(FSP.ScenePlayer.bindRoutine("FadeOut"), timeDelay * 4);
        };
        /**
         * Cutscene for completing the introduction and fading it out.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneIntroFadeOut = function (FSP, settings) {
            var blank = FSP.ObjectMaker.make("WhiteSquare", {
                "width": FSP.MapScreener.width,
                "height": FSP.MapScreener.height,
                "opacity": 0
            });
            FSP.addThing(blank, 0, 0);
            FSP.TimeHandler.addEvent(FSP.animateFadeAttribute, 35, blank, "opacity", .2, 1, 7, FSP.ScenePlayer.bindRoutine("Finish"));
        };
        /**
         * Cutscene showing the player in his bedroom.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneIntroFinish = function (FSP, settings) {
            delete FSP.MapScreener.cutscene;
            FSP.MenuGrapher.deleteActiveMenu();
            FSP.ScenePlayer.stopCutscene();
            FSP.ItemsHolder.setItem("gameStarted", true);
            FSP.setMap("Pallet Town", "Start Game");
        };
        /**
         * Cutscene for walking into the grass before receiving a Pokemon.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneOakIntroFirstDialog = function (FSP, settings) {
            var triggered = false;
            settings.triggerer.alive = false;
            FSP.StateHolder.addChange(settings.triggerer.id, "alive", false);
            if (FSP.ItemsHolder.getItem("starter")) {
                FSP.MapScreener.blockInputs = false;
                return;
            }
            FSP.animatePlayerDialogFreeze(settings.player);
            FSP.animateCharacterSetDirection(settings.player, 2);
            FSP.AudioPlayer.playTheme("Professor Oak");
            FSP.MapScreener.blockInputs = true;
            FSP.MenuGrapher.createMenu("GeneralText", {
                "finishAutomatically": true,
                "finishAutomaticSpeed": 28
            });
            FSP.MenuGrapher.addMenuDialog("GeneralText", "OAK: Hey! Wait! Don't go out!", function () {
                if (!triggered) {
                    triggered = true;
                    FSP.ScenePlayer.playRoutine("Exclamation");
                }
            });
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene showing the exclamation point over the player's head.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneOakIntroExclamation = function (FSP, settings) {
            var timeout = 49;
            FSP.animateExclamation(settings.player, timeout);
            FSP.TimeHandler.addEvent(FSP.MenuGrapher.hideMenu.bind(FSP.MenuGrapher), timeout, "GeneralText");
            FSP.TimeHandler.addEvent(FSP.ScenePlayer.bindRoutine("Catchup"), timeout);
        };
        /**
         * Cutscene for animating Oak to walk to the player.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneOakIntroCatchup = function (FSP, settings) {
            var door = FSP.getThingById("Oak's Lab Door"), oak = FSP.ObjectMaker.make("Oak", {
                "outerok": true,
                "nocollide": true
            }), isToLeft = FSP.player.bordering[Direction.Left] !== undefined, walkingSteps = [
                1, "left", 4, "top", 8, "right", 1, "top", 1, "right", 1, "top", 1
            ];
            if (!isToLeft) {
                walkingSteps.push("right", 1, "top", 0);
            }
            walkingSteps.push(FSP.ScenePlayer.bindRoutine("GrassWarning"));
            settings.oak = oak;
            settings.isToLeft = isToLeft;
            FSP.addThing(oak, door.left, door.top);
            FSP.animateCharacterStartWalkingCycle(oak, 2, walkingSteps);
        };
        /**
         * Cutscene for Oak telling the player to keep out of the grass.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneOakIntroGrassWarning = function (FSP, settings) {
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                "It's unsafe! Wild %%%%%%%POKEMON%%%%%%% live in tall grass!",
                "You need your own %%%%%%%POKEMON%%%%%%% for your protection. \n I know!",
                "Here, come with me."
            ], FSP.ScenePlayer.bindRoutine("FollowToLab"));
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for the player following Oak to the Professor's lab.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneOakIntroFollowToLab = function (FSP, settings) {
            var startingDirection, walkingSteps;
            if (settings.isToLeft) {
                startingDirection = Direction.Bottom;
                walkingSteps = [5, "left", 1, "bottom", 5, "right", 3, "top", 1];
            }
            else {
                startingDirection = Direction.Left;
                walkingSteps = [1, "bottom", 5, "left", 1, "bottom", 5, "right", 3, "top", 1];
            }
            walkingSteps.push(FSP.ScenePlayer.bindRoutine("EnterLab"));
            FSP.MenuGrapher.deleteMenu("GeneralText");
            FSP.animateCharacterFollow(settings.player, settings.oak);
            FSP.animateCharacterStartWalkingCycle(settings.oak, startingDirection, walkingSteps);
        };
        /**
         * Cutscene for entering Oak's lab.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneOakIntroEnterLab = function (FSP, settings) {
            FSP.StateHolder.addChange("Pallet Town::Oak's Lab::Oak", "alive", true);
            settings.oak.hidden = true;
            FSP.TimeHandler.addEvent(FSP.animateCharacterStartWalkingCycle, FSP.getCharacterWalkingInterval(FSP.player), FSP.player, 0, [
                0,
                function () {
                    FSP.setMap("Pallet Town", "Oak's Lab Floor 1 Door", false);
                    FSP.player.hidden = true;
                    FSP.ScenePlayer.playRoutine("WalkToTable");
                }
            ]);
        };
        /**
         * Cutscene for Oak offering a Pokemon to the player.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneOakIntroWalkToTable = function (FSP, settings) {
            var oak = FSP.getThingById("Oak"), rival = FSP.getThingById("Rival");
            settings.oak = oak;
            settings.player = FSP.player;
            oak.dialog = "OAK: Now, %%%%%%%PLAYER%%%%%%%, which %%%%%%%POKEMON%%%%%%% do you want?";
            oak.hidden = false;
            oak.nocollide = true;
            FSP.setMidXObj(oak, settings.player);
            FSP.setBottom(oak, settings.player.top);
            FSP.StateHolder.addChange(oak.id, "hidden", false);
            FSP.StateHolder.addChange(oak.id, "nocollide", false);
            FSP.StateHolder.addChange(oak.id, "dialog", oak.dialog);
            rival.dialog = [
                "%%%%%%%RIVAL%%%%%%%: Heh, I don't need to be greedy like you!",
                "Go ahead and choose, %%%%%%%PLAYER%%%%%%%!"
            ];
            FSP.StateHolder.addChange(rival.id, "dialog", rival.dialog);
            FSP.animateCharacterStartWalking(oak, 0, [
                8, "bottom", 0
            ]);
            FSP.TimeHandler.addEvent(function () {
                FSP.player.hidden = false;
            }, 112 - FSP.getCharacterWalkingInterval(settings.player));
            FSP.TimeHandler.addEvent(function () {
                FSP.animateCharacterStartWalking(settings.player, 0, [8, FSP.ScenePlayer.bindRoutine("RivalComplain")]);
            }, 112);
        };
        /**
         * Cutscene for the rival complaining to Oak.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneOakIntroRivalComplain = function (FSP, settings) {
            settings.oak.nocollide = false;
            settings.player.nocollide = false;
            FSP.StateHolder.addChange(settings.oak.id, "nocollide", false);
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", "%%%%%%%RIVAL%%%%%%%: Gramps! I'm fed up with waiting!", FSP.ScenePlayer.bindRoutine("OakThinksToRival"));
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for Oak telling the player to pick a Pokemon.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneOakIntroOakThinksToRival = function (FSP, settings) {
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                "OAK: %%%%%%%RIVAL%%%%%%%? Let me think...",
                "Oh, that's right, I told you to come! Just wait!",
                "Here, %%%%%%%PLAYER%%%%%%%!",
                "There are 3 %%%%%%%POKEMON%%%%%%% here!",
                "Haha!",
                "They are inside the %%%%%%%POKE%%%%%%% BALLs.",
                "When I was young, I was a serious %%%%%%%POKEMON%%%%%%% trainer!",
                "In my old age, I have only 3 left, but you can have one! Choose!"
            ], FSP.ScenePlayer.bindRoutine("RivalProtests"));
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for the rival protesting to Oak.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneOakIntroRivalProtests = function (FSP, settings) {
            var timeout = 21;
            FSP.MenuGrapher.deleteMenu("GeneralText");
            FSP.TimeHandler.addEvent(FSP.MenuGrapher.createMenu.bind(FSP.MenuGrapher), timeout, "GeneralText");
            FSP.TimeHandler.addEvent(FSP.MenuGrapher.addMenuDialog.bind(FSP.MenuGrapher), timeout, "GeneralText", [
                "%%%%%%%RIVAL%%%%%%%: Hey! Gramps! What about me?"
            ], FSP.ScenePlayer.bindRoutine("OakRespondsToProtest"));
            FSP.TimeHandler.addEvent(FSP.MenuGrapher.setActiveMenu.bind(FSP.MenuGrapher), timeout, "GeneralText");
        };
        /**
         * Cutscene for Oak responding to the rival's protest.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneOakIntroOakRespondsToProtest = function (FSP, settings) {
            var blocker = FSP.getThingById("OakBlocker"), timeout = 21;
            settings.player.nocollide = false;
            settings.oak.nocollide = false;
            blocker.nocollide = false;
            FSP.StateHolder.addChange(blocker.id, "nocollide", false);
            FSP.MapScreener.blockInputs = false;
            FSP.MenuGrapher.deleteMenu("GeneralText");
            FSP.TimeHandler.addEvent(FSP.MenuGrapher.createMenu.bind(FSP.MenuGrapher), timeout, "GeneralText", {
                "deleteOnFinish": true
            });
            FSP.TimeHandler.addEvent(FSP.MenuGrapher.addMenuDialog.bind(FSP.MenuGrapher), timeout, "GeneralText", "Oak: Be patient! %%%%%%%RIVAL%%%%%%%, you can have one too!");
            FSP.TimeHandler.addEvent(FSP.MenuGrapher.setActiveMenu.bind(FSP.MenuGrapher), timeout, "GeneralText");
        };
        /**
         * Cutscene for the player checking a Pokeball.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneOakIntroPokemonChoicePlayerChecksPokeball = function (FSP, settings) {
            var pokeball = settings.triggerer;
            // If Oak is hidden, this cutscene shouldn't be starting (too early)
            if (FSP.getThingById("Oak").hidden) {
                FSP.ScenePlayer.stopCutscene();
                FSP.MenuGrapher.createMenu("GeneralText");
                FSP.MenuGrapher.addMenuDialog("GeneralText", [
                    "Those are %%%%%%%POKE%%%%%%% Balls. They contain %%%%%%%POKEMON%%%%%%%!"
                ]);
                FSP.MenuGrapher.setActiveMenu("GeneralText");
                return;
            }
            // If there's already a starter, ignore this sad last ball...
            if (FSP.ItemsHolder.getItem("starter")) {
                return;
            }
            settings.chosen = pokeball.pokemon;
            FSP.openPokedexListing(pokeball.pokemon, FSP.ScenePlayer.bindRoutine("PlayerDecidesPokemon"), {
                "position": {
                    "vertical": "center",
                    "offset": {
                        "left": 0
                    }
                }
            });
        };
        /**
         * Cutscene for confirming the player wants to keep the chosen Pokemon.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneOakIntroPokemonChoicePlayerDecidesPokemon = function (FSP, settings) {
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                [
                    "So! You want the " + settings.triggerer.description + " %%%%%%%POKEMON%%%%%%%, ", settings.chosen, "?"
                ]
            ], function () {
                FSP.MenuGrapher.createMenu("Yes/No", {
                    "killOnB": ["GeneralText"]
                });
                FSP.MenuGrapher.addMenuList("Yes/No", {
                    "options": [
                        {
                            "text": "YES",
                            "callback": FSP.ScenePlayer.bindRoutine("PlayerTakesPokemon")
                        }, {
                            "text": "NO",
                            "callback": FSP.MenuGrapher.registerB
                        }]
                });
                FSP.MenuGrapher.setActiveMenu("Yes/No");
            });
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for the player receiving his Pokemon.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneOakIntroPokemonChoicePlayerTakesPokemon = function (FSP, settings) {
            var oak = FSP.getThingById("Oak"), rival = FSP.getThingById("Rival"), dialogOak = "Oak: If a wild %%%%%%%POKEMON%%%%%%% appears, your %%%%%%%POKEMON%%%%%%% can fight against it!", dialogRival = "%%%%%%%RIVAL%%%%%%%: My %%%%%%%POKEMON%%%%%%% looks a lot stronger.";
            settings.oak = oak;
            oak.dialog = dialogOak;
            FSP.StateHolder.addChange(oak.id, "dialog", dialogOak);
            settings.rival = rival;
            rival.dialog = dialogRival;
            FSP.StateHolder.addChange(rival.id, "dialog", dialogRival);
            FSP.ItemsHolder.setItem("starter", settings.chosen.join(""));
            settings.triggerer.hidden = true;
            FSP.StateHolder.addChange(settings.triggerer.id, "hidden", true);
            FSP.StateHolder.addChange(settings.triggerer.id, "nocollide", true);
            FSP.MenuGrapher.deleteMenu("Yes/No");
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                [
                    "%%%%%%%PLAYER%%%%%%% received a ", settings.chosen, "!"
                ],
                "This %%%%%%%POKEMON%%%%%%% is really energetic!",
                [
                    "Do you want to give a nickname to ", settings.chosen, "?"
                ]
            ], FSP.ScenePlayer.bindRoutine("PlayerChoosesNickname"));
            FSP.MenuGrapher.setActiveMenu("GeneralText");
            FSP.ItemsHolder.setItem("starter", settings.chosen);
            FSP.ItemsHolder.setItem("PokemonInParty", [
                FSP.MathDecider.compute("newPokemon", settings.chosen, 5)
            ]);
            FSP.addPokemonToPokedex(FSP, settings.chosen, PokedexListingStatus.Caught);
        };
        /**
         * Cutscene for allowing the player to choose his Pokemon's nickname.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneOakIntroPokemonChoicePlayerChoosesNickname = function (FSP, settings) {
            FSP.MenuGrapher.createMenu("Yes/No", {
                "ignoreB": true,
                "killOnB": ["GeneralText"]
            });
            FSP.MenuGrapher.addMenuList("Yes/No", {
                "options": [
                    {
                        "text": "YES",
                        "callback": FSP.openKeyboardMenu.bind(FSP, {
                            "position": {
                                "vertical": "center",
                                "offset": {
                                    "top": -12
                                }
                            },
                            "title": settings.chosen,
                            "callback": FSP.ScenePlayer.bindRoutine("PlayerSetsNickname")
                        })
                    }, {
                        "text": "NO",
                        "callback": FSP.ScenePlayer.bindRoutine("RivalWalksToPokemon")
                    }]
            });
            FSP.MenuGrapher.setActiveMenu("Yes/No");
        };
        /**
         * Cutscene for the player finishing the naming process.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneOakIntroPokemonChoicePlayerSetsNickname = function (FSP, settings) {
            var party = FSP.ItemsHolder.getItem("PokemonInParty"), menu = FSP.MenuGrapher.getMenu("KeyboardResult"), result = menu.completeValue;
            party[0].nickname = result;
            FSP.ScenePlayer.playRoutine("RivalWalksToPokemon");
        };
        /**
         * Cutscene for the rival selecting his Pokemon.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneOakIntroPokemonChoiceRivalWalksToPokemon = function (FSP, settings) {
            var rival = FSP.getThingById("Rival"), starterRival, steps, pokeball;
            FSP.MenuGrapher.deleteMenu("Keyboard");
            FSP.MenuGrapher.deleteMenu("GeneralText");
            FSP.MenuGrapher.deleteMenu("Yes/No");
            switch (settings.chosen.join("")) {
                case "SQUIRTLE":
                    steps = 4;
                    starterRival = "BULBASAUR".split("");
                    break;
                case "CHARMANDER":
                    steps = 3;
                    starterRival = "SQUIRTLE".split("");
                    break;
                case "BULBASAUR":
                    steps = 2;
                    starterRival = "CHARMANDER".split("");
                    break;
                default:
                    throw new Error("Unknown first Pokemon.");
            }
            settings.rivalPokemon = starterRival;
            settings.rivalSteps = steps;
            FSP.ItemsHolder.setItem("starterRival", starterRival);
            FSP.addPokemonToPokedex(FSP, starterRival, PokedexListingStatus.Caught);
            pokeball = FSP.getThingById("Pokeball" + starterRival.join(""));
            settings.rivalPokeball = pokeball;
            FSP.animateCharacterStartWalkingCycle(rival, 2, [
                2, "right", steps, "top", 1,
                function () { return FSP.ScenePlayer.playRoutine("RivalTakesPokemon"); }
            ]);
        };
        /**
         * Cutscene for the rival receiving his Pokemon.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneOakIntroPokemonChoiceRivalTakesPokemon = function (FSP, settings) {
            var oakblocker = FSP.getThingById("OakBlocker"), rivalblocker = FSP.getThingById("RivalBlocker");
            FSP.MenuGrapher.deleteMenu("Yes/No");
            oakblocker.nocollide = true;
            FSP.StateHolder.addChange(oakblocker.id, "nocollide", true);
            rivalblocker.nocollide = false;
            FSP.StateHolder.addChange(rivalblocker.id, "nocollide", false);
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                "%%%%%%%RIVAL%%%%%%%: I'll take this one, then!",
                [
                    "%%%%%%%RIVAL%%%%%%% received a ", settings.rivalPokemon, "!"
                ]
            ], function () {
                settings.rivalPokeball.hidden = true;
                FSP.StateHolder.addChange(settings.rivalPokeball.id, "hidden", true);
                FSP.MenuGrapher.deleteActiveMenu();
            });
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for the rival challenging the player to a Pokemon battle.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneOakIntroRivalBattleApproach = function (FSP, settings) {
            var rival = FSP.getThingById("Rival"), dx = Math.abs(settings.triggerer.left - settings.player.left), further = dx < FSP.unitsize;
            FSP.AudioPlayer.playTheme("Rival Appears");
            settings.rival = rival;
            FSP.animateCharacterSetDirection(rival, Direction.Bottom);
            FSP.animateCharacterSetDirection(settings.player, Direction.Top);
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                "%%%%%%%RIVAL%%%%%%%: Wait, %%%%%%%PLAYER%%%%%%%! Let's check out our %%%%%%%POKEMON%%%%%%%!",
                "Come on, I'll take you on!"
            ], FSP.ScenePlayer.bindRoutine("Challenge", {
                "further": further
            }));
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for showing the lab after the battle ends.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneOakIntroRivalLeavesAfterBattle = function (FSP, settings) {
            FSP.MapScreener.blockInputs = true;
            FSP.ItemsHolder.getItem("PokemonInParty").forEach(FSP.healPokemon.bind(FSP));
            FSP.TimeHandler.addEvent(FSP.ScenePlayer.bindRoutine("Complaint"), 49);
        };
        /**
         * Cutscene for the rival's comment after losing the battle.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneOakIntroRivalLeavesComplaint = function (FSP, settings) {
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                "%%%%%%%RIVAL%%%%%%%: Okay! I'll make my %%%%%%%POKEMON%%%%%%% fight to toughen it up!"
            ], function () {
                FSP.MenuGrapher.deleteActiveMenu();
                FSP.TimeHandler.addEvent(FSP.ScenePlayer.bindRoutine("Goodbye"), 21);
            });
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for the rival telling Oak he is leaving.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneOakIntroRivalLeavesGoodbye = function (FSP, settings) {
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                "%%%%%%%PLAYER%%%%%%%! Gramps! Smell ya later!"
            ], FSP.ScenePlayer.bindRoutine("Walking"));
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for the rival leaving the lab and Oak giving the player advice.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneOakIntroRivalLeavesWalking = function (FSP, settings) {
            var oak = FSP.getThingById("Oak"), rival = FSP.getThingById("Rival"), isRight = Math.abs(oak.left - rival.left) < FSP.unitsize, steps = [
                1,
                "bottom",
                6,
                function () {
                    FSP.killNormal(rival);
                    FSP.StateHolder.addChange(rival.id, "alive", false);
                    FSP.MapScreener.blockInputs = false;
                }
            ], dialog = [
                "OAK: %%%%%%%PLAYER%%%%%%%, raise your young %%%%%%%POKEMON%%%%%%% by making it fight!"
            ];
            console.log("Shouldn't this say the dialog?", dialog);
            FSP.ScenePlayer.stopCutscene();
            FSP.MenuGrapher.deleteMenu("GeneralText");
            rival.nocollide = true;
            FSP.animateCharacterStartWalkingCycle(rival, isRight ? Direction.Left : Direction.Right, steps);
        };
        /**
         * Cutscene for the battle between the player and the rival.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         * @param args   Settings for the routine.
         */
        FullScreenPokemon.prototype.cutsceneOakIntroRivalBattleChallenge = function (FSP, settings, args) {
            var steps, starterRival = FSP.ItemsHolder.getItem("starterRival"), battleInfo = {
                "opponent": {
                    "sprite": "RivalPortrait",
                    "name": FSP.ItemsHolder.getItem("nameRival"),
                    "category": "Trainer",
                    "hasActors": true,
                    "reward": 175,
                    "actors": [
                        FSP.MathDecider.compute("newPokemon", starterRival, 5)
                    ]
                },
                "textStart": ["", " wants to fight!"],
                "textDefeat": ["%%%%%%%RIVAL%%%%%%% Yeah! Am I great or what?"],
                "textVictory": [
                    [
                        "%%%%%%%RIVAL%%%%%%%: WHAT?",
                        "Unbelievable!",
                        "I picked the wrong %%%%%%%POKEMON%%%%%%%!"
                    ].join(" ")
                ],
                // "animation": "LineSpiral",
                "noBlackout": true,
                "keptThings": FSP.collectBattleKeptThings(FSP, ["player", "Rival"]),
                "nextCutscene": "OakIntroRivalLeaves"
            };
            switch (FSP.ItemsHolder.getItem("starterRival").join("")) {
                case "SQUIRTLE":
                    steps = 2;
                    break;
                case "BULBASAUR":
                    steps = 3;
                    break;
                case "CHARMANDER":
                    steps = 1;
                    break;
                default:
                    throw new Error("Unknown starterRival.");
            }
            if (args.further) {
                steps += 1;
            }
            FSP.animateCharacterStartWalkingCycle(settings.rival, 3, [
                steps,
                "bottom",
                1,
                FSP.startBattle.bind(FSP, battleInfo)
            ]);
        };
        /**
         * Cutscene for the PokeMart clerk calling the player to pick up Oak's parcel.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneOakParcelPickupGreeting = function (FSP, settings) {
            settings.triggerer.alive = false;
            FSP.StateHolder.addChange(settings.triggerer.id, "alive", false);
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                "Hey! You came from PALLET TOWN?"
            ], FSP.ScenePlayer.bindRoutine("WalkToCounter"));
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for the player walking to the counter when picking up the parcel.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneOakParcelPickupWalkToCounter = function (FSP, settings) {
            FSP.animateCharacterStartWalkingCycle(settings.player, 0, [
                2,
                "left",
                1,
                FSP.ScenePlayer.bindRoutine("CounterDialog")
            ]);
        };
        /**
         * Cutscene for the player receiving the parcel from the PokeMart clerk.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneOakParcelPickupCounterDialog = function (FSP, settings) {
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                "You know PROF. Oak, right?",
                "His order came in. Will you take it to him?",
                "%%%%%%%PLAYER%%%%%%% got OAK's PARCEL!"
            ], function () {
                FSP.MenuGrapher.deleteMenu("GeneralText");
                FSP.ScenePlayer.stopCutscene();
                FSP.MapScreener.blockInputs = false;
            });
            FSP.MenuGrapher.setActiveMenu("GeneralText");
            FSP.StateHolder.addCollectionChange("Pallet Town::Oak's Lab", "Oak", "cutscene", "OakParcelDelivery");
        };
        /**
         * Cutscene for when the player delivers the parcel to Oak.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneOakParcelDeliveryGreeting = function (FSP, settings) {
            settings.rival = FSP.getThingById("Rival");
            settings.oak = settings.triggerer;
            delete settings.oak.cutscene;
            delete settings.oak.dialog;
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                "OAK: Oh, %%%%%%%PLAYER%%%%%%%!",
                "How is my old %%%%%%%POKEMON%%%%%%%?",
                "Well, it seems to like you a lot.",
                "You must be talented as a %%%%%%%POKEMON%%%%%%% trainer!",
                "What? You have something for me?",
                "%%%%%%%PLAYER%%%%%%% delivered OAK's PARCEL.",
                "Ah! This is the custom %%%%%%%POKE%%%%%%% BALL I ordered! Thank you!"
            ], FSP.TimeHandler.addEvent.bind(FSP.TimeHandler, FSP.ScenePlayer.bindRoutine("RivalInterrupts"), 14));
            FSP.MenuGrapher.setActiveMenu("GeneralText");
            FSP.StateHolder.addCollectionChange("Viridian City::PokeMart", "CashierDetector", "dialog", false);
            FSP.StateHolder.addCollectionChange("Viridian City::Land", "CrankyGrandpa", "alive", false);
            FSP.StateHolder.addCollectionChange("Viridian City::Land", "CrankyGrandpaBlocker", "alive", false);
            FSP.StateHolder.addCollectionChange("Viridian City::Land", "CrankyGranddaughter", "alive", false);
            FSP.StateHolder.addCollectionChange("Viridian City::Land", "HappyGrandpa", "alive", true);
            FSP.StateHolder.addCollectionChange("Viridian City::Land", "HappyGranddaughter", "alive", true);
        };
        /**
         * Cutscene for when the rival interrupts Oak and the player.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneOakParcelDeliveryRivalInterrupts = function (FSP, settings) {
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                "%%%%%%%RIVAL%%%%%%%: Gramps!"
            ], FSP.ScenePlayer.bindRoutine("RivalWalksUp"));
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for the rival walking up to Oak and the player.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneOakParcelDeliveryRivalWalksUp = function (FSP, settings) {
            var doormat = FSP.getThingById("DoormatLeft"), rival = FSP.addThing("Rival", doormat.left, doormat.top);
            rival.alive = true;
            settings.rival = rival;
            FSP.MenuGrapher.deleteMenu("GeneralText");
            FSP.animateCharacterStartWalkingCycle(rival, 0, [
                8,
                function () { return FSP.ScenePlayer.playRoutine("RivalInquires"); }
            ]);
        };
        /**
         * Cutscene for the rival asking Oak why he was called.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneOakParcelDeliveryRivalInquires = function (FSP, settings) {
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                "%%%%%%%RIVAL%%%%%%%: What did you call me for?"
            ], FSP.TimeHandler.addEvent.bind(FSP.TimeHandler, FSP.ScenePlayer.bindRoutine("OakRequests"), 14));
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for Oak requesting something of the player and rival.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneOakParcelDeliveryOakRequests = function (FSP, settings) {
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                "Oak: Oh right! I have a request of you two."
            ], FSP.TimeHandler.addEvent.bind(FSP.TimeHandler, FSP.ScenePlayer.bindRoutine("OakDescribesPokedex"), 14));
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for Oak describing the Pokedex.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneOakParcelDeliveryOakDescribesPokedex = function (FSP, settings) {
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                "On the desk there is my invention, %%%%%%%POKEDEX%%%%%%%!",
                "It automatically records data on %%%%%%%POKEMON%%%%%%% you've seen or caught!",
                "It's a hi-tech encyclopedia!"
            ], FSP.TimeHandler.addEvent.bind(FSP.TimeHandler, FSP.ScenePlayer.bindRoutine("OakGivesPokedex"), 14));
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for Oak giving the player and rival Pokedexes.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneOakParcelDeliveryOakGivesPokedex = function (FSP, settings) {
            var bookLeft = FSP.getThingById("BookLeft"), bookRight = FSP.getThingById("BookRight");
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                "OAK: %%%%%%%PLAYER%%%%%%% and %%%%%%%RIVAL%%%%%%%! Take these with you!",
                "%%%%%%%PLAYER%%%%%%% got %%%%%%%POKEDEX%%%%%%% from OAK!"
            ], function () {
                FSP.TimeHandler.addEvent(FSP.ScenePlayer.playRoutine.bind(FSP.ScenePlayer), 14, "OakDescribesGoal");
                FSP.killNormal(bookLeft);
                FSP.killNormal(bookRight);
                FSP.StateHolder.addChange(bookLeft.id, "alive", false);
                FSP.StateHolder.addChange(bookRight.id, "alive", false);
                FSP.ItemsHolder.setItem("hasPokedex", true);
            });
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for Oak describing his life goal.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneOakParcelDeliveryOakDescribesGoal = function (FSP, settings) {
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                "To make a complete guide on all the %%%%%%%POKEMON%%%%%%% in the world...",
                "That was my dream!",
                "But, I'm too old! I can't do it!",
                "So, I want you two to fulfill my dream for me!",
                "Get moving, you two!",
                "This is a great undertaking in %%%%%%%POKEMON%%%%%%% history!"
            ], FSP.TimeHandler.addEvent.bind(FSP.TimeHandler, FSP.ScenePlayer.bindRoutine("RivalAccepts"), 14));
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for the rival accepting the Pokedex and challenge to complete Oak's goal.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneOakParcelDeliveryRivalAccepts = function (FSP, settings) {
            FSP.animateCharacterSetDirection(settings.rival, 1);
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                "%%%%%%%RIVAL%%%%%%%: Alright Gramps! Leave it all to me!",
                "%%%%%%%PLAYER%%%%%%%, I hate to say it, but I don't need you!",
                "I know! I'll borrow a TOWN MAP from my sis!",
                "I'll tell her not to lend you one, %%%%%%%PLAYER%%%%%%%! Hahaha!"
            ], function () {
                FSP.ScenePlayer.stopCutscene();
                FSP.MenuGrapher.deleteMenu("GeneralText");
                delete settings.oak.activate;
                settings.rival.nocollide = true;
                FSP.animateCharacterStartWalkingCycle(settings.rival, 2, [
                    8,
                    function () {
                        FSP.killNormal(settings.rival);
                        FSP.player.canKeyWalking = true;
                    }
                ]);
                delete settings.oak.cutscene;
                settings.oak.dialog = [
                    "%%%%%%%POKEMON%%%%%%% around the world wait for you, %%%%%%%PLAYER%%%%%%%!"
                ];
                FSP.StateHolder.addChange(settings.oak.id, "dialog", settings.oak.dialog);
                FSP.StateHolder.addChange(settings.oak.id, "cutscene", undefined);
            });
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for Daisy giving the player a Town Map.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneDaisyTownMapGreeting = function (FSP, settings) {
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                "Grandpa asked you to run an errand? Here, this will help you!"
            ], FSP.ScenePlayer.bindRoutine("ReceiveMap"));
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /**
         * Cutscene for the player receiving the Town Map.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneDaisyTownMapReceiveMap = function (FSP, settings) {
            var book = FSP.getThingById("Book"), daisy = settings.triggerer;
            FSP.killNormal(book);
            FSP.StateHolder.addChange(book.id, "alive", false);
            delete daisy.cutscene;
            FSP.StateHolder.addChange(daisy.id, "cutscene", undefined);
            daisy.dialog = [
                "Use the TOWN MAP to find out where you are."
            ];
            FSP.StateHolder.addChange(daisy.id, "dialog", daisy.dialog);
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                "%%%%%%%PLAYER%%%%%%% got a TOWN MAP!"
            ], function () {
                FSP.ScenePlayer.stopCutscene();
                FSP.MenuGrapher.deleteMenu("GeneralText");
            });
            FSP.MenuGrapher.setActiveMenu("GeneralText");
            console.warn("Player does not actually get a Town Map...");
        };
        /**
         * Cutscene for the old man battling a Weedle.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneElderTrainingStartBattle = function (FSP, settings) {
            FSP.MapScreener.blockInputs = true;
            FSP.startBattle({
                "keptThings": FSP.collectBattleKeptThings(FSP, [settings.player, settings.triggerer]),
                "player": {
                    "name": "OLD MAN".split(""),
                    "sprite": "ElderBack",
                    "category": "Wild",
                    "actors": []
                },
                "opponent": {
                    "name": "WEEDLE".split(""),
                    "sprite": "WeedleFront",
                    "category": "Wild",
                    "actors": [
                        FSP.MathDecider.compute("newPokemon", "WEEDLE".split(""), 5)
                    ]
                },
                "items": [{
                        "item": "Pokeball",
                        "amount": 50
                    }],
                "automaticMenus": true,
                "onShowPlayerMenu": function () {
                    var timeout = 70;
                    FSP.TimeHandler.addEvent(FSP.MenuGrapher.registerDown.bind(FSP.MenuGrapher), timeout);
                    FSP.TimeHandler.addEvent(FSP.MenuGrapher.registerA.bind(FSP.MenuGrapher), timeout * 2);
                    FSP.TimeHandler.addEvent(FSP.MenuGrapher.registerA.bind(FSP.MenuGrapher), timeout * 3);
                }
            });
        };
        /**
         * Cutscene for encountering the rival on Route 22.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneRivalRoute22RivalEmerges = function (FSP, settings) {
            var player = settings.player, triggerer = settings.triggerer, playerUpper = Number(Math.abs(player.top - triggerer.top) < FSP.unitsize), steps = [
                2,
                "right",
                3 + playerUpper,
            ], rival = FSP.ObjectMaker.make("Rival", {
                "direction": 0,
                "nocollide": true,
                "opacity": 0
            });
            if (playerUpper) {
                steps.push("top");
                steps.push(0);
            }
            settings.rival = rival;
            steps.push(FSP.ScenePlayer.bindRoutine("RivalTalks"));
            // thing, attribute, change, goal, speed, onCompletion
            FSP.animateFadeAttribute(rival, "opacity", .2, 1, 3);
            FSP.addThing(rival, triggerer.left - FSP.unitsize * 28, triggerer.top + FSP.unitsize * 24);
            FSP.animateCharacterStartWalkingCycle(rival, 0, steps);
        };
        /**
         * Cutscene for the rival talking to the player before the battle.
         *
         * @param FSP
         * @param settings   Settings used for the cutscene.
         */
        FullScreenPokemon.prototype.cutsceneRivalRoute22RivalTalks = function (FSP, settings) {
            var rivalTitle = FSP.ItemsHolder.getItem("starterRival");
            FSP.animateCharacterSetDirection(settings.player, FSP.getDirectionBordering(settings.player, settings.rival));
            FSP.MenuGrapher.createMenu("GeneralText");
            FSP.MenuGrapher.addMenuDialog("GeneralText", [
                "%%%%%%%RIVAL%%%%%%%: Hey! %%%%%%%PLAYER%%%%%%%!",
                "You're going to %%%%%%%POKEMON%%%%%%% LEAGUE?",
                "Forget it! You probably don't have any BADGES!",
                "The guard won't let you through!",
                "By the way did your %%%%%%%POKEMON%%%%%%% get any stronger?"
            ], FSP.startBattle.bind(FSP, {
                "opponent": {
                    "sprite": "RivalPortrait",
                    "name": FSP.ItemsHolder.getItem("nameRival"),
                    "category": "Trainer",
                    "hasActors": true,
                    "reward": 280,
                    "actors": [
                        FSP.MathDecider.compute("newPokemon", rivalTitle, 8),
                        FSP.MathDecider.compute("newPokemon", "PIDGEY".split(""), 9)
                    ]
                },
                "textStart": [
                    "".split(""),
                    " wants to fight!".split("")
                ],
                "textDefeat": [
                    "Yeah! Am I great or what?".split("")
                ],
                "textVictory": [
                    "Awww! You just lucked out!".split("")
                ],
                "keptThings": FSP.collectBattleKeptThings(FSP, ["player", "Rival"])
            }));
            FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        /* Memory
        */
        /**
         * Saves the positions of all Characters in the game.
         *
         * @param FSP
         */
        FullScreenPokemon.prototype.saveCharacterPositions = function (FSP) {
            var characters = FSP.GroupHolder.getGroup("Character"), character, id, i;
            for (i = 0; i < characters.length; i += 1) {
                character = characters[i];
                id = character.id;
                FSP.saveCharacterPosition(FSP, character, id);
            }
        };
        /**
         * Saves the position of a certain Character.
         *
         * @param FSP
         * @param character   An in-game Character.
         * @param id   The ID associated with the Character.
         */
        FullScreenPokemon.prototype.saveCharacterPosition = function (FSP, character, id) {
            FSP.StateHolder.addChange(id, "xloc", (character.left + FSP.MapScreener.left) / FSP.unitsize);
            FSP.StateHolder.addChange(id, "yloc", (character.top + FSP.MapScreener.top) / FSP.unitsize);
            FSP.StateHolder.addChange(id, "direction", character.direction);
        };
        /**
         * Saves all persistant information about the
         * current game state.
         */
        FullScreenPokemon.prototype.saveGame = function () {
            var ticksRecorded = this.FPSAnalyzer.getNumRecorded();
            this.ItemsHolder.setItem("map", this.AreaSpawner.getMapName());
            this.ItemsHolder.setItem("area", this.AreaSpawner.getAreaName());
            this.ItemsHolder.setItem("location", this.AreaSpawner.getLocationEntered().name);
            this.ItemsHolder.increase("time", ticksRecorded - this.ticksElapsed);
            this.ticksElapsed = ticksRecorded;
            this.saveCharacterPositions(this);
            this.ItemsHolder.saveAll();
            this.StateHolder.saveCollection();
            this.MenuGrapher.createMenu("GeneralText");
            this.MenuGrapher.addMenuDialog("GeneralText", [
                "Now saving..."
            ]);
            this.TimeHandler.addEvent(this.MenuGrapher.registerB.bind(this.MenuGrapher), 49);
        };
        /**
         * Saves current game state and downloads
         * it onto the client's computer as a JSON file.
         */
        FullScreenPokemon.prototype.downloadSaveGame = function () {
            var link = document.createElement("a");
            this.saveGame();
            link.setAttribute("download", "FullScreenPokemon Save " + Date.now() + ".json");
            link.setAttribute("href", "data:text/json;charset=utf-8," + encodeURIComponent(this.LevelEditor.beautify(JSON.stringify(this.ItemsHolder.exportItems()))));
            this.container.appendChild(link);
            link.click();
            this.container.removeChild(link);
        };
        /**
         * Adds an in-game item to the character's bag.
         *
         * @param FSP
         * @param item    The item being stored.
         * @param amount   The quantity of this item being stored.
         */
        FullScreenPokemon.prototype.addItemToBag = function (FSP, item, amount) {
            if (amount === void 0) { amount = 1; }
            FSP.combineArrayMembers(FSP.ItemsHolder.getItem("items"), item, amount, "item", "amount");
        };
        /* Map sets
        */
        /**
         * Sets the game state to a new Map, resetting all Things and inputs in the
         * process. The mod events are fired.
         *
         * @param name   The name of the Map.
         * @param location   The name of the Location within the Map.
         * @param noEntrance    Whether or not an entry Function should
         *                      be skipped (by default, false).
         * @remarks Most of the work here is done by setLocation.
         */
        FullScreenPokemon.prototype.setMap = function (name, location, noEntrance) {
            var map;
            if (typeof name === "undefined" || name.constructor === FullScreenPokemon) {
                name = this.AreaSpawner.getMapName();
            }
            map = this.AreaSpawner.setMap(name);
            this.ModAttacher.fireEvent("onPreSetMap", map);
            this.NumberMaker.resetFromSeed(map.seed);
            this.InputWriter.restartHistory();
            this.ModAttacher.fireEvent("onSetMap", map);
            this.setLocation(location
                || map.locationDefault
                || this.settings.maps.locationDefault, noEntrance);
        };
        /**
         * Sets the game state to a Location within the current map, resetting all
         * Things, inputs, the current Area, PixelRender, and MapScreener in the
         * process. The Location's entry Function is called to bring a new Player
         * into the game if specified. The mod events are fired.
         *
         * @param name   The name of the Location within the Map.
         * @param noEntrance   Whether or not an entry Function should
         *                     be skipped (by default, false).
         */
        FullScreenPokemon.prototype.setLocation = function (name, noEntrance) {
            var location, theme;
            name = name || "0";
            this.AudioPlayer.clearAll();
            this.GroupHolder.clearArrays();
            this.MapScreener.clearScreen();
            this.MapScreener.thingsById = this.generateThingsByIdContainer();
            this.MenuGrapher.setActiveMenu();
            this.TimeHandler.cancelAllEvents();
            this.AreaSpawner.setLocation(name);
            this.MapScreener.setVariables();
            location = this.AreaSpawner.getLocation(name);
            location.area.spawnedBy = {
                "name": name,
                "timestamp": new Date().getTime()
            };
            this.ModAttacher.fireEvent("onPreSetLocation", location);
            this.PixelDrawer.setBackground(this.AreaSpawner.getArea().background);
            this.StateHolder.setCollection(location.area.map.name + "::" + location.area.name);
            this.QuadsKeeper.resetQuadrants();
            theme = location.theme || location.area.theme || location.area.map.theme;
            this.MapScreener.theme = theme;
            if (theme && this.AudioPlayer.getThemeName() !== theme) {
                this.AudioPlayer.playTheme(theme);
            }
            if (!noEntrance) {
                location.entry(this, location);
            }
            this.ModAttacher.fireEvent("onSetLocation", location);
            this.GamesRunner.play();
            this.animateFadeFromColor(this, {
                "color": "Black"
            });
            if (location.push) {
                this.animateCharacterStartWalking(this.player, this.player.direction);
            }
        };
        /**
         * Determines the in-game measurements of the
         * boundaries of the current Area.
         *
         * @param FSP
         * @returns The boundaries of the current Area.
         */
        FullScreenPokemon.prototype.getAreaBoundariesReal = function (FSP) {
            var area = FSP.AreaSpawner.getArea();
            if (!area) {
                return {
                    "top": 0,
                    "right": 0,
                    "bottom": 0,
                    "left": 0,
                    "width": 0,
                    "height": 0
                };
            }
            return {
                "top": area.boundaries.top * FSP.unitsize,
                "right": area.boundaries.right * FSP.unitsize,
                "bottom": area.boundaries.bottom * FSP.unitsize,
                "left": area.boundaries.left * FSP.unitsize,
                "width": (area.boundaries.right - area.boundaries.left) * FSP.unitsize,
                "height": (area.boundaries.bottom - area.boundaries.top) * FSP.unitsize
            };
        };
        /**
         * Determines the scrollable directions.
         *
         * @param FSP
         * @returns The direction(s) that are scrollable.
         * @todo Strict type the returned string to a new IScrollability.
         *       When TypeScript 1.8 is out of beta, we'll be able to use
         *       string literals as types. This would be
         *       "both" | "horizontal" | "vertical" | "none".
         */
        FullScreenPokemon.prototype.getScreenScrollability = function (FSP) {
            var area = FSP.AreaSpawner.getArea(), boundaries, width, height;
            if (!area) {
                return Scrollability.None;
            }
            boundaries = area.boundaries;
            width = (boundaries.right - boundaries.left) * FSP.unitsize;
            height = (boundaries.bottom - boundaries.top) * FSP.unitsize;
            if (width > FSP.MapScreener.width) {
                if (height > FSP.MapScreener.height) {
                    return Scrollability.Both;
                }
                return Scrollability.Horizontal;
            }
            if (height > FSP.MapScreener.height) {
                return Scrollability.Vertical;
            }
            return Scrollability.None;
        };
        /**
         *
         */
        FullScreenPokemon.prototype.generateThingsByIdContainer = function () {
            return {};
        };
        /**
         * Analyzes a PreThing to be placed in one of the
         * cardinal directions of the current Map's boundaries
         * (just outside of the current Area).
         *
         * @param prething   A PreThing whose Thing is to be added to the game.
         * @param direction   The cardinal direction the Character is facing.
         * @remarks Direction is taken in by the .forEach call as the index.
         */
        FullScreenPokemon.prototype.mapAddAfter = function (prething, direction) {
            var MapsCreator = this.MapsCreator, AreaSpawner = this.AreaSpawner, prethings = AreaSpawner.getPreThings(), area = AreaSpawner.getArea(), map = AreaSpawner.getMap(), boundaries = this.AreaSpawner.getArea().boundaries;
            prething.direction = direction;
            switch (direction) {
                case 0:
                    prething.x = boundaries.left;
                    prething.y = boundaries.top - 8;
                    prething.width = boundaries.right - boundaries.left;
                    break;
                case 1:
                    prething.x = boundaries.right;
                    prething.y = boundaries.top;
                    prething.height = boundaries.bottom - boundaries.top;
                    break;
                case 2:
                    prething.x = boundaries.left;
                    prething.y = boundaries.bottom;
                    prething.width = boundaries.right - boundaries.left;
                    break;
                case 3:
                    prething.x = boundaries.left - 8;
                    prething.y = boundaries.top;
                    prething.height = boundaries.bottom - boundaries.top;
                    break;
                default:
                    throw new Error("Unknown direction: " + direction + ".");
            }
            MapsCreator.analyzePreSwitch(prething, prethings, area, map);
        };
        /* Map entrances
        */
        /**
         * Centers the current view of the Map based on scrollability.
         *
         * @param FSP
         */
        FullScreenPokemon.prototype.centerMapScreen = function (FSP) {
            switch (FSP.MapScreener.scrollability) {
                case Scrollability.None:
                    FSP.centerMapScreenHorizontally(FSP);
                    FSP.centerMapScreenVertically(FSP);
                    return;
                case Scrollability.Vertical:
                    FSP.centerMapScreenHorizontally(FSP);
                    FSP.centerMapScreenVerticallyOnPlayer(FSP);
                    return;
                case Scrollability.Horizontal:
                    FSP.centerMapScreenHorizontallyOnPlayer(FSP);
                    FSP.centerMapScreenVertically(FSP);
                    return;
                case Scrollability.Both:
                    FSP.centerMapScreenHorizontallyOnPlayer(FSP);
                    FSP.centerMapScreenVerticallyOnPlayer(FSP);
                    return;
                default:
                    return;
            }
        };
        /**
         * Scrolls the game window horizontally until the Map is centered based on
         * the Area.
         *
         * @param FSP
         */
        FullScreenPokemon.prototype.centerMapScreenHorizontally = function (FSP) {
            var boundaries = FSP.MapScreener.boundaries, difference = FSP.MapScreener.width - boundaries.width;
            if (difference > 0) {
                FSP.scrollWindow(difference / -2);
            }
        };
        /**
         * Scrolls the game window vertically until the Map is centered based on
         * the Area.
         *
         * @param FSP
         */
        FullScreenPokemon.prototype.centerMapScreenVertically = function (FSP) {
            var boundaries = FSP.MapScreener.boundaries, difference = FSP.MapScreener.height - boundaries.height;
            FSP.scrollWindow(0, difference / -2);
        };
        /**
         * Scrolls the game window horizontally until the Map is centered on the player.
         *
         * @param FSP
         */
        FullScreenPokemon.prototype.centerMapScreenHorizontallyOnPlayer = function (FSP) {
            var difference = (FSP.getMidX(FSP.player) - FSP.MapScreener.middleX) | 0;
            if (Math.abs(difference) > 0) {
                FSP.scrollWindow(difference);
            }
        };
        /**
         * Scrolls the game window vertically until the Map is centered on the player.
         *
         * @param FSP
         */
        FullScreenPokemon.prototype.centerMapScreenVerticallyOnPlayer = function (FSP) {
            var difference = (FSP.getMidY(FSP.player) - FSP.MapScreener.middleY) | 0;
            if (Math.abs(difference) > 0) {
                FSP.scrollWindow(0, difference);
            }
        };
        /**
         * A blank Map entrance Function where no Character is placed.
         *
         * @param FSP
         */
        FullScreenPokemon.prototype.mapEntranceBlank = function (FSP) {
            FSP.addPlayer(0, 0);
            FSP.player.hidden = true;
        };
        /**
         * Standard Map entrance Function. Character is placed based on specified Location.
         *
         * @param FSP
         * @param location   The name of the Location within the Map.
         */
        FullScreenPokemon.prototype.mapEntranceNormal = function (FSP, location) {
            FSP.addPlayer(location.xloc ? location.xloc * FSP.unitsize : 0, location.yloc ? location.yloc * FSP.unitsize : 0);
            FSP.animateCharacterSetDirection(FSP.player, (typeof location.direction === "undefined"
                ? FSP.MapScreener.playerDirection
                : location.direction)
                || 0);
            FSP.centerMapScreen(FSP);
            if (location.cutscene) {
                FSP.ScenePlayer.startCutscene(location.cutscene, {
                    "player": FSP.player
                });
            }
            if (location.routine && FSP.ScenePlayer.getCutsceneName()) {
                FSP.ScenePlayer.playRoutine(location.routine);
            }
        };
        /**
         * Map entrace Function used when player is added to the Map at the beginning
         * of play. Retrieves Character position from the previous save state.
         *
         * @param FSP
         */
        FullScreenPokemon.prototype.mapEntranceResume = function (FSP) {
            var savedInfo = FSP.StateHolder.getChanges("player") || {};
            FSP.addPlayer(savedInfo.xloc || 0, savedInfo.yloc || 0, true);
            FSP.animateCharacterSetDirection(FSP.player, savedInfo.direction || Direction.Top);
            FSP.centerMapScreen(FSP);
        };
        /* Map macros
        */
        /**
         * Macro Function used to create an alternating pattern of Things.
         *
         * @param reference   Settings for a Checkered macro.
         * @returns A checkered pattern of Things.
         */
        FullScreenPokemon.prototype.macroCheckered = function (reference) {
            var xStart = reference.x || 0, yStart = reference.y || 0, xnum = reference.xnum || 1, ynum = reference.ynum || 1, xwidth = reference.xwidth || 8, yheight = reference.yheight || 8, offset = reference.offset || 0, things = reference.things, mod = things.length, output = [], thing, x, y, i, j;
            y = yStart;
            for (i = 0; i < ynum; i += 1) {
                x = xStart;
                for (j = 0; j < xnum; j += 1) {
                    thing = reference.things[(i + j + offset) % mod];
                    if (thing !== "") {
                        output.push({
                            "x": x,
                            "y": y,
                            "thing": thing
                        });
                    }
                    x += xwidth;
                }
                y += yheight;
            }
            return output;
        };
        /**
         * Macro Function used to create a body of water.
         *
         * @param reference   Settings for a Water macro.
         * @returns A body of water.
         */
        FullScreenPokemon.prototype.macroWater = function (reference) {
            var x = reference.x || 0, y = reference.y || 0, width = reference.width || 8, height = reference.height || 8, open = reference.open || [true, true, true, true], output = [{
                    "thing": "Water",
                    "x": x,
                    "y": y,
                    "width": width,
                    "height": height
                }];
            if (!open[0]) {
                output.push({
                    "thing": "WaterEdgeTop",
                    "x": x,
                    "y": y,
                    "width": width
                });
            }
            if (!open[1]) {
                output.push({
                    "thing": "WaterEdgeRight",
                    "x": x + width - 4,
                    "y": open[0] ? y : y + 4,
                    "height": open[0] ? height : height - 4
                });
            }
            if (!open[2]) {
                output.push({
                    "thing": "WaterEdgeBottom",
                    "x": x,
                    "y": y + height - 4,
                    "width": width
                });
            }
            if (!open[3]) {
                output.push({
                    "thing": "WaterEdgeLeft",
                    "x": x,
                    "y": y,
                    "height": height
                });
            }
            return output;
        };
        /**
         * Macro Function used to create a House.
         *
         * @param reference   Settings for a House macro.
         * @returns A House.
         */
        FullScreenPokemon.prototype.macroHouse = function (reference) {
            var x = reference.x || 0, y = reference.y || 0, width = reference.width || 32, stories = reference.stories || 1, output = [], door, i;
            if (stories === 1) {
                output.push({
                    "thing": "HouseTopRoofLeft",
                    "x": x,
                    "y": y
                });
                output.push({
                    "thing": "HouseTopRoof",
                    "x": x + 8,
                    "y": y,
                    "width": width - 16
                });
                output.push({
                    "thing": "HouseTopRoofRight",
                    "x": x + width - 8,
                    "y": y
                });
                output.push({
                    "thing": "HouseLeft",
                    "x": x,
                    "y": y + 8
                });
                output.push({
                    "thing": "HouseRight",
                    "x": x + width - 8,
                    "y": y + 8
                });
                if (reference.door) {
                    output.push({
                        "thing": "HouseMiddle",
                        "x": x + 16,
                        "y": y + 8,
                        "width": width - 24
                    });
                }
                else {
                    output.push({
                        "thing": "HouseMiddle",
                        "x": x + 8,
                        "y": y + 8,
                        "width": width - 16
                    });
                }
            }
            else {
                output.push({
                    "thing": "HouseTop",
                    "x": x,
                    "y": y
                });
            }
            y += 16;
            for (i = 1; i < stories; i += 1) {
                output.push({
                    "thing": "HouseCenterLeft",
                    "x": x,
                    "y": y
                });
                output.push({
                    "thing": "HouseCenterRight",
                    "x": x + 16,
                    "y": y,
                    "width": width - 16
                });
                y += 8;
            }
            if (reference.door) {
                door = {
                    "thing": "Door",
                    "x": x + 8,
                    "y": y - 8,
                    "requireDirection": 0
                };
                if (reference.entrance) {
                    door.entrance = reference.entrance;
                }
                if (reference.transport) {
                    door.transport = reference.transport;
                }
                output.push(door);
            }
            return output;
        };
        /**
         * Macro Function used to create a Large House.
         *
         * @param reference   Settings for a Large House macro.
         * @returns A Large House.
         */
        FullScreenPokemon.prototype.macroHouseLarge = function (reference) {
            var x = reference.x || 0, y = reference.y || 0, width = reference.width || 48, stories = reference.stories || 1, doorOffset = reference.doorOffset || 16, output = [
                {
                    "thing": "HouseLargeTopLeft",
                    "x": x,
                    "y": y
                }, {
                    "thing": "HouseLargeTopMiddle",
                    "x": x + 8,
                    "y": y,
                    "width": width - 16
                }, {
                    "thing": "HouseLargeTopRight",
                    "x": x + width - 8,
                    "y": y
                }], door, i;
            y += 20;
            for (i = 2; i < stories; i += 1) {
                output.push({
                    "thing": "HouseLargeCenter",
                    "x": x,
                    "y": y,
                    "width": width
                });
                if (reference.white) {
                    output.push({
                        "thing": "HouseWallWhitewash",
                        "x": reference.white.start,
                        "y": y,
                        "width": reference.white.end - reference.white.start,
                        "position": "end"
                    });
                }
                y += 16;
            }
            if (!reference.door) {
                output.push({
                    "thing": "HouseLargeCenterLeft",
                    "x": x,
                    "y": y,
                    "width": 16
                });
                output.push({
                    "thing": "HouseLargeCenterMiddle",
                    "x": x + 16,
                    "y": y,
                    "width": 8
                });
                output.push({
                    "thing": "HouseLargeCenterRight",
                    "x": x + 24,
                    "y": y,
                    "width": width - 24
                });
            }
            else {
                output.push({
                    "thing": "HouseLargeCenterLeft",
                    "x": x,
                    "y": y,
                    "width": doorOffset
                });
                output.push({
                    "thing": "HouseLargeCenterMiddle",
                    "x": x + doorOffset,
                    "y": y,
                    "width": 8,
                    "height": 4
                });
                output.push({
                    "thing": "HouseLargeCenterRight",
                    "x": x + doorOffset + 8,
                    "y": y,
                    "width": width - doorOffset - 8
                });
                if (reference.white) {
                    output.push({
                        "thing": "HouseWallWhitewash",
                        "x": reference.white.start,
                        "y": y,
                        "width": reference.white.end - reference.white.start,
                        "position": "end"
                    });
                }
                y += 16;
                door = {
                    "thing": "Door",
                    "x": x + doorOffset,
                    "y": y - 12,
                    "requireDirection": 0,
                    "id": reference.id
                };
                if (reference.entrance) {
                    door.entrance = reference.entrance;
                }
                if (reference.transport) {
                    door.transport = reference.transport;
                }
                output.push(door);
            }
            return output;
        };
        /**
         * Macro Function used to create a Gym.
         *
         * @param reference   Settings for a Gym macro.
         * @returns A Gym.
         */
        FullScreenPokemon.prototype.macroGym = function (reference) {
            var x = reference.x || 0, y = reference.y || 0, width = reference.width || 48, stories = reference.stories || 2, output = [
                {
                    "macro": "HouseLarge",
                    "x": x,
                    "y": y,
                    "width": width,
                    "stories": stories,
                    "white": {
                        "start": x + 4,
                        "end": x + width - 4
                    },
                    "transport": reference.transport,
                    "entrance": reference.entrance,
                    "door": true,
                    "doorOffset": width - 16
                }, {
                    "thing": "GymLabel",
                    "x": x + 16,
                    "y": y + 16,
                    "width": width - 32
                }];
            return output;
        };
        /**
         * Macro Function used to create a Building.
         *
         * @param reference   Settings for a Building macro.
         * @returns A Building.
         */
        FullScreenPokemon.prototype.macroBuilding = function (reference) {
            var x = reference.x || 0, y = reference.y || 0, width = reference.width || 32, stories = reference.stories || 1, doorOffset = reference.doorOffset || 8, output = [
                {
                    "thing": "BuildingTopLeft",
                    "x": x,
                    "y": y
                }, {
                    "thing": "BuildingTopMiddle",
                    "x": x + 4,
                    "y": y,
                    "width": width - 8
                }, {
                    "thing": "BuildingTopRight",
                    "x": x + width - 4,
                    "y": y
                }], door, i;
            y += 16;
            for (i = 0; i < stories; i += 1) {
                output.push({
                    "thing": "BuildingMiddleLeft",
                    "x": x,
                    "y": y
                });
                output.push({
                    "thing": "BuildingMiddleWindow",
                    "x": x + 4,
                    "y": y,
                    "width": width - 8,
                    "height": 4
                });
                output.push({
                    "thing": "BuildingMiddleMiddle",
                    "x": x + 4,
                    "y": y + 4,
                    "width": width - 8,
                    "height": 4
                });
                output.push({
                    "thing": "BuildingMiddleRight",
                    "x": x + width - 4,
                    "y": y
                });
                y += 8;
            }
            output.push({
                "thing": "BuildingMiddleLeft",
                "x": x,
                "y": y,
                "height": 4
            });
            output.push({
                "thing": "BuildingMiddleRight",
                "x": x + width - 4,
                "y": y,
                "height": 4
            });
            if (reference.door) {
                door = {
                    "thing": "Door",
                    "x": x + doorOffset,
                    "y": y,
                    "entrance": reference.entrance
                };
                if (reference.entrance) {
                    door.entrance = reference.entrance;
                }
                if (reference.transport) {
                    door.transport = reference.transport;
                }
                output.push({
                    "thing": "BuildingMiddleMiddle",
                    "x": x + 4,
                    "y": y,
                    "height": 4,
                    "width": doorOffset - 4
                });
                output.push(door);
                output.push({
                    "thing": "BuildingMiddleMiddle",
                    "x": x + doorOffset + 8,
                    "y": y,
                    "height": 4,
                    "width": width - doorOffset - 8
                });
                output.push({
                    "thing": "BuildingBottomLeft",
                    "x": x,
                    "y": y + 4,
                    "width": doorOffset
                });
                output.push({
                    "thing": "BuildingBottomRight",
                    "x": x + doorOffset + 8,
                    "y": y + 4,
                    "width": width - doorOffset - 8
                });
            }
            else {
                output.push({
                    "thing": "BuildingMiddleMiddle",
                    "x": x + 4,
                    "y": y,
                    "width": width - 8,
                    "height": 4
                });
                output.push({
                    "thing": "BuildingBottom",
                    "x": x,
                    "y": y + 4,
                    "width": width
                });
            }
            if (reference.label) {
                output.push({
                    "thing": reference.label + "Label",
                    "x": x + 16,
                    "y": y
                });
            }
            return output;
        };
        /**
         * Macro Function used to create a Mountain.
         *
         * @param reference   Settings for a Mountain macro.
         * @returns A Mountain.
         */
        FullScreenPokemon.prototype.macroMountain = function (reference) {
            var x = reference.x || 0, y = reference.y || 0, width = reference.width || 8, height = reference.height || 8, openingOffset = reference.openingOffset || 8, output = [];
            if (reference.right) {
                if (reference.top) {
                    output.push({
                        "thing": "MountainTopRight",
                        "x": x + width - 8,
                        "y": y
                    });
                    output.push({
                        "thing": "MountainRight",
                        "x": x + width - 8,
                        "y": y + 4
                    });
                    output.push({
                        "thing": "MountainTopRight",
                        "x": x + width - 4,
                        "y": y + 4
                    });
                }
                else {
                    output.push({
                        "thing": "MountainRight",
                        "x": x + width - 8,
                        "y": y,
                        "width": 8,
                        "height": 8
                    });
                }
                if (reference.bottom) {
                    output.push({
                        "thing": "MountainBottomRight",
                        "x": x + width - 8,
                        "y": y + height - 8
                    });
                    output.push({
                        "thing": "MountainRight",
                        "x": x + width - 4,
                        "y": y + height - 8
                    });
                    output.push({
                        "thing": "MountainBottom",
                        "x": x + width - 8,
                        "y": y + height - 4
                    });
                    output.push({
                        "thing": "MountainBottomRight",
                        "x": x + width - 4,
                        "y": y + height - 4
                    });
                }
                else {
                    output.push({
                        "thing": "MountainRight",
                        "x": x + width - 8,
                        "y": y + height - 8,
                        "width": 8,
                        "height": 8
                    });
                }
                if (height > 16) {
                    output.push({
                        "thing": "MountainRight",
                        "x": x + width - 8,
                        "y": y + 8,
                        "width": 8,
                        "height": height - 16
                    });
                }
                width -= 8;
            }
            if (reference.left) {
                if (reference.top) {
                    output.push({
                        "thing": "MountainTopLeft",
                        "x": x + 4,
                        "y": y
                    });
                    output.push({
                        "thing": "MountainTopLeft",
                        "x": x,
                        "y": y + 4
                    });
                    output.push({
                        "thing": "MountainLeft",
                        "x": x + 4,
                        "y": y + 4
                    });
                }
                else {
                    output.push({
                        "thing": "MountainLeft",
                        "x": x,
                        "y": y,
                        "width": 8,
                        "height": 8
                    });
                }
                if (reference.bottom) {
                    output.push({
                        "thing": "MountainLeft",
                        "x": x,
                        "y": y + height - 8
                    });
                    output.push({
                        "thing": "MountainBottomLeft",
                        "x": x + 4,
                        "y": y + height - 8
                    });
                    output.push({
                        "thing": "MountainBottomLeft",
                        "x": x,
                        "y": y + height - 4
                    });
                    output.push({
                        "thing": "MountainBottom",
                        "x": x + 4,
                        "y": y + height - 4
                    });
                }
                else {
                    output.push({
                        "thing": "MountainLeft",
                        "x": x,
                        "y": y + height - 8,
                        "width": 8,
                        "height": 8
                    });
                }
                if (height > 16) {
                    output.push({
                        "thing": "MountainLeft",
                        "x": x,
                        "y": y + 8,
                        "width": 8,
                        "height": height - 16
                    });
                }
                width -= 8;
                x += 8;
            }
            if (reference.top && width > 0) {
                output.push({
                    "thing": "MountainTop",
                    "x": x,
                    "y": y,
                    "width": width
                });
                y += 5;
                height -= 5;
            }
            if (reference.bottom && width > 0) {
                if (reference.opening) {
                    if (openingOffset > 0) {
                        output.push({
                            "thing": "MountainBottom",
                            "x": x,
                            "y": y + height - 8,
                            "width": openingOffset,
                            "height": 8
                        });
                    }
                    output.push({
                        "thing": "CaveOpening",
                        "x": x + openingOffset,
                        "y": y + height - 8,
                        "entrance": reference.entrance,
                        "transport": reference.transport
                    });
                    if (openingOffset < width) {
                        output.push({
                            "thing": "MountainBottom",
                            "x": x + openingOffset + 8,
                            "y": y + height - 8,
                            "width": width - openingOffset - 8,
                            "height": 8
                        });
                    }
                }
                else {
                    output.push({
                        "thing": "MountainBottom",
                        "x": x,
                        "y": y + height - 8,
                        "width": width,
                        "height": 8
                    });
                }
                height -= 8;
            }
            if (width > 0 && height > 0) {
                output.push({
                    "thing": "Mountain",
                    "x": x,
                    "y": y,
                    "width": width,
                    "height": height
                });
            }
            return output;
        };
        /**
         * Macro Function used to create a Pokemon Center.
         *
         * @param reference   Settings for a Pokemon Center macro.
         * @returns A Pokemon Center.
         */
        FullScreenPokemon.prototype.macroPokeCenter = function (reference) {
            var x = reference.x || 0, y = reference.y || 0, output = [
                {
                    "thing": "FloorDiamonds",
                    "width": 112,
                    "height": 64,
                    "x": x,
                    "y": y
                }, {
                    "thing": "SquareWallTop",
                    "x": x,
                    "y": y,
                    "height": 16
                }, {
                    "thing": "HealingMachine",
                    "x": x + 8,
                    "y": y,
                    "id": "HealingMachine"
                }, {
                    "thing": "WallIndoorHorizontalBandsDark",
                    "x": x + 8,
                    "y": y,
                    "width": 32
                }, {
                    "thing": "PokeCenterPoster",
                    "x": x + 28,
                    "y": y
                }, {
                    "thing": "SquareWallTop",
                    "x": x + 40,
                    "y": y,
                    "height": 16
                }, {
                    "thing": "WallIndoorHorizontalBandsDark",
                    "x": x + 48,
                    "y": y,
                    "width": 32
                }, {
                    "thing": "StairsVertical",
                    "x": x + 80,
                    "y": y
                }, {
                    "thing": "WallIndoorHorizontalBandsDark",
                    "x": x + 88,
                    "y": y
                }, {
                    "thing": "StairsVertical",
                    "x": x + 96,
                    "y": y
                }, {
                    "thing": "WallIndoorHorizontalBandsDark",
                    "x": x + 104,
                    "y": y
                }, {
                    "thing": "Nurse",
                    "id": "Nurse",
                    "x": x + 24,
                    "y": y + 8
                }, {
                    "thing": "SquareWallFront",
                    "x": x,
                    "y": y + 16
                }, {
                    "thing": "PokeCenterDeskLeft",
                    "x": x + 8,
                    "y": y + 16
                }, {
                    "thing": "PokeCenterDesk",
                    "x": x + 12,
                    "y": y + 16,
                    "width": 32
                }, {
                    "thing": "CutsceneResponder",
                    "x": x + 24,
                    "y": y + 16,
                    "cutscene": "PokeCenter",
                    "keepAlive": true
                }, {
                    "thing": "SquareWallFront",
                    "x": x + 40,
                    "y": y + 16
                }, {
                    "thing": "PokeCenterDesk",
                    "x": x + 48,
                    "y": y + 16,
                    "width": 32
                }, {
                    "thing": "PokeCenterDeskBlocker",
                    "x": x + 80,
                    "y": y + 16
                }, {
                    "thing": "DeskWoman",
                    "x": x + 88,
                    "y": y + 16,
                    "dialog": [
                        "Welcome to the Cable Club!",
                        "This area is reserved for 2 friends who are linked by cable."
                    ]
                }, {
                    "thing": "PokeCenterDeskBlocker",
                    "x": x + 96,
                    "y": y + 16
                }, {
                    "thing": "PokeCenterDesk",
                    "x": x + 104,
                    "y": y + 16
                }, {
                    "thing": "Buzzer",
                    "x": x + 28,
                    "y": y + 19
                }, {
                    "thing": "Computer",
                    "x": x + 104,
                    "y": y + 24
                }, {
                    "thing": "SofaLeft",
                    "x": x,
                    "y": y + 32
                }, {
                    "thing": "PottedPalmTree",
                    "x": x,
                    "y": y + 48,
                    "width": 16
                }, {
                    "thing": "PottedPalmTree",
                    "x": x + 48,
                    "y": y + 48,
                    "width": 16
                }, {
                    "thing": "PottedPalmTree",
                    "x": x + 96,
                    "y": y + 48,
                    "width": 16
                }, {
                    "thing": "Doormat",
                    "x": x + 24,
                    "y": y + 56,
                    "width": 16,
                    "entrance": reference.entrance
                }];
            if (reference.transport) {
                output.push({
                    "thing": "HiddenTransporter",
                    "x": x + 24,
                    "y": y + 56,
                    "width": 16,
                    "transport": reference.transport,
                    "requireDirection": 2
                });
            }
            if (!reference.excludeCoolTrainer) {
                output.push({
                    "thing": "CoolTrainerM",
                    "x": x,
                    "y": y + 32,
                    "offsetX": FullScreenPokemon.unitsize * 1.75,
                    "offsetY": 0,
                    "direction": 1,
                    "sitting": true,
                    "dialogDirections": true,
                    "dialog": reference.coolTrainerDialog || [
                        "",
                        "%%%%%%%POKEMON%%%%%%% CENTERs heal your tired, hurt, or fainted %%%%%%%POKEMON%%%%%%%!",
                        "",
                        ""
                    ]
                });
            }
            return output;
        };
        /**
         * Macro Function used to create a PokeMart.
         *
         * @param reference   Settings for a PokeMart macro.
         * @returns A PokeMart.
         */
        FullScreenPokemon.prototype.macroPokeMart = function (reference) {
            var x = reference.x || 0, y = reference.y || 0, output = [
                {
                    "thing": "WallIndoorHorizontalBandsDark",
                    "x": x,
                    "y": y,
                    "width": 16,
                    "height": 4
                }, {
                    "thing": "FloorDiamonds",
                    "x": x,
                    "y": y + 8,
                    "width": 64,
                    "height": 56
                }, {
                    "thing": "FloorDiamondsDark",
                    "x": x,
                    "y": y + 16,
                    "height": 8
                }, {
                    "thing": "StoreFridge",
                    "x": x + 16,
                    "y": y,
                    "width": 32
                }, {
                    "thing": "WallIndoorHorizontalBandsDark",
                    "x": x + 48,
                    "y": y,
                    "width": 16,
                    "height": 4
                }, {
                    "thing": "StoreSaleBin",
                    "x": x,
                    "y": y + 4,
                    "width": 16
                }, {
                    "thing": "StoreSaleBin",
                    "x": x + 48,
                    "y": y + 4,
                    "width": 16
                }, {
                    "thing": "StoreAisle",
                    "x": x,
                    "y": y + 24,
                    "height": 8
                }, {
                    "thing": "StoreAisle",
                    "x": x + 32,
                    "y": y + 24,
                    "width": 32
                }, {
                    "thing": "WallIndoorHorizontalBandsDark",
                    "x": x,
                    "y": y + 32
                }, {
                    "thing": "WallIndoorHorizontalBandsDark",
                    "x": x + 8,
                    "y": y + 32,
                    "height": 4
                }, {
                    "thing": "FloorDiamondsDark",
                    "x": x + 16,
                    "y": y + 32,
                    "height": 24
                }, {
                    "thing": "SquareWallTop",
                    "x": x + 8,
                    "y": y + 36,
                    "height": 16
                }, {
                    "thing": "Cashier",
                    "x": x,
                    "y": y + 40,
                    "direction": 1
                }, {
                    "thing": "FloorDiamondsDark",
                    "x": x,
                    "y": y + 40
                }, {
                    "thing": "Register",
                    "x": x + 8,
                    "y": y + 40,
                    "id": reference.responderId,
                    "activate": FullScreenPokemon.prototype.activateCutsceneResponder,
                    "cutscene": "PokeMart",
                    "keepAlive": true,
                    "items": reference.items,
                    "dialog": reference.responderDialog
                }, {
                    "thing": "PokeCenterDeskLeft",
                    "x": x,
                    "y": y + 48
                }, {
                    "thing": "PokeCenterDesk",
                    "x": x + 4,
                    "y": y + 48,
                    "width": 12
                }, {
                    "thing": "FloorDiamondsDark",
                    "x": x,
                    "y": y + 56
                }, {
                    "thing": "Doormat",
                    "x": x + 24,
                    "y": y + 56,
                    "width": 16,
                    "entrance": reference.entrance
                }];
            if (reference.transport) {
                output.push({
                    "thing": "HiddenTransporter",
                    "x": x + 24,
                    "y": y + 56,
                    "width": 16,
                    "transport": reference.transport,
                    "requireDirection": 2
                });
            }
            return output;
        };
        /* Miscellaneous utilities
        */
        /**
         * Creates a new String equivalent to an old String repeated any number of
         * times. If times is 0, a blank String is returned.
         *
         * @param {String} string   The characters to repeat.
         * @param {Number} [times]   How many times to repeat (by default, 1).
         */
        FullScreenPokemon.prototype.stringOf = function (str, times) {
            if (times === void 0) { times = 1; }
            return (times === 0) ? "" : new Array(1 + (times || 1)).join(str);
        };
        /**
         * Turns a Number into a String with a prefix added to pad it to a certain
         * number of digits.
         *
         * @param {Mixed} number   The original Number being padded.
         * @param {Number} size   How many digits the output must contain.
         * @param {Mixed} [prefix]   A prefix to repeat for padding (by default, "0").
         * @returns {String}
         * @example
         * makeDigit(7, 3); // '007'
         * makeDigit(7, 3, 1); // '117'
         */
        FullScreenPokemon.prototype.makeDigit = function (num, size, prefix) {
            return FullScreenPokemon.prototype.stringOf(prefix ? prefix.toString() : "0", Math.max(0, size - String(num).length)) + num;
        };
        /**
         * Checks all members of an Array to see if a specified key exists within one of them.
         *
         * @param array   The Array being checked.
         * @param key   The key being searched for.
         * @returns Whether the key exists within the Array members.
         */
        FullScreenPokemon.prototype.checkArrayMembersIndex = function (array, key) {
            var i;
            for (i = 0; i < array.length; i += 1) {
                if (array[i][key]) {
                    return true;
                }
            }
            return false;
        };
        /**
         * Function to add a stackable item to an Array. If it already exists,
         * the Function increases its value by count. Otherwise, it adds a new item
         * to the Array.
         *
         * @param array   The Array containing the stackable items.
         * @param title   The name of the stackable item to be added.
         * @param count   The number of these stackable items.
         * @param keyTitle   The key associated with the item's name.
         *                   i.e "item"
         * @param keyCount   The key associated with the item's count.
         *                   i.e. "amount"
         * @returns Whether the stackable item was newly added.
         */
        FullScreenPokemon.prototype.combineArrayMembers = function (array, title, count, keyTitle, keyCount) {
            var object, i;
            for (i = 0; i < array.length; i += 1) {
                object = array[i];
                if (array[i][keyTitle] === title) {
                    array[i][keyCount] += count;
                    return false;
                }
            }
            object = {};
            object[keyTitle] = title;
            object[keyCount] = count;
            array.push(object);
            return true;
        };
        /**
         * Displays a message to the user.
         *
         * @param thing   The Thing that triggered the error.
         * @param message   The message to be displayed.
         */
        FullScreenPokemon.prototype.displayMessage = function (thing, message) {
            if (thing.FSP.MenuGrapher.getActiveMenu()) {
                return;
            }
            thing.FSP.MenuGrapher.createMenu("GeneralText", {
                "deleteOnFinish": true
            });
            thing.FSP.MenuGrapher.addMenuDialog("GeneralText", [
                message
            ]);
            thing.FSP.MenuGrapher.setActiveMenu("GeneralText");
        };
        // For the sake of reset functions, constants are stored as members of the 
        // FullScreenPokemon Function itself - this allows prototype setters to use 
        // them regardless of whether the prototype has been instantiated yet.
        /**
         * Static settings passed to individual reset Functions.
         */
        FullScreenPokemon.settings = {
            "audio": undefined,
            "battles": undefined,
            "collisions": undefined,
            "devices": undefined,
            "editor": undefined,
            "generator": undefined,
            "groups": undefined,
            "events": undefined,
            "help": undefined,
            "items": undefined,
            "input": undefined,
            "maps": undefined,
            "math": undefined,
            "menus": undefined,
            "mods": undefined,
            "objects": undefined,
            "quadrants": undefined,
            "renderer": undefined,
            "runner": undefined,
            "scenes": undefined,
            "sprites": undefined,
            "states": undefined,
            "touch": undefined,
            "ui": undefined
        };
        /**
         * How much to expand each pixel from raw sizing measurements to in-game.
         */
        FullScreenPokemon.unitsize = 4;
        /**
         * Static scale of 2, to exand to two pixels per one game pixel.
         */
        FullScreenPokemon.scale = 2;
        /**
         * Quickly tapping direction keys means to look in a direction, not walk.
         */
        FullScreenPokemon.inputTimeTolerance = 4;
        /**
         * The allowed uppercase keys to be shown in a keyboard.
         */
        FullScreenPokemon.keysUppercase = [
            "A", "J", "S", "Times", "-",
            "B", "K", "T", "(", "?",
            "C", "L", "U", ")", "!",
            "D", "M", "V", ":", "MaleSymbol",
            "E", "N", "W", ";", "FemaleSymbol",
            "F", "O", "X", "[", "/",
            "G", "P", "Y", "]", ".",
            "H", "Q", "Z", "Poke", ",",
            "I", "R", " ", "Mon", "ED"
        ];
        /*
         * The allowed lowercase keys to be shown in a keyboard.
         */
        FullScreenPokemon.keysLowercase = [
            "a", "j", "s", "Times", "-",
            "b", "k", "t", "(", "?",
            "c", "l", "u", ")", "!",
            "d", "m", "v", ":", "MaleSymbol",
            "e", "n", "w", ";", "FemaleSymbol",
            "f", "o", "x", "[", "/",
            "g", "p", "y", "]", ".",
            "h", "q", "z", "Poke", ",",
            "i", "r", " ", "Mon", "ED"
        ];
        return FullScreenPokemon;
    })(GameStartr.GameStartr);
    FullScreenPokemon_1.FullScreenPokemon = FullScreenPokemon;
})(FullScreenPokemon || (FullScreenPokemon = {}));
